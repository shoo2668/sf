<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>배송 시트</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="manifest" href="manifest.json">
    <!-- ▼▼▼ [수정] theme-color에 id를 추가하여 JS로 제어할 수 있도록 함 ▼▼▼ -->
    <meta name="theme-color" content="#ffffff" id="theme-color-meta">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- ▼▼▼ [추가] Tailwind CSS CDN 버전을 위한 다크모드 설정 ▼▼▼ -->
    <script>
        tailwind.config = {
            darkMode: 'class', // 'class' 전략을 사용하여 <html> 태그에 'dark' 클래스가 있을 때 다크모드를 활성화합니다.
            theme: {
                extend: {
                    // 필요하다면 여기에 커스텀 테마를 추가할 수 있습니다.
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ▼▼▼ [수정] 설정 섹션 배경색에 CSS 변수 적용 ▼▼▼ */
        .setting-section {
            background-color: var(--card-bg);
            padding: 1rem; /* 16px */
            border-radius: 0.5rem; /* 8px */
            box-shadow: var(--card-shadow);
        }
        .setting-section-title {
            font-size: 1rem; /* 16px */
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem; /* 12px */
        }
        /* ▲▲▲ [추가 끝] ▲▲▲ */
        /* ▼▼▼ [추가] 새로운 테마 스위치 UI를 위한 스타일 ▼▼▼ */
#theme-switch-container.disabled {
    opacity: 0.5;
    pointer-events: none;
}
/* ▲▲▲ [추가 끝] ▲▲▲ */
        /* ▼▼▼ [수정] CSS 변수 정의 (라이트/다크 모드) ▼▼▼ */
        :root {
            --page-bg: #ffffff;
            --card-bg: #ffffff;
            --header-bg: #ffffff;
            --header-border: #e5e7eb;
            --badge-bg: #2563eb; /* <-- [추가] 라이트 모드 배지 배경 */
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --modal-bg: #ffffff;
            --active-btn-bg: #ffffff;
            --active-btn-shadow: 0 1px 3px rgba(0,0,0,0.1);
            --search-bar-border: #2563eb;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }

        html.dark {
            color-scheme: dark;
            --page-bg: #121212;
            --card-bg: #1e1e1e; 
            --header-bg: #1e1e1e;
            --header-border: #333333;
            --badge-bg: #616161; /* <-- [추가] 다크 모드 배지 배경 (무채색) */
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --modal-bg: #1e1e1e;
            --active-btn-bg: #333333;
            --active-btn-shadow: 0 1px 3px rgba(0,0,0,0.4);
            --search-bar-border: #3b82f6;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -2px rgba(0, 0, 0, 0.3);
        }
        /* ▲▲▲ [수정 끝] ▲▲▲ */

        /* ▼▼▼ [추가] 상단 필터 영역에 CSS 변수 적용 ▼▼▼ */
        #filter-buttons-container {
            background-color: var(--header-bg);
            border-bottom-color: var(--header-border);
        }
        /* ▲▲▲ [추가 끝] ▲▲▲ */

        .map-select-btn {
            color: var(--text-secondary);
        }
        .map-select-btn.active {
            background-color: var(--active-btn-bg);
            color: var(--text-primary);
            box-shadow: var(--active-btn-shadow);
        }
        .map-icon-button {
            width: 28px;
            height: 28px;
            flex-shrink: 0;
        }
        .map-icon-button.naver {
            background-color: #2DB400;
        }
        .map-icon-button.naver svg {
            stroke: white;
        }
        .map-icon-button.kakao {
            background-color: #FEE500;
        }
        .map-icon-button.kakao svg {
            stroke: #0085FF;
        }

        /* ▼▼▼ [추가] 바코드 스캔 버튼 터치 영역 확장 ▼▼▼ */
        #barcode-scan-button {
            position: relative; /* 가상 요소의 기준점이 됨 */
        }
        #barcode-scan-button::before {
            content: ''; /* 가상 요소 필수 속성 */
            position: absolute;
            /* 버튼의 상하좌우로 10px씩 영역을 확장 */
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            /* 터치 영역을 시각적으로 둥글게 (버튼 모양과 맞춤) */
            border-radius: 50%; 
        }
        /* ▲▲▲ [추가 끝] ▲▲▲ */

        /* ▼▼▼ [추가] 돋보기 아이콘 터치 영역 확장 ▼▼▼ */
        #search-scan-button {
            position: relative; /* 가상 요소의 기준점이 됨 */
            padding: 10px; /* 실제 터치 영역 확보를 위해 패딩 추가 */
            margin: -10px; /* 추가된 패딩만큼 마이너스 마진으로 레이아웃 유지 */
        }
        #search-scan-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
        }
        /* ▲▲▲ [추가 끝] ▲▲▲ */

        #refresh-indicator {
            transform: translateY(-100%);
            transition: transform 0.3s, opacity 0.3s;
            z-index: 10;
        }
        #refresh-indicator.visible {
            opacity: 1;
            transform: translateY(1rem);
        }
        html {
            scroll-behavior: smooth !important;
            height: 100%;
            overflow: auto; 
        }
        body {
            /* ▼▼▼ [추가] CSS 변수를 사용하여 body의 기본 배경/텍스트 색상 설정 ▼▼▼ */
            background-color: var(--page-bg);
            color: var(--text-primary);
            /* ▲▲▲ [추가 끝] ▲▲▲ */
            font-family: 'Inter', sans-serif;
            margin: 0;
            height: 100%;
            overflow-y: auto;
            overscroll-behavior: contain;
        }

        body.modal-open {
            overflow: hidden;
        }

        .signature-modal, .confirmation-modal, .smart-edit-modal, .number-jump-modal {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 50;
        }

        .confirmation-modal { z-index: 51; }

        /* ▼▼▼ [수정] 모달 배경색에 CSS 변수 적용 ▼▼▼ */
        .signature-modal-content, .confirmation-modal-content, .smart-edit-modal-content, .number-jump-modal-content {
            background-color: var(--modal-bg);
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            padding: 1.5rem;
            width: 100%;
            max-width: 28rem;
            max-height: calc(100vh - 3rem);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #smart-edit-scroll-area, #number-jump-list {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        #smart-edit-scroll-area, #number-jump-list, #manual-add-form-container {
            flex: 1 1 auto;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .key-button { position: relative; overflow: visible !important; -webkit-tap-highlight-color: transparent; }
        .key-pop {
            position: absolute;
            bottom: 80%;
            left: 50%;
            transform: translateX(-50%) scale(0.8);
            transform-origin: bottom center;
            background-color: #374151;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 1.25rem;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 10;
            min-width: 100%;
            text-align: center;
            white-space: nowrap;
        }
        .key-button:active .key-pop {
            opacity: 1;
            transform: translateX(-50%) scale(1) translateY(-8px);
        }
        .filter-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            border-radius: 9999px;
            background-color: var(--badge-bg); /* <-- [수정] CSS 변수 사용 */
            color: white;
            font-size: 12px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--header-bg);
            transition: transform 0.2s, opacity 0.2s;
            transform: scale(1);
            opacity: 1;
        }
        /* ▼▼▼ [삭제] 기존 다크모드 테두리 색상 지정 코드는 더 이상 필요 없음 ▼▼▼
        html.dark .filter-badge {
            border-color: #1f2937; 
        }
        */
        .filter-badge.hidden {
            transform: scale(0.5);
            opacity: 0;
            pointer-events: none;
        }
        #address-pieces-container button { margin: 0.25rem; padding: 0.25rem 0.75rem; border-radius: 9999px; font-size: 0.875rem; font-weight: 500; transition: background-color 0.2s; }

        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #2563eb; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        html.dark .spinner { border-left-color: #60a5fa; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .animate-slide-in-left { animation: slideInLeft 0.3s ease-out forwards; }
        @keyframes slideInLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .animate-slide-in-right { animation: slideInRight 0.3s ease-out forwards; }
        @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        #delivery-cards-container { transition: transform 0.1s ease-out; will-change: transform; }
        #toast-container { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; flex-direction: column; align-items: center; gap: 8px; pointer-events: none; }
        .toast-message { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 10px 20px; border-radius: 20px; font-size: 0.875rem; box-shadow: 0 2px 10px rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.5s, transform 0.5s; transform: translateY(20px); }
        html.dark .toast-message { background-color: rgba(240, 240, 240, 0.9); color: #111827; }
        .toast-message.show { opacity: 1; transform: translateY(0); }
        #number-jump-list { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem; overflow-y: auto; padding: 0.5rem; margin: -0.5rem; max-height: 60vh; }
        .number-jump-item { min-width: 50px; padding: 0.75rem; border-radius: 0.5rem; font-weight: 600; text-align: center; transition: background-color 0.2s, color 0.2s; }
        .number-jump-item.active { background-color: #2563eb; color: white; cursor: pointer; }
        .number-jump-item.active:hover { background-color: #1d4ed8; }
        .number-jump-item.inactive { background-color: #f3f4f6; color: #9ca3af; cursor: not-allowed; }
        html.dark .number-jump-item.inactive { background-color: #374151; color: #6b7280; }
        .number-jump-item.placeholder { background-color: transparent; }
        .bottom-bar { position: fixed; bottom: 0; left: 0; width: 100vw; z-index: 46; transition: transform 0.3s ease-out; background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border-top: 1px solid #e5e7eb; }
        html.dark .bottom-bar { background-color: rgba(31, 41, 55, 0.8); border-top-color: #4b5563; }
        .bottom-bar.hidden { transform: translateY(100%); }
        .completed-strikethrough {
            text-decoration: line-through;
            color: #6b7280; /* gray-500 */
        }
        html.dark .completed-strikethrough { color: #9ca3af; }
        #fab-options button {
            width: 0;
            padding: 0;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s ease-in-out;
        }
        #fab-options.expanded button {
            width: 3rem;
            padding: 0.75rem;
            opacity: 1;
            transform: scale(1);
        }
        /* ▼▼▼ [수정] 검색창 그림자 및 테두리에 CSS 변수 적용 ▼▼▼ */
        #search-bar {
            box-shadow: var(--card-shadow);
            border: 2px solid var(--search-bar-border);
            z-index: 45;
        }

        /* ▼▼▼ [추가] 참조용 주소 위치 이동 애니메이션 ▼▼▼ */
        #original-address-container {
            transition: transform 0.3s ease-in-out;
            will-change: transform;
        }
        /* ▲▲▲ [추가 끝] ▲▲▲ */
    </style>
</head>
<!-- ▼▼▼ [수정] CSS 변수로 색상을 제어하므로, 직접적인 색상 클래스 제거 ▼▼▼ -->
<body class="font-sans">
    <div id="app-container" class="h-screen flex flex-col">

        <!-- ▼▼▼ [수정] 상단 필터 컨테이너에서 직접 색상 지정 클래스 제거 ▼▼▼ -->
        <div id="filter-buttons-container" class="z-20 flex-shrink-0 shadow-md border-b">
            <div class="max-w-md mx-auto w-full min-w-[320px] p-2">
                <div class="flex justify-around">
                    <!-- 버튼들은 JS에서 동적으로 클래스가 제어됩니다 -->
                    <button data-filter="배송준비" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8"/><path d="M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg>
                    </button>
                    <button data-filter="전체" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M3 5h.01"/><path d="M3 12h.01"/><path d="M3 19h.01"/><path d="M8 5h13"/><path d="M8 12h13"/><path d="M8 19h13"/></svg>
                        <span id="count-전체" class="filter-badge">0</span>
                    </button>
                    <button data-filter="배송전" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z"/><path d="M12 22V12"/><polyline points="3.29 7 12 12 20.71 7"/><path d="m7.5 4.27 9 5.15"/></svg>
                        <span id="count-배송전" class="filter-badge">0</span>
                    </button>
                    <button data-filter="배송중" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M14 18V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v11a1 1 0 0 0 1 1h2"/><path d="M15 18H9"/><path d="M19 18h2a1 1 0 0 0 1-1v-3.65a1 1 0 0 0-.22-.624l-3.48-4.35A1 1 0 0 0 17.52 8H14"/><circle cx="17" cy="18" r="2"/><circle cx="7" cy="18" r="2"/></svg>
                        <span id="count-배송중" class="filter-badge">0</span>
                    </button>
                    <button data-filter="완료" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M21.801 10A10 10 0 1 1 17 3.335"/><path d="m9 11 3 3L22 4"/></svg>
                        <span id="count-완료" class="filter-badge">0</span>
                    </button>
                </div>
            </div>
        </div>

        <div id="main-content-wrapper" class="flex-1 overflow-y-auto min-h-0 relative" style="overscroll-behavior: contain;">
            <div id="refresh-indicator" class="absolute top-0 left-0 right-0 flex justify-center items-center h-12 opacity-0 transition-opacity duration-300 pointer-events-none">
                <div class="spinner"></div>
            </div>
            <div class="max-w-md mx-auto p-4 sm:p-6 lg:p-8">
          <!-- ▼▼▼ [수정] 설정 항목들을 재구성 ▼▼▼ -->
                <div id="scan-section-container" class="mb-6 setting-section w-full min-w-[320px] hidden">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3">송장 스캔하여 카드 생성</h3>
                    <div class="flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 sm:space-x-3">
                        <input type="file" id="deliverySheetImage" accept="image/*" multiple class="hidden"/>
                        <label for="deliverySheetImage" class="flex-1 w-full text-sm text-blue-700 dark:text-blue-300 py-2 px-4 rounded-md border border-blue-300 dark:border-blue-600 bg-blue-50 dark:bg-blue-900/30 font-semibold cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900/50 text-center whitespace-nowrap">사진 선택</label>
                        <button id="scanAndGenerateButton" class="w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">스캔하여 카드 생성</button>
                    </div>
                    <div id="selected-files-display" class="mt-2 text-sm text-gray-600 dark:text-gray-400 text-center">선택된 파일 없음</div>
                </div>

                <div id="data-management-container" class="w-full min-w-[320px] space-y-4 hidden">
                    <!-- ▼▼▼ [수정] 환경설정 섹션 (테마, 지도, 데이터 통합) ▼▼▼ -->
                    <div class="setting-section">
                        <!-- 테마 설정 항목 -->
                        <div class="flex items-center justify-between">
                            <h3 class="setting-section-title !mb-0">테마</h3>
                            <div class="flex items-center">
                                <!-- 라이트/다크 아이콘 스위치 -->
                                <div id="theme-switch-container" class="relative flex items-center p-1 rounded-md bg-gray-100 dark:bg-gray-700">
                                    <div id="theme-glider" class="absolute h-8 w-8 bg-white dark:bg-gray-500 rounded-md shadow-sm transition-all duration-300 ease-in-out"></div>
                                    <button id="light-theme-btn" data-theme="light" class="relative z-10 w-8 h-8 flex items-center justify-center text-gray-600 dark:text-gray-300">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
                                    </button>
                                    <button id="dark-theme-btn" data-theme="dark" class="relative z-10 w-8 h-8 flex items-center justify-center text-gray-600 dark:text-gray-300">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.985 12.486a9 9 0 1 1-9.473-9.472c.405-.022.617.46.402.803a6 6 0 0 0 8.268 8.268c.344-.215.825-.004.803.401"/></svg>
                                    </button>
                                </div>
                                <!-- 시스템 테마 토글 스위치 -->
                                <div class="flex items-center space-x-2 pl-3">
                                    <span class="text-sm font-medium text-gray-700 dark:text-gray-300">시스템</span>
                                    <label for="system-theme-toggle" class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="system-theme-toggle" class="sr-only peer">
                                        <div class="w-11 h-6 bg-gray-300 dark:bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- 구분선 -->
                        <hr class="my-4 border-gray-200 dark:border-gray-700">

                        <!-- 지도 설정 항목 -->
                        <div class="flex items-center justify-between">
                            <h3 class="setting-section-title !mb-0">지도</h3>
                            <div id="map-selection-container" class="flex space-x-1 rounded-lg bg-gray-100 dark:bg-gray-700 p-1">
                                <button data-map="naver" class="map-select-btn px-4 py-1 text-sm font-semibold rounded-md transition-colors">네이버</button>
                                <button data-map="kakao" class="map-select-btn px-4 py-1 text-sm font-semibold rounded-md transition-colors">카카오</button>
                            </div>
                        </div>

                        <!-- 구분선 -->
                        <hr class="my-4 border-gray-200 dark:border-gray-700">

                        <!-- 데이터 관리 항목 -->
                        <div class="flex items-center justify-between">
                            <h3 class="setting-section-title !mb-0">데이터 관리</h3>
                            <div class="flex items-center space-x-2">
                                <button id="exportDataButton" class="w-10 h-10 flex items-center justify-center rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"/><path d="M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7"/><path d="M7 3v4a1 1 0 0 0 1 1h7"/></svg>
                                </button>
                                <label for="importDataInput" class="w-10 h-10 flex items-center justify-center rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600 cursor-pointer">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"/></svg>
                                </label>
                                <input type="file" id="importDataInput" class="hidden" accept=".json"/>
                            </div>
                        </div>

                        <!-- ▼▼▼ [추가 시작] 수동 카드 추가 UI ▼▼▼ -->
                        <hr class="my-4 border-gray-200 dark:border-gray-700">
                        <div>
                            <h3 class="setting-section-title">수동 카드 추가</h3>
                            <button id="manual-add-card-button" class="w-full px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500">새 카드 생성</button>
                        </div>
                        <!-- ▲▲▲ [추가 끝] ▲▲▲ -->

                        <!-- 구분선 -->
                        <hr class="my-4 border-gray-200 dark:border-gray-700">

                        <!-- ▼▼▼ [추가 시작] 웹훅 설정 UI ▼▼▼ -->
                        <div>
                            <h3 class="setting-section-title">웹훅 (자동화)</h3>
                            <div class="flex items-center space-x-2">
                                <input type="url" id="webhook-url-input" placeholder="웹훅 URL을 입력하세요" class="flex-grow px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 focus:ring-blue-500 focus:border-blue-500">
                                <button id="save-webhook-url-button" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-sm font-medium">저장</button>
                            </div>
                        </div>
                        <!-- ▲▲▲ [추가 끝] ▲▲▲ -->
                    </div>

                    <!-- 앱 초기화 섹션 -->
                    <div class="setting-section">
                        <h3 class="setting-section-title">앱 초기화</h3>
                        <button id="clearAllCardsButton" class="w-full px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">모든 카드 삭제</button>
                    </div>
                </div>
                
                <div id="version-info-container" class="mb-6 text-center hidden">
                    <p id="version-text" class="text-xs text-gray-600 dark:text-gray-400 font-mono"></p>
                    <p id="version-changelog" class="text-xs text-gray-500 dark:text-gray-500"></p>
                </div>

                <div id="delivery-cards-container" class="pb-14"></div>
            </div>
        </div>
    </div>

    <div id="toast-container"></div>

    <div id="search-bar-container" class="fixed bottom-0 left-0 w-full z-40">
        <div class="max-w-md mx-auto px-4 sm:px-6 lg:px-8 pb-3">
            <!-- ▼▼▼ [수정] 검색창에 다크모드 클래스 추가 ▼▼▼ -->
            <div id="search-bar" class="flex items-center w-full p-1.5 rounded-2xl bg-white/90 dark:bg-gray-800/80 backdrop-blur-md border dark:border-gray-600">
                <div id="search-scan-button" class="pl-2 pr-1 text-gray-400 dark:text-gray-500 cursor-pointer">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
                </div>
                <input type="tel" id="invoiceNumber" name="invoiceNumber" placeholder="송장번호 또는 전화번호 검색" class="flex-grow flex-shrink min-w-0 px-2 py-2 bg-transparent border-none focus:ring-0 outline-none text-base placeholder:text-gray-500 dark:placeholder:text-gray-400" inputmode="numeric" pattern="[0-9]*"/>
                <button id="barcode-scan-button" class="w-10 h-10 flex-shrink-0 flex items-center justify-center text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-teal-600 dark:text-teal-400"><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><path d="M8 7v10"/><path d="M12 7v10"/><path d="M17 7v10"/></svg>
                </button>
                <button id="resetButton" class="w-10 h-10 flex-shrink-0 flex items-center justify-center text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M10 5a2 2 0 0 0-1.344.519l-6.328 5.74a1 1 0 0 0 0 1.481l6.328 5.741A2 2 0 0 0 10 19h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2z"/><path d="m12 9 6 6"/><path d="m18 9-6 6"/></svg>
                </button>
            </div>
        </div>
    </div>

    <div id="action-bar-container" class="fixed bottom-0 left-0 w-full z-40 pointer-events-none">
        <div class="max-w-md mx-auto w-full min-w-[320px] p-4 flex justify-end">
            <!-- ▼▼▼ [수정] FAB 패널에 다크모드 클래스 추가 ▼▼▼ -->
            <div id="fab-panel" class="flex items-center space-x-1 p-1.5 rounded-full bg-white/80 dark:bg-gray-800/80 backdrop-blur-md shadow-lg border border-gray-200 dark:border-gray-600 pointer-events-auto">
                <div id="fab-options" class="flex items-center space-x-1"></div>
                <button id="fab-main-button" class="w-10 h-10 flex-shrink-0 flex items-center justify-center rounded-full transition-colors duration-200">
                </button>
            </div>
        </div>
    </div>

    <!-- 모달들은 CSS 변수를 통해 배경색이 제어됩니다. 내부 텍스트/버튼 색상만 조정합니다. -->
    <div id="number-jump-modal" class="number-jump-modal" style="display: none;">
        <div class="number-jump-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">번호로 이동</h2>
            <div id="number-jump-list"></div>
            <div class="flex justify-end mt-6">
                <button id="number-jump-close" class="px-4 py-2 bg-gray-400 dark:bg-gray-600 text-white rounded-md hover:bg-gray-500 dark:hover:bg-gray-500 text-sm font-medium">닫기</button>
            </div>
        </div>
    </div>

    <div id="signature-modal" class="signature-modal" style="display: none;">
        <div class="signature-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">서명 입력</h2>
            <div class="signature-input-container">
                <textarea id="signature-text-input" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200" rows="3" placeholder="여기에 서명 내용을 입력하세요."></textarea>
            </div>
            <div class="flex justify-end space-x-2 mt-4">
                <button id="clearSignature" class="px-4 py-2 rounded-md bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-sm font-medium hover:bg-gray-400 dark:hover:bg-gray-500">지우기</button>
                <button id="cancelSignature" class="px-4 py-2 rounded-md bg-red-500 text-white text-sm font-medium hover:bg-red-600">취소</button>
                <button id="saveSignature" class="px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">저장</button>
            </div>
        </div>
    </div>

    <div id="confirmation-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200" id="confirmation-modal-title">확인</h2>
            <div id="confirmation-modal-body">
                <p class="text-base text-gray-700 dark:text-gray-300 mb-6" id="confirmation-modal-message"></p>
            </div>
            <div class="flex justify-between space-x-2 mt-4" id="confirmation-modal-buttons">
                <button id="confirmCancelButton" class="w-1/2 px-4 py-2 rounded-md bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-sm font-medium hover:bg-gray-400 dark:hover:bg-gray-500">취소</button>
                <button id="confirmOkButton" class="w-1/2 px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">확인</button>
            </div>
        </div>
    </div>

    <div id="smart-edit-modal" class="smart-edit-modal" style="display: none;">
        <div class="smart-edit-modal-content">
            <div id="smart-edit-scroll-area">
                <div id="original-address-container" class="mb-4">
                    <h3 class="text-sm font-semibold text-gray-600 dark:text-gray-400 mb-1">AI 추출 원본 (참조용)</h3>
                    <p id="original-address-display" class="p-2 bg-gray-100 dark:bg-gray-700 rounded-md text-gray-800 dark:text-gray-300 text-sm font-mono break-all"></p>
                </div>

                <div class="mb-2">
                    <h3 class="text-sm font-semibold text-gray-600 dark:text-gray-400 mb-1">주소 조각 (클릭하여 추가)</h3>
                    <div id="address-pieces-container" class="flex flex-wrap p-2 bg-gray-50 dark:bg-gray-900 rounded-md border border-gray-200 dark:border-gray-600 min-h-[40px]"></div>
                </div>
                
                <div id="fixed-buttons-container" class="mt-2 grid grid-cols-2 gap-4">
                    <div id="number-keypad" class="grid grid-cols-3 gap-2"></div>
                    <div id="unit-keypad" class="grid grid-cols-2 gap-2"></div>
                </div>

                <hr class="my-4 border-gray-300 dark:border-gray-600"/>

                    <div id="editable-address-container" class="mt-4">
                    <div class="flex justify-between items-center mb-2">
                         <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200">주소 편집</h3>
                         <div class="flex items-center space-x-2">
                             <button id="revert-address-btn" class="p-1.5 text-blue-600 dark:text-blue-400 hover:bg-blue-100 dark:hover:bg-blue-900/30 rounded-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>
                            </button>
                             <button id="reset-address-btn" class="p-1.5 text-red-500 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                            </button>
                            <button id="apply-address-btn" class="px-4 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-sm font-medium">수정 완료</button>
                         </div>
                    </div>
                    <textarea id="editable-address-input" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:ring-blue-500 focus:border-blue-500 resize-none overflow-hidden" rows="2"></textarea>
                </div>

            </div>
            <div class="flex justify-end mt-auto pt-4 border-t border-gray-200 dark:border-gray-700">
                <button id="smart-edit-exit" class="px-4 py-2 bg-gray-400 dark:bg-gray-600 text-white rounded-md hover:bg-gray-500 dark:hover:bg-gray-500 text-sm font-medium">나가기</button>
            </div>
        </div>
    </div>

    <div id="completion-options-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-6 text-gray-800 dark:text-gray-200" id="completion-options-title">완료 옵션 선택</h2>
            <div id="completion-options-list" class="space-y-3"></div>
            <div class="flex justify-end mt-8">
                <button id="completion-options-cancel" class="px-4 py-2 bg-gray-400 dark:bg-gray-600 text-white rounded-md hover:bg-gray-500 dark:hover:bg-gray-500 text-sm font-medium">취소</button>
            </div>
        </div>
    </div>

    <div id="delivery-location-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200" id="delivery-location-title">배송 위치 선택</h2>
            <div id="delivery-location-card-info" class="mb-4"></div>
            <div id="delivery-location-options" class="space-y-1"></div>
            <!-- ▼▼▼ [수정] 버튼 컨테이너에 id 추가 ▼▼▼ -->
            <div id="delivery-location-buttons" class="flex justify-between space-x-2 mt-6">
                <!-- 버튼들은 JS에서 동적으로 생성됩니다. -->
            </div>
        </div>
    </div>

    <div id="scan-progress-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">송장 스캔 진행 중</h2>
            <div class="flex flex-col items-center justify-center p-4">
                <div class="spinner mb-4"></div>
                <p id="scan-progress-modal-text" class="text-base text-gray-700 dark:text-gray-300 text-center">스캔을 준비 중입니다...</p>
            </div>
            <div class="flex justify-end mt-6">
                <button id="scan-progress-cancel-btn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 text-sm font-medium">닫기</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ [추가 시작] 수동 카드 추가 모달 ▼▼▼ -->
    <div id="manual-add-card-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">수동 카드 추가</h2>
            <div id="manual-add-form-container" class="flex-1 overflow-y-auto -mr-4 pr-4 space-y-3">
                <div>
                    <label for="manual-no-input" class="text-sm font-medium text-gray-700 dark:text-gray-300">순번 (자동)</label>
                    <input type="tel" id="manual-no-input" readonly class="mt-1 w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-gray-100 dark:bg-gray-800">
                </div>
                <div>
                    <label for="manual-hawb-input" class="text-sm font-medium text-gray-700 dark:text-gray-300">송장번호 (선택)</label>
                    <input type="tel" id="manual-hawb-input" placeholder="송장번호를 입력하세요" class="mt-1 w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700">
                </div>
                <div>
                    <label for="manual-address-input" class="text-sm font-medium text-gray-700 dark:text-gray-300">주소 (필수)</label>
                    <textarea id="manual-address-input" placeholder="기본 주소, 상세 주소 순으로 입력하세요 (쉼표로 구분)" rows="2" class="mt-1 w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700"></textarea>
                </div>
                <div>
                    <label for="manual-name-input" class="text-sm font-medium text-gray-700 dark:text-gray-300">받는 분</label>
                    <input type="text" id="manual-name-input" placeholder="받는 분 성함을 입력하세요" class="mt-1 w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700">
                </div>
                <div>
                    <label for="manual-company-input" class="text-sm font-medium text-gray-700 dark:text-gray-300">회사명</label>
                    <input type="text" id="manual-company-input" placeholder="회사명을 입력하세요" class="mt-1 w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700">
                </div>
                <div>
                    <label for="manual-phone-input" class="text-sm font-medium text-gray-700 dark:text-gray-300">전화번호</label>
                    <input type="tel" id="manual-phone-input" placeholder="전화번호를 입력하세요" class="mt-1 w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700">
                </div>
            </div>
            <div class="flex justify-between space-x-2 mt-6">
                <button id="manual-add-cancel-btn" class="w-1/2 px-4 py-2 rounded-md bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-sm font-medium hover:bg-gray-400 dark:hover:bg-gray-500">취소</button>
                <button id="manual-add-create-btn" class="w-1/2 px-4 py-2 rounded-md bg-green-600 text-white text-sm font-medium hover:bg-green-700">생성</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ [추가 끝] ▲▲▲ -->

    <script type="text/javascript">
        // ▼▼▼▼▼ [수정] 새로운 UI에 맞춘 다크모드 테마 제어 로직 ▼▼▼▼▼
const themeColorMeta = document.getElementById('theme-color-meta');

const applyTheme = (themePreference) => {
    const systemThemeToggle = document.getElementById('system-theme-toggle');
    const themeSwitchContainer = document.getElementById('theme-switch-container');
    const themeGlider = document.getElementById('theme-glider');
    const lightBtn = document.getElementById('light-theme-btn');
    const darkBtn = document.getElementById('dark-theme-btn');

    let effectiveTheme = themePreference;
    const isSystemMode = themePreference === 'system';

    if (isSystemMode) {
        effectiveTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    // 1. HTML 클래스 및 메타 태그 업데이트
    if (effectiveTheme === 'dark') {
        document.documentElement.classList.add('dark');
        if (themeColorMeta) themeColorMeta.setAttribute('content', '#121212'); // 페이지 배경과 동일한 어두운 색으로 변경
    } else {
        document.documentElement.classList.remove('dark');
        if (themeColorMeta) themeColorMeta.setAttribute('content', '#ffffff'); // white
    }
    
    // 2. UI 업데이트
    if (systemThemeToggle && themeSwitchContainer && themeGlider && lightBtn && darkBtn) {
        // 시스템 토글 상태 업데이트
        systemThemeToggle.checked = isSystemMode;
        
        // 라이트/다크 스위치 비활성화/활성화
        themeSwitchContainer.classList.toggle('disabled', isSystemMode);

        // 글라이더 위치 이동
        const targetButton = effectiveTheme === 'dark' ? darkBtn : lightBtn;
        themeGlider.style.transform = `translateX(${targetButton.offsetLeft - lightBtn.offsetLeft}px)`;
        
        // 아이콘 색상 활성화
        lightBtn.classList.toggle('text-yellow-500', effectiveTheme === 'light');
        lightBtn.classList.toggle('text-gray-600', effectiveTheme !== 'light');
        darkBtn.classList.toggle('text-blue-400', effectiveTheme === 'dark');
        darkBtn.classList.toggle('text-gray-600', effectiveTheme !== 'dark');
    }

    // 3. 선택 사항 저장
    localStorage.setItem('theme', themePreference);
};

const initializeTheme = () => {
    const savedTheme = localStorage.getItem('theme') || 'system';
    applyTheme(savedTheme);
};

// 시스템 테마 변경 감지
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
    // 시스템 모드가 활성화 되어 있을 때만 테마를 자동으로 변경
    if (localStorage.getItem('theme') === 'system') {
        applyTheme('system');
    }
});
// ▲▲▲▲▲ [수정 끝] ▲▲▲▲▲


const GEMINI_PROMPT = `Analyze the provided image containing one or more delivery invoices. Your task is to identify each distinct invoice block and extract its key information into a valid JSON array. Your primary goals are 1) Flawless OCR of ALL text including tracking numbers, and 2) Assembling addresses based on proven Korean address rules.

**CRITICAL DATA INTEGRITY RULES:**
- **PRESERVE ALL TEXT EXACTLY:** Never modify, deduplicate, or alter any characters in phone numbers or addresses
- **HAWB NUMBER PROCESSING:** 
  * Extract ALL digits and letters from tracking numbers exactly as recognized
  * **REMOVE ALL SPACES from hawNo field** (e.g., "SF329664287 8806" → "SF3296642878806")
  * Never add or insert spaces in tracking numbers
- **NO SPACE INSERTION IN OTHER FIELDS:** Preserve original spacing in all other fields (addresses, names, etc.)

**FUNDAMENTAL RULES:**

1.  **IDENTIFY EACH INVOICE:** Treat each logical invoice area as a separate item. An "no" is essential for each item.

2.  **EXTRACT CORE FIELDS:** For each invoice, extract: "no", "hawbNo", "receiverAddress", "rawOcrAddress", "receiverPhone", "receiverCompanyName", "receiverName".

3.  **SEPARATE COMPANY AND PERSONAL NAME:**
    *   Intelligently separate company/organization names and personal names. If separation is impossible, place the entire text in both fields.

4.  **TRANSLATE AND SEPARATE ADDRESS:**
    *   Translate names to Korean if in English/Romanized Korean.
    
    *   **STEP 1 (DATA INTEGRITY): Extract Raw OCR Address.** 
        - "rawOcrAddress": COMPLETE, UNALTERED text from receiver address block
        - Preserve ALL characters, spacing exactly as they appear

    *   **STEP 2 (LITERAL TRANSLATION):** Perform STRICT, LITERAL TRANSLATION of "rawOcrAddress"
        - Translate English words to Korean equivalents
        - Preserve ALL numbers and symbols exactly

    *   **STEP 3 (PROVEN ADDRESS ASSEMBLY):** From translated address, assemble "baseAddressKorean" and "detailAddressKorean"

        **BUILDING NUMBER DETECTION (PROVEN RULES):**
        - **PRIMARY:** Number immediately PRECEDING road name ("12-8, Saemal-ro 17-gil" → "새말로17길 12-8")
        - **SECONDARY:** Number immediately FOLLOWING road name (if no primary found)
        - **CLOSEST TO ANCHOR:** If multiple numbers before anchor, use closest one

        **ADDRESS ASSEMBLY:**
        - Base Address = [Administrative District] + [Road Name] + [Building Number]
        - Detail Address = Everything else (unit numbers, building names, etc.)
        - **CRITICAL:** Never include building number from base address in detail address

        **UNIT PROCESSING:**
        - Preserve complete unit numbers: "501호", "103-401", "211동1604호"
        - For office ranges "C-819-822", use first unit "C-819"
        - For apartment ranges "101-105", preserve completely

5.  **HAWB NO SPECIFIC PROCESSING:**
    *   After OCR recognition, remove ANY spaces within the tracking number
    *   Ensure hawNo contains only alphanumeric characters without spaces
    *   Example: "SF 329664287 8806" → "SF3296642878806"
    *   Example: "123 456 789" → "123456789"

6.  **OUTPUT A JSON ARRAY:** Your entire output MUST be a single, valid JSON array of objects.

**Example Output:**
[
  {
    "no": "1",
    "hawbNo": "SF3296642878806",
    "receiverName": "Support Ryu",
    "receiverNameKorean": "류 서포트",
    "receiverPhone": "01098924075",
    "receiverCompanyName": "",
    "receiverCompanyNameKorean": "",
    "receiverAddress": "seoul Songpa-gu 124 Wiryesongpa -ro, Songpa-gu, SeoulRoom 401, Building 103",
    "rawOcrAddress": "seoul Songpa-gu 124 Wiryesongpa -ro, Songpa-gu, SeoulRoom 401, Building 103",
    "baseAddressKorean": "서울 송파구 위례송파로 124",
    "detailAddressKorean": "103-401"
  }
]
`;
        const KAKAO_API_KEY = '2342aad8b15d534cb60fb824f71a97f1';

        const dateTimeFormatOptions = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };

        // --- Helper functions ---

        // ▼▼▼ [추가 시작] 터치 피드백(진동)을 위한 헬퍼 함수 ▼▼▼
        const triggerVibration = (duration = 15) => {
            // navigator.vibrate가 지원되는 환경인지 먼저 확인합니다.
            if ('vibrate' in navigator) {
                try {
                    navigator.vibrate(duration);
                } catch (e) {
                    console.warn("Vibration failed.", e);
                }
            }
        };
        // ▲▲▲ [추가 끝] ▲▲▲

            const showLoadingMessage = (message) => {
    confirmationModalTitle.textContent = '처리 중...';
    confirmationModalBody.innerHTML = `
        <div class="flex flex-col items-center justify-center p-4">
            <div class="spinner mb-4"></div>
            <p class="text-base text-gray-700 dark:text-gray-300">${message}</p>
        </div>
    `;
    // 확인/취소 버튼 숨기기
    confirmationModalButtons.style.display = 'none';
    document.body.classList.add('modal-open');
    confirmationModal.style.display = 'flex';
};

const showToastMessage = (message, duration = 2000) => {
    const toast = document.createElement('div');
    toast.className = 'toast-message';
    toast.textContent = message;
    toastContainer.appendChild(toast);

    // Animate in
    setTimeout(() => {
        toast.classList.add('show');
    }, 10);

    // Animate out and remove
    setTimeout(() => {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, { once: true });
    }, duration);
};

const showMessage = (message, title = '알림') => {
            // 1. 중앙 관리 함수인 openConfirmationModal을 호출하여 모달을 띄웁니다.
            //    - onOk 콜백은 null로 전달하여 '확인' 버튼이 특별한 동작 없이 모달만 닫도록 합니다.
            openConfirmationModal(message, null, '확인', '취소');

            // 2. openConfirmationModal이 생성한 모달의 내용을 '알림' 스타일에 맞게 조정합니다.
            confirmationModalTitle.textContent = title; // 제목 변경
            
            const cancelButton = document.getElementById('confirmCancelButton');
            if (cancelButton) {
                cancelButton.style.display = 'none'; // 취소 버튼 숨기기
            }
            
            const okButton = document.getElementById('confirmOkButton');
            if (okButton) {
                okButton.classList.remove('w-1/2'); // 너비 클래스 제거
                okButton.classList.add('w-full');   // 전체 너비로 설정
            }
        };

const sendCompletionNotification = (item) => {
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const fullAddress = item.baseAddress + (item.detailAddress ? `, ${item.detailAddress}` : '');
        const time = formatCompletionTime(item.deliveryCompletionTime);

        navigator.serviceWorker.controller.postMessage({
            type: 'SHOW_NOTIFICATION',
            payload: {
                no: item.no,
                location: item.completionDetail || item.completionType,
                receiverName: item.receiverNameKorean,
                companyName: item.companyNameKorean,
                address: fullAddress,
                time: time
            }
        });
    }
};

        const resizeAppContainer = () => {
            const appContainer = document.getElementById('app-container');
            if (appContainer) {
                appContainer.style.height = `${window.innerHeight}px`;
            }
        };
        const isValidPhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) {
                return true; // 번호가 없으면 유효한 것으로 간주 (수정 대상이 아님)
            }
            
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('82')) {
                cleaned = '0' + cleaned.substring(2);
            }

            if (cleaned.startsWith('010')) {
                return cleaned.length === 11;
            }
            
            if (cleaned.startsWith('02')) {
                return cleaned.length === 9 || cleaned.length === 10;
            }

            if (cleaned.startsWith('070')) {
                return cleaned.length === 11;
            }

            if (cleaned.startsWith('0')) {
                return cleaned.length === 10 || cleaned.length === 11;
            }

            return false;
        };

        const setVersionInfo = () => {
            const version = "v1.9.0";
            const changelog = "버그수정";
            if (versionText) versionText.textContent = version;
            if (versionChangelog) versionChangelog.textContent = changelog;
        };

                const setupDelegatedEventListeners = () => {
            let touchTarget = null;

            // 지도 아이콘 터치 관련 변수
            let mapIconTapCount = 0;
            let mapIconTapTimer = null;
            // ▼▼▼ [수정] 지도 길게 터치 타이머 변수 제거 ▼▼▼
            // let mapIconLongPressTimer = null; 

            deliveryCardsContainer.addEventListener('touchstart', (event) => {
                const frontDoorButton = event.target.closest('button[data-action="front-door-delivery"]');
                if (frontDoorButton) {
                    isLongPress = false;
                    touchTarget = frontDoorButton;
                    longPressTimer = setTimeout(() => {
                        isLongPress = true;
                        const itemNo = parseInt(frontDoorButton.dataset.no, 10);
                        openCompletionOptionsModal(itemNo);
                    }, 300);
                }

                // ▼▼▼ [수정] 지도 아이콘 길게 터치 로직 전체 삭제 ▼▼▼
                /*
                const mapButton = event.target.closest('button[data-action="open-map"]');
                if (mapButton) { ... }
                */
            }, { passive: true });

            deliveryCardsContainer.addEventListener('touchmove', (event) => {
                // 스크롤 시 모든 타이머 취소
                clearTimeout(longPressTimer);
                touchTarget = null;
                // ▼▼▼ [수정] 지도 길게 터치 타이머 취소 로직 제거 ▼▼▼
                // clearTimeout(mapIconLongPressTimer);
                // mapIconLongPressTimer = null;
            }, { passive: true });

            deliveryCardsContainer.addEventListener('touchend', (event) => {
                if (touchTarget) {
                    clearTimeout(longPressTimer);
                    if (isLongPress) {
                        event.preventDefault();
                        isLongPress = false;
                    }
                    touchTarget = null;
                }

                const mapButton = event.target.closest('button[data-action="open-map"]');
                if (mapButton) {
                    // ▼▼▼ [수정] 길게 터치 관련 로직 제거 ▼▼▼
                    // clearTimeout(mapIconLongPressTimer);
                    // if (!mapIconLongPressTimer) { return; }
                    
                    mapIconTapCount++; // 탭 횟수 증가

                    if (mapIconTapCount === 1) { // 첫 번째 탭
                        mapIconTapTimer = setTimeout(() => {
                            const itemNo = parseInt(mapButton.dataset.no, 10);
                            const item = deliveryItems.find(i => i.no === itemNo);
                            if (item) {
                                openMap(item); // 일반 복사 및 지도 열기
                            }
                            mapIconTapCount = 0;
                        }, 300);
                    } else if (mapIconTapCount === 2) { // 두 번째 탭 (더블 탭)
                        clearTimeout(mapIconTapTimer);
                        mapIconTapTimer = setTimeout(() => {
                            const itemNo = parseInt(mapButton.dataset.no, 10);
                            const item = deliveryItems.find(i => i.no === itemNo);
                            if (item) {
                                const textToCopy = `*${item.no}. ${extractClipboardAddressPart(item)}`;
                                navigator.clipboard.writeText(textToCopy);
                                openMap(item, true);
                            }
                            mapIconTapCount = 0;
                        }, 300);
                    } else if (mapIconTapCount === 3) { // 세 번째 탭 (트리플 탭)
                        clearTimeout(mapIconTapTimer);
                        const itemNo = parseInt(mapButton.dataset.no, 10);
                        const item = deliveryItems.find(i => i.no === itemNo);
                        if (item) {
                            // ▼▼▼ [수정] 별표 2개로 변경 (기존 길게 터치 기능) ▼▼▼
                            const textToCopy = `**${item.no}. ${extractClipboardAddressPart(item)}`;
                            navigator.clipboard.writeText(textToCopy);
                            openMap(item, true);
                        }
                        mapIconTapCount = 0;
                    }
                }
            });

            deliveryCardsContainer.addEventListener('click', (event) => {
                if (isLongPress) {
                    isLongPress = false;
                    return;
                }
                
                const target = event.target.closest('button, input[type="checkbox"], p[data-action="open-smart-edit"], span[data-action="edit-phone"], span[data-action="copy-completion"], span[data-action="edit-completion-detail"], span[data-action="copy-hawb"], button[data-action="swap-name"], span[data-action="edit-completion-time"]');
                if (!target) return;

                const action = target.dataset.action;
                if (action === 'open-map') {
                    event.preventDefault(); // touchend에서 처리하므로 기본 click 이벤트 방지
                    return;
                }
                const itemNo = parseInt(target.dataset.no, 10);

                switch (action) {
                    case 'copy-completion':
                        {
                            triggerVibration(); // <-- [추가]
                            const item = deliveryItems.find(i => i.no === itemNo);
                            if (item) {
                                const completionText = item.completionType === '본인전달'
                                    ? (item.receiverNameKorean || '')
                                    : (item.completionDetail || item.completionType || '');
                                const timeText = formatCompletionTime(item.deliveryCompletionTime);
                                const textToCopy = `${item.no} - ${completionText} [${timeText}]`;
                                
                                navigator.clipboard.writeText(textToCopy).then(() => {
                                    showToastMessage(`'${textToCopy}' 복사 완료`);
                                }).catch(err => {
                                    console.error('클립보드 복사 실패:', err);
                                    showMessage('클립보드 복사에 실패했습니다.');
                                });
                            }
                        }
                        break;
                    case 'edit-completion-detail':
                        {
                            triggerVibration(); // <-- [추가]
                            const item = deliveryItems.find(i => i.no === itemNo);
                            if (item) {
                                const isEditableText = ['본인전달', '직접입력'].includes(item.completionType);
                                if (isEditableText) {
                                    openSignatureModal(item.no); 
                                } else {
                                    openDeliveryLocationModal(item.no);
                                }
                            }
                        }
                        break;

                    case 'toggle-hawb-confirm':
                        handleCheckboxToggleAndResetSearch(itemNo, target.checked);
                        break;
                    case 'swap-name':
                        {
                            triggerVibration(); // <-- [추가]
                            const itemIndex = deliveryItems.findIndex(i => i.no === itemNo);
                            if (itemIndex > -1) {
                                const item = deliveryItems[itemIndex];
                                if (typeof item.receiverNameKoreanOriginal === 'undefined') {
                                    item.receiverNameKoreanOriginal = item.receiverNameKorean;
                                }
                                const currentName = item.receiverNameKorean;
                                const originalName = item.receiverNameKoreanOriginal;
                                if (currentName !== originalName) {
                                    deliveryItems[itemIndex].receiverNameKorean = originalName;
                                } else {
                                    const nameToSwap = currentName.trim().replace(/\s/g, '');
                                    if (nameToSwap.length > 1) {
                                        const lastChar = nameToSwap.slice(-1);
                                        const restOfString = nameToSwap.slice(0, -1);
                                        const newName = `${lastChar}${restOfString}`;
                                        deliveryItems[itemIndex].receiverNameKorean = newName;
                                    }
                                }
                                saveDeliveryItemsToLocalStorage();
                                renderDeliveryCards(activeFilter);
                            }
                        }
                        break;
                    case 'copy-hawb':
                        {
                            const hawbToCopy = target.dataset.hawbNo;
                            if (hawbToCopy) {
                                navigator.clipboard.writeText(hawbToCopy).catch(err => {
                                    console.error('송장번호 복사 실패:', err);
                                    showMessage('송장번호 복사에 실패했습니다.');
                                });
                            }
                        }
                        break;
                    case 'revert-delivery':
                        triggerVibration(); // <-- [추가]
                        openConfirmationModal(`${itemNo}번 항목을 '배송중' 상태로 되돌리시겠습니까?`, () => {
                            handleStatusChange(itemNo, '배송중');
                            showToastMessage(`${itemNo}번 항목이 되돌려졌습니다.`);
                        });
                        break;
                    case 'identity-verification':
                        openConfirmationModal(`${itemNo}번 항목을 '본인전달'로 완료 처리하시겠습니까?`, () => {
                            copyHawbOnComplete(itemNo);
                            const currentTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
                            handleStatusChange(itemNo, '완료', currentTime, '본인전달', '신분증');
                            sortItemsByDistanceSilent();
                            
                            // ▼▼▼ [추가] 웹훅 전송 ▼▼▼
                            const updatedItem = deliveryItems.find(i => i.no === itemNo);
                            if (updatedItem) sendWebhook(updatedItem);
                        });
                        break;
                    case 'open-location-modal':
                        openDeliveryLocationModal(itemNo);
                        break;
                    case 'sign-delivery':
                        openSignatureModal(itemNo);
                        break;
                    case 'toggle-details':
                        {
                            const detailsContainer = document.querySelector(`div[data-details-container="${itemNo}"]`);
                            const iconButton = target.closest('button');
                            const iconSvg = iconButton.querySelector('svg');
                            if (detailsContainer && iconSvg) {
                                const isHidden = detailsContainer.style.display === 'none';
                                detailsContainer.style.display = isHidden ? 'block' : 'none';
                                if (isHidden) {
                                    iconSvg.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />`;
                                } else {
                                    iconSvg.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />`;
                                }
                            }
                        }
                        break;
                    case 'edit-phone':
                        openPhoneEditModal(itemNo);
                        break;
                    case 'open-smart-edit':
                        openSmartEditModal(itemNo);
                        break;
                    case 'edit-completion-time':
                        openTimeEditModal(itemNo);
                        break;
                }
            });

            completionOptionsCancelBtn.addEventListener('click', () => {
                completionOptionsModal.style.display = 'none';
            });
        };

        const resizeImage = (file) => {
            return new Promise((resolve, reject) => {
                const MAX_WIDTH = 1920;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;
                        if (width > MAX_WIDTH) {
                            height = (MAX_WIDTH / width) * height;
                            width = MAX_WIDTH;
                        }
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                        resolve({ file, data: dataUrl.split(',')[1] });
                    };
                    img.onerror = (error) => reject(error);
                };
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        };

        const getCurrentLocation = (timeout = 10000) => {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    return reject(new Error('Geolocation is not supported by this browser.'));
                }
                navigator.geolocation.getCurrentPosition(
                    (position) => resolve({ lat: position.coords.latitude, lng: position.coords.longitude }),
                    (error) => reject(error),
                    { enableHighAccuracy: true, timeout, maximumAge: 0 }
                );
            });
        };

        const getCoordsFromAddress = async (address) => {
            if (!address) throw new Error("Address is empty.");
            const response = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(address)}`, {
                headers: { 'Authorization': `KakaoAK ${KAKAO_API_KEY}` }
            });
            if (!response.ok) throw new Error('Kakao Geocoding API call failed');
            const data = await response.json();
            if (data.documents && data.documents.length > 0) {
                const location = data.documents[0];
                return { lat: parseFloat(location.y), lng: parseFloat(location.x) };
            }
            throw new Error("Could not find coordinates for the address.");
        };

        const calculateDistance = (pos1, pos2) => {
            if (!pos1 || !pos2) return Infinity;
            const R = 6371; // Radius of the Earth in km
            const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
            const dLon = (pos2.lng - pos1.lng) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance in km
        };

        const formatSinglePhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('+82010')) { cleaned = '010' + cleaned.substring(6); }
            else if (cleaned.startsWith('82010')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('+8210')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('8210')) { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('8201') && cleaned.length > 4 && cleaned[4] !== '0') { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('82') && cleaned.length > 2) { cleaned = '0' + cleaned.substring(2); }
            else if (cleaned.length >= 7 && cleaned.length <= 11 && !cleaned.startsWith('0')) { cleaned = '0' + cleaned; }
            
            if (cleaned.startsWith('010') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.startsWith('02')) {
                if (cleaned.length === 9) return cleaned.replace(/(\d{2})(\d{3})(\d{4})/, '$1-$2-$3');
                if (cleaned.length === 10) return cleaned.replace(/(\d{2})(\d{4})(\d{4})/, '$1-$2-$3');
            }
            if (cleaned.startsWith('031') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.startsWith('070') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 10) return cleaned.replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 9) return cleaned.replace(/(\d{2})(\d{3})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 8) return cleaned.replace(/(\d{4})(\d{4})/, '$1-$2');
            if (cleaned.length === 7) return cleaned.replace(/(\d{3})(\d{4})/, '$1-$2');

            return cleaned;
        };

        const formatPhoneNumberForDisplay = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            const rangeMatch = phoneNumber.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) {
                const baseNumber = rangeMatch[1];
                const suffix = rangeMatch[2];
                if (baseNumber.length >= suffix.length) {
                    const num1 = formatSinglePhoneNumber(baseNumber);
                    const num2Raw = baseNumber.substring(0, baseNumber.length - suffix.length) + suffix;
                    const num2 = formatSinglePhoneNumber(num2Raw);
                    return `${num1} / ${num2}`;
                }
            }
            return formatSinglePhoneNumber(phoneNumber.replace(/\D/g, ''));
        };

        const getCleanPhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            const rangeMatch = phoneNumber.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) phoneNumber = rangeMatch[1];
            
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('+82010')) { cleaned = '010' + cleaned.substring(6); }
            else if (cleaned.startsWith('82010')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('+8210')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('8210')) { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('8201') && cleaned.length > 4 && cleaned[4] !== '0') { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('82') && cleaned.length > 2) { cleaned = '0' + cleaned.substring(2); }
            else if (cleaned.length >= 7 && cleaned.length <= 11 && !cleaned.startsWith('0')) { cleaned = '0' + cleaned; }

            return cleaned;
        };

        const formatHawbNoForDisplay = (hawbNo) => {
            if (!hawbNo || hawbNo.length < 4) return hawbNo;
            const prefix = hawbNo.substring(0, hawbNo.length - 4);
            const suffix = hawbNo.substring(hawbNo.length - 4);
            return `${prefix} ${suffix}`;
        };

        const formatCompletionTime = (dateTimeString) => {
            if (!dateTimeString) return '';
            const parts = dateTimeString.split(' ');
            if (parts.length >= 4) {
                const [hour, minute] = parts[3].split(':');
                return `${hour}:${minute}`;
            }
            return '';
        };
        
        const extractClipboardAddressPart = (item) => {
            if (!item) return '';
            const { baseAddress, detailAddress } = item;

            if (detailAddress) {
                const hyphenMatch = detailAddress.match(/\b(\d{2,4}-\d{2,4})\b/);
                if (hyphenMatch) return hyphenMatch[1];
                const dongHoMatch = detailAddress.match(/(\d+)\s*동\s*(\d+)\s*호/);
                if (dongHoMatch) return `${dongHoMatch[1]}-${dongHoMatch[2]}`;
            }

            if (baseAddress) {
                const addressParts = baseAddress.split(' ');
                const adminNames = ['서울', '부산', '대구', '인천', '광주', '대전', '울산', '세종', '경기', '강원', '충북', '충남', '전북', '전남', '경북', '경남', '제주'];
                const adminSuffixes = ['도', '시', '구', '군', '읍', '면'];
                
                while (addressParts.length > 0) {
                    const firstPart = addressParts[0];
                    if (adminNames.includes(firstPart) || adminSuffixes.some(suffix => firstPart.endsWith(suffix))) {
                        addressParts.shift();
                    } else {
                        break;
                    }
                }
                
                const resultAddress = addressParts.join(' ');
                return resultAddress.length > 0 ? resultAddress : baseAddress;
            }

            return baseAddress || '';
        };

        const isValidAddressForMap = (address) => {
            return !!(address && address.trim().length > 0);
        };
        
        const validateAddressWithKakao = async (baseAddress, detailAddress) => {
            if (!baseAddress) {
                return { baseAddress: '', detailAddress: detailAddress || '', validated: false };
            }
            try {
                const response = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(baseAddress)}`, {
                    headers: { 'Authorization': `KakaoAK ${KAKAO_API_KEY}` }
                });
                if (!response.ok) throw new Error('Kakao API call failed');
                const data = await response.json();
                if (data.documents && data.documents.length > 0) {
                    const doc = data.documents[0];
                    const kakaoBaseAddress = doc.road_address ? doc.road_address.address_name : doc.address.address_name;
                    return { baseAddress: kakaoBaseAddress, detailAddress: detailAddress || '', validated: true };
                }
                return { baseAddress, detailAddress: detailAddress || '', validated: false };
            } catch (error) {
                console.error('Error validating address with Kakao API:', error);
                return { baseAddress, detailAddress: detailAddress || '', validated: false };
            }
        };

        // --- Global state and DOM elements ---
        let deliveryItems = [];
        let searchTerm = '';
        let activeFilter = '전체';
        const filterCategories = ['배송준비', '전체', '배송전', '배송중', '완료'];
        let filterScrollPositions = {};
        let currentFileToScan = null;
        let failedFileObjects = []; 
        let currentSignatureItemNo = null;
        let onConfirmCallback = null;
        let currentEditItemNo = null; 
        let currentSortOrder = 'no';
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let backButtonPressedOnce = false;
        let justReturnedFromExternalApp = false;
        let deliveryInProgressSortOrder = 'no';
        let completedSortOrder = 'no';
        let longPressTimer = null;
        let isLongPress = false;
        let isRefreshing = false;
        let pullStartY = 0;
        let refreshIndicator;
        let currentLocationEditItemNo = null;
        let isScanCancelled = false;
        
        const searchBarContainer = document.getElementById('search-bar-container');
        const invoiceNumberInput = document.getElementById('invoiceNumber');
        const resetButton = document.getElementById('resetButton');
        const filterButtonsContainer = document.getElementById('filter-buttons-container');
        const deliveryCardsContainer = document.getElementById('delivery-cards-container');
        const deliverySheetImageInput = document.getElementById('deliverySheetImage');
        const scanAndGenerateButton = document.getElementById('scanAndGenerateButton');
        const scanSectionContainer = document.getElementById('scan-section-container');
        const clearAllCardsButton = document.getElementById('clearAllCardsButton');
        const dataManagementContainer = document.getElementById('data-management-container');
        const exportDataButton = document.getElementById('exportDataButton');
        const importDataInput = document.getElementById('importDataInput');
        const selectedFilesDisplay = document.getElementById('selected-files-display');
        const scanProgressModal = document.getElementById('scan-progress-modal');
        const scanProgressModalText = document.getElementById('scan-progress-modal-text');
        const scanProgressCancelBtn = document.getElementById('scan-progress-cancel-btn');
        const signatureModal = document.getElementById('signature-modal');
        const signatureTextInput = document.getElementById('signature-text-input');
        const clearSignatureBtn = document.getElementById('clearSignature');
        const cancelSignatureBtn = document.getElementById('cancelSignature');
        const saveSignatureBtn = document.getElementById('saveSignature');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationModalTitle = document.getElementById('confirmation-modal-title');
        const confirmationModalMessage = document.getElementById('confirmation-modal-message');
        const confirmationModalBody = document.getElementById('confirmation-modal-body');
        const confirmationModalButtons = document.getElementById('confirmation-modal-buttons');
        const confirmOkButton = document.getElementById('confirmOkButton');
        const confirmCancelButton = document.getElementById('confirmCancelButton');
        const versionInfoContainer = document.getElementById('version-info-container');
        const versionText = document.getElementById('version-text');
        const versionChangelog = document.getElementById('version-changelog');
        const smartEditModal = document.getElementById('smart-edit-modal');
        const originalAddressDisplay = document.getElementById('original-address-display');
        const editableAddressInput = document.getElementById('editable-address-input');
        const applyAddressBtn = document.getElementById('apply-address-btn');
        const resetAddressBtn = document.getElementById('reset-address-btn');
        const revertAddressBtn = document.getElementById('revert-address-btn');
        const smartEditExitBtn = document.getElementById('smart-edit-exit');
        const toastContainer = document.getElementById('toast-container');
        const numberJumpModal = document.getElementById('number-jump-modal');
        const numberJumpList = document.getElementById('number-jump-list');
        const numberJumpClose = document.getElementById('number-jump-close');
        const actionBarContainer = document.getElementById('action-bar-container');
        const completionOptionsModal = document.getElementById('completion-options-modal');
        const completionOptionsTitle = document.getElementById('completion-options-title');
        const completionOptionsList = document.getElementById('completion-options-list');
        const completionOptionsCancelBtn = document.getElementById('completion-options-cancel');
        const deliveryLocationModal = document.getElementById('delivery-location-modal');
        const deliveryLocationTitle = document.getElementById('delivery-location-title');
        const deliveryLocationOptions = document.getElementById('delivery-location-options');
        const locationModalConfirm = document.getElementById('location-modal-confirm');
        const locationModalCancel = document.getElementById('location-modal-cancel');

        // ▼▼▼ [추가 시작] 수동 카드 추가 관련 DOM 요소 ▼▼▼
        const manualAddCardButton = document.getElementById('manual-add-card-button');
        const manualAddCardModal = document.getElementById('manual-add-card-modal');
        const manualNoInput = document.getElementById('manual-no-input');
        const manualHawbInput = document.getElementById('manual-hawb-input');
        const manualAddressInput = document.getElementById('manual-address-input');
        const manualNameInput = document.getElementById('manual-name-input');
        const manualCompanyInput = document.getElementById('manual-company-input');
        const manualPhoneInput = document.getElementById('manual-phone-input');
        const manualAddCancelBtn = document.getElementById('manual-add-cancel-btn');
        const manualAddCreateBtn = document.getElementById('manual-add-create-btn');
        // ▲▲▲ [추가 끝] ▲▲▲

        // --- Modal & Core Logic Functions ---

        // ▼▼▼ [추가 시작] 수동 카드 추가 관련 함수들 ▼▼▼
        const openManualAddModal = () => {
            // 1. 다음 순번을 자동으로 계산하여 입력 필드에 설정
            const nextNo = Math.max(0, ...deliveryItems.map(item => item.no)) + 1;
            manualNoInput.value = nextNo;

            // 2. 기존 입력 내용 초기화
            manualHawbInput.value = '';
            manualAddressInput.value = '';
            manualNameInput.value = '';
            manualCompanyInput.value = '';
            manualPhoneInput.value = '';

            // 3. 모달 표시
            document.body.classList.add('modal-open');
            manualAddCardModal.style.display = 'flex';
        };

        const closeManualAddModal = () => {
            document.body.classList.remove('modal-open');
            manualAddCardModal.style.display = 'none';
        };

        const handleCreateManualCard = async () => { // <-- [수정] async 키워드 추가
            // 1. 입력 필드에서 값 가져오기
            const no = parseInt(manualNoInput.value, 10);
            const hawbNo = manualHawbInput.value.trim();
            const fullAddress = manualAddressInput.value.trim();
            const receiverName = manualNameInput.value.trim();
            const companyName = manualCompanyInput.value.trim();
            const phone = manualPhoneInput.value.trim();

            // 2. 필수 값(순번, 주소) 유효성 검사
            if (isNaN(no) || !fullAddress) {
                showMessage('순번과 주소는 필수 입력 항목입니다.');
                return;
            }
            if (deliveryItems.some(item => item.no === no)) {
                showMessage(`순번 ${no}번은 이미 존재합니다. 다른 번호를 사용해주세요.`);
                return;
            }

            // 3. 주소를 기본 주소와 상세 주소로 분리 (쉼표 기준)
            const addressParts = fullAddress.split(',');
            const tempBaseAddress = addressParts[0] ? addressParts[0].trim() : '';
            const tempDetailAddress = addressParts[1] ? addressParts[1].trim() : '';

            // ▼▼▼ [추가 시작] 주소 검증 로직 ▼▼▼
            showLoadingMessage('주소 검증 중...'); // 로딩 메시지 표시
            const validationResult = await validateAddressWithKakao(tempBaseAddress, tempDetailAddress);
            closeConfirmationModal(); // 로딩 메시지 닫기
            // ▲▲▲ [추가 끝] ▲▲▲

            // 4. 최종 카드 생성 및 저장을 위한 함수 정의
            const createAndSaveCard = (base, detail, isValidated) => {
                const newCard = {
                    no: no,
                    hawbNo: hawbNo,
                    baseAddress: base,
                    detailAddress: detail,
                    feedback_status: 'USER_CORRECTED',
                    original_ocr_address: '수동 입력',
                    ai_base_address: base,
                    ai_detail_address: detail,
                    companyNameOriginal: companyName,
                    receiverNameOriginal: receiverName,
                    companyNameKorean: companyName,
                    receiverNameKorean: receiverName,
                    receiverNameKoreanOriginal: receiverName,
                    receiverTelephoneNo: getCleanPhoneNumber(phone),
                    status: '배송전',
                    isHawbConfirmed: false,
                    deliveryCompletionTime: null,
                    completionType: null,
                    completionDetail: null,
                    addressLocation: null,
                    isStruckThrough: false,
                    isAddressValidated: isValidated // 검증 결과 반영
                };

                deliveryItems.push(newCard);
                deliveryItems.sort((a, b) => a.no - b.no);
                saveDeliveryItemsToLocalStorage();

                updateFilterCounts();
                renderDeliveryCards(activeFilter);
                closeManualAddModal();
                showToastMessage(`${no}번 카드가 성공적으로 생성되었습니다.`);
            };

            // 5. 검증 결과에 따라 카드 생성 처리
            if (validationResult.validated) {
                // 검증 성공 시, API가 반환한 표준 주소로 카드 생성
                createAndSaveCard(validationResult.baseAddress, validationResult.detailAddress, true);
            } else {
                // 검증 실패 시, 사용자에게 재확인
                const message = `카카오맵에서 주소를 찾을 수 없습니다. 입력하신 '${fullAddress}' 주소 그대로 저장하시겠습니까?`;
                openConfirmationModal(message, () => {
                    // 사용자가 '확인'을 누르면 입력한 그대로 카드 생성
                    createAndSaveCard(tempBaseAddress, tempDetailAddress, false);
                });
            }
        };
        // ▲▲▲ [추가 끝] ▲▲▲

        function autoResizeTextarea(event) {
            const textarea = event.target;
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
        }

        const openDeliveryLocationModal = (itemNo) => {
            currentLocationEditItemNo = itemNo;
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item) return;

            deliveryLocationTitle.textContent = `${item.no}번 배송 위치 선택`;

            const deliveryLocationCardInfo = document.getElementById('delivery-location-card-info');
            deliveryLocationCardInfo.innerHTML = `
                <div class="p-2.5 bg-gray-100 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-md space-y-1">
                    <p class="text-xs text-gray-600 dark:text-gray-300 truncate"><span class="font-semibold w-11 inline-block flex-shrink-0">주소:</span> ${item.baseAddress}${item.detailAddress ? ', ' + item.detailAddress : ''}</p>
                    <p class="text-xs text-gray-600 dark:text-gray-300 truncate"><span class="font-semibold w-11 inline-block flex-shrink-0">받는분:</span> ${item.receiverNameKorean || item.receiverNameOriginal}</p>
                </div>
            `;

            const locations = ['문앞', '택배보관소', '택배함', '문서수발실', '경비실', '안내데스크'];
            let radioOptionsHtml = locations.map((location, index) => `
                <label for="loc-${index}" class="flex items-center p-2.5 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer">
                    <input type="radio" id="loc-${index}" name="delivery-location" value="${location}" class="h-5 w-5 text-blue-600 border-gray-300 focus:ring-blue-500" ${index === 0 ? 'checked' : ''}>
                    <span class="ml-3 text-sm font-medium text-gray-800 dark:text-gray-200">${location}</span>
                </label>
            `).join('');

            radioOptionsHtml += `
                <div class="flex items-center p-2.5 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600">
                    <input type="radio" id="loc-other" name="delivery-location" value="기타" class="h-5 w-5 text-blue-600 border-gray-300 focus:ring-blue-500">
                    <label for="loc-other" class="ml-3 text-sm font-medium text-gray-800 dark:text-gray-200 mr-2 cursor-pointer">기타:</label>
                    <input type="text" id="other-location-input" class="flex-1 bg-transparent border-b border-gray-400 focus:border-blue-500 focus:outline-none text-sm p-1 hidden" placeholder="직접 입력...">
                </div>
            `;
            
            deliveryLocationOptions.innerHTML = radioOptionsHtml;

            const radioButtons = document.querySelectorAll('input[name="delivery-location"]');
            const otherInput = document.getElementById('other-location-input');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', () => {
                    otherInput.classList.toggle('hidden', radio.value !== '기타');
                    if (radio.value === '기타') {
                        otherInput.focus();
                    }
                });
            });

            // ▼▼▼ [수정 시작] 전화번호 유형에 따라 버튼 동적 생성 ▼▼▼
            const buttonsContainer = document.getElementById('delivery-location-buttons');
            const cleanPhoneNumber = getCleanPhoneNumber(item.receiverTelephoneNo);
            const isMobile = cleanPhoneNumber && cleanPhoneNumber.startsWith('010');

            if (isMobile) {
                buttonsContainer.innerHTML = `
                    <button id="location-modal-cancel" class="px-4 py-2 rounded-md bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-sm font-medium hover:bg-gray-400 dark:hover:bg-gray-500" style="flex-grow: 2;">취소</button>
                    <button id="location-modal-confirm-no-sms" class="px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700" style="flex-grow: 4;">배송 완료</button>
                    <button id="location-modal-confirm-with-sms" class="px-4 py-2 rounded-md bg-green-600 text-white text-sm font-medium hover:bg-green-700" style="flex-grow: 4;">문자 보내기</button>
                `;
            } else {
                buttonsContainer.innerHTML = `
                    <button id="location-modal-cancel" class="w-1/2 px-4 py-2 rounded-md bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-sm font-medium hover:bg-gray-400 dark:hover:bg-gray-500">취소</button>
                    <button id="location-modal-confirm-no-sms" class="w-1/2 px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">배송 완료</button>
                `;
            }
            // ▲▲▲ [수정 끝] ▲▲▲

            document.body.classList.add('modal-open');
            deliveryLocationModal.style.display = 'flex';
        };

        const closeDeliveryLocationModal = () => {
            document.body.classList.remove('modal-open');
            deliveryLocationModal.style.display = 'none';
            currentLocationEditItemNo = null;
        };

        const openPhoneEditModal = (itemNo) => {
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item) return;

            const onOk = () => {
                const phoneInput = document.getElementById('phone-edit-input');
                if (!phoneInput) return;
                const newPhoneNumber = phoneInput.value;
                const itemIndex = deliveryItems.findIndex(i => i.no === itemNo);
                if (itemIndex > -1) {
                    deliveryItems[itemIndex].receiverTelephoneNo = newPhoneNumber;
                    saveDeliveryItemsToLocalStorage();
                    renderDeliveryCards(activeFilter);
                    showToastMessage(`${item.no}번 전화번호가 수정되었습니다.`);
                }
            };

            const bodyHtml = `
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-2">숫자만 입력하세요. 자동으로 하이픈(-)이 추가됩니다.</p>
                <form id="phone-edit-form">
                    <input type="tel" id="phone-edit-input" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg bg-white dark:bg-gray-700" value="" inputmode="numeric" maxlength="13">
                </form>
            `;
            
            openConfirmationModal(bodyHtml, onOk, '수정 완료', '취소');
            
            confirmationModalTitle.textContent = `${item.no}번 전화번호 수정`;

            const phoneForm = document.getElementById('phone-edit-form');
            const newPhoneInput = document.getElementById('phone-edit-input');
            
            if (phoneForm && newPhoneInput) {
                const autoHyphenOnInput = (target) => {
                    target.value = target.value
                        .replace(/[^0-9]/g, '')
                        .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, "$1-$2-$3")
                        .replace(/(\-{1,2})$/g, "");
                }
                newPhoneInput.addEventListener('input', (e) => autoHyphenOnInput(e.target));
                newPhoneInput.focus();

                // ▼▼▼ [핵심 수정] 'submit' 이벤트를 '수정 완료' 버튼 클릭으로 연결합니다. ▼▼▼
                phoneForm.addEventListener('submit', (event) => {
                    event.preventDefault(); // 페이지 새로고침 방지
                    
                    // '수정 완료' 버튼을 찾아서 프로그래밍적으로 클릭합니다.
                    const okButton = document.getElementById('confirmOkButton');
                    if (okButton) {
                        okButton.click();
                    }
                });
                // ▲▲▲ [핵심 수정 끝] ▲▲▲
            }
        };
        const openTimeEditModal = (itemNo) => {
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item || !item.deliveryCompletionTime) return;

            const currentTime = item.deliveryCompletionTime.split(' ')[3].substring(0, 5);

            confirmationModalTitle.textContent = `${item.no}번 완료 시간 수정`;
            
            confirmationModalBody.innerHTML = `
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-2">변경할 완료 시간을 선택하세요.</p>
                <input type="time" id="time-edit-input" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg bg-white dark:bg-gray-700" value="${currentTime}">
            `;
            
            confirmOkButton.textContent = '수정 완료';
            confirmCancelButton.textContent = '취소';
            confirmCancelButton.style.display = '';
            confirmationModalButtons.style.display = 'flex';
            
            onConfirmCallback = () => {
                const timeInput = document.getElementById('time-edit-input');
                const newTime = timeInput.value;

                if (newTime) {
                    const itemIndex = deliveryItems.findIndex(i => i.no === itemNo);
                    if (itemIndex > -1) {
                        const originalDateTime = deliveryItems[itemIndex].deliveryCompletionTime;
                        const datePart = originalDateTime.split(' ').slice(0, 3).join(' ');
                        const newCompletionTime = `${datePart} ${newTime}:00`;

                        deliveryItems[itemIndex].deliveryCompletionTime = newCompletionTime;
                        saveDeliveryItemsToLocalStorage();
                        renderDeliveryCards(activeFilter);
                        showToastMessage(`${item.no}번 완료 시간이 수정되었습니다.`);
                    }
                }
            };

            document.body.classList.add('modal-open');
            confirmationModal.style.display = 'flex';
        };

        const openSignatureModal = (itemNo) => { 
            currentSignatureItemNo = itemNo; 
            document.body.classList.add('modal-open');
            signatureModal.style.display = 'flex'; 
            signatureTextInput.value = ''; 
            signatureTextInput.focus(); 
        };

        const closeSignatureModal = () => { 
            document.body.classList.remove('modal-open');
            signatureModal.style.display = 'none'; 
            currentSignatureItemNo = null; 
        };

        const saveSignature = () => {
            const signatureText = signatureTextInput.value.trim();
            if (!signatureText) {
                showMessage('서명 내용을 입력해주세요.');
                return;
            }

            if (currentSignatureItemNo !== null) {
                const item = deliveryItems.find(i => i.no === currentSignatureItemNo);
                if (item) {
                    let completionTime = null;
                    let completionType = item.completionType;

                    if (item.status !== '완료') {
                        copyHawbOnComplete(currentSignatureItemNo);
                        completionTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
                        completionType = '직접입력'; 
                    }
                    
                    if (item.completionType === '본인전달') {
                        deliveryItems = deliveryItems.map(i => i.no === currentSignatureItemNo ? { ...i, receiverNameKorean: signatureText } : i);
                    }

                    handleStatusChange(currentSignatureItemNo, '완료', completionTime, completionType, signatureText);
                    
                    // ▼▼▼ [추가] 웹훅 전송 ▼▼▼
                    const updatedItem = deliveryItems.find(i => i.no === currentSignatureItemNo);
                    if (updatedItem) sendWebhook(updatedItem);
                }
                sortItemsByDistanceSilent();
                closeSignatureModal();
            }
        };

        const openCompletionOptionsModal = (itemNo) => {
            completionOptionsTitle.textContent = `${itemNo}번 완료 옵션 선택`;
            completionOptionsList.innerHTML = '';

            const options = [
                { text: '경비실', type: '경비실', detail: '경비실 전달' },
                { text: '택배함', type: '택배함', detail: '택배함 보관' },
                { text: '택배보관소', type: '택배보관소', detail: '택배보관소 보관' },
                { text: '문서수발실', type: '문서수발실', detail: '문서수발실 전달' }
            ];

            options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'w-full px-4 py-3 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-base font-semibold';
                button.textContent = option.text;
                button.onclick = () => {
                    const currentTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
                    handleStatusChange(itemNo, '완료', currentTime, option.type, option.detail);
                    sortItemsByDistanceSilent();
                    document.body.classList.remove('modal-open');
                    completionOptionsModal.style.display = 'none';
                };
                completionOptionsList.appendChild(button);
            });

            document.body.classList.add('modal-open');
            completionOptionsModal.style.display = 'flex';
        };

        const openConfirmationModal = (message, onOk, okText = '확인', cancelText = '취소') => {
            confirmationModalTitle.textContent = '확인';
            confirmationModalBody.innerHTML = `<p class="text-base text-gray-700 dark:text-gray-300 mb-6" id="confirmation-modal-message">${message}</p>`;
            
            // ▼▼▼ [핵심] 버튼 HTML을 매번 새로 생성하여 이전의 이벤트(.onclick)를 완벽하게 제거합니다. ▼▼▼
            confirmationModalButtons.innerHTML = `
                <button id="confirmCancelButton" class="w-1/2 px-4 py-2 rounded-md bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-sm font-medium hover:bg-gray-400 dark:hover:bg-gray-500">${cancelText}</button>
                <button id="confirmOkButton" class="w-1/2 px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">${okText}</button>
            `;

            document.getElementById('confirmOkButton').onclick = () => {
                if (onOk) onOk();
                closeConfirmationModal();
            };
            document.getElementById('confirmCancelButton').onclick = closeConfirmationModal;
            // ▲▲▲ [핵심 끝] ▲▲▲

            onConfirmCallback = onOk; // 이전 로직과의 호환성을 위해 유지
            confirmationModalButtons.style.display = 'flex';
            document.body.classList.add('modal-open');
            confirmationModal.style.display = 'flex';
        };
        const closeConfirmationModal = () => { 
            document.body.classList.remove('modal-open');
            confirmationModal.style.display = 'none'; 
            onConfirmCallback = null; 
        };

        const openSmartEditModal = (itemNo) => {
            currentEditItemNo = itemNo;
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item) { showMessage('카드 정보를 찾을 수 없습니다.'); return; }
            
            // '수정 행위' 자체를 추적하는 변수 선언
            let hasUserMadeChanges = false; 
            const markAsChanged = () => {
                if (!hasUserMadeChanges) {
                    console.log(`Item ${currentEditItemNo} is being manually edited.`);
                    hasUserMadeChanges = true;
                }
            };
            
            const originalFullAddress = item.baseAddress + (item.detailAddress ? `, ${item.detailAddress}` : '');
            
            originalAddressDisplay.textContent = item.original_ocr_address || '원본 주소 없음';
            
            // ▼▼▼ [수정 시작] 입력창(textarea)을 복제하여 기존 리스너 문제를 원천 차단 ▼▼▼
            const editableAddressContainer = document.getElementById('editable-address-container');
            const oldTextarea = editableAddressContainer.querySelector('textarea');
            const newTextarea = oldTextarea.cloneNode(true);
            newTextarea.value = originalFullAddress; // 새 입력창에 현재 카드 주소 설정
            oldTextarea.parentNode.replaceChild(newTextarea, oldTextarea);
            
            newTextarea.addEventListener('input', markAsChanged);
            newTextarea.addEventListener('input', autoResizeTextarea);

            // ▼▼▼ [추가 시작] 복제된 새 입력창에 주소 이동 이벤트 리스너를 다시 등록합니다. ▼▼▼
            newTextarea.addEventListener('focus', () => {
                const originalAddressContainer = document.getElementById('original-address-container');
                const editableAddressContainer = document.getElementById('editable-address-container');
                if (originalAddressContainer && editableAddressContainer) {
                    editableAddressContainer.before(originalAddressContainer);
                }
            });
            newTextarea.addEventListener('blur', () => {
                const originalAddressContainer = document.getElementById('original-address-container');
                const scrollArea = document.getElementById('smart-edit-scroll-area');
                if (originalAddressContainer && scrollArea) {
                    scrollArea.prepend(originalAddressContainer);
                }
            });
            // ▲▲▲ [추가 끝] ▲▲▲

            setTimeout(() => {
                autoResizeTextarea({target: newTextarea});
            }, 0);

            const addressPiecesContainer = document.getElementById('address-pieces-container');
            const numberKeypad = document.getElementById('number-keypad');
            const unitKeypad = document.getElementById('unit-keypad');
            [addressPiecesContainer, numberKeypad, unitKeypad].forEach(c => c.innerHTML = '');
            
            addressPiecesContainer.dataset.isPieceClicked = 'false';

            const createKeyButton = (text, colorClass, value, action = 'add') => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = `key-button flex-shrink-0 font-semibold m-1 text-sm rounded-md py-1.5 flex items-center justify-center ${colorClass}`;
                button.dataset.value = value !== undefined ? value : text;
                button.dataset.action = action;
                
                const buttonText = document.createElement('span');
                buttonText.textContent = text;
                button.appendChild(buttonText);

                const keyPop = document.createElement('span');
                keyPop.className = 'key-pop';
                keyPop.textContent = text;
                button.appendChild(keyPop);

                button.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    triggerVibration(); // <-- [추가]

    markAsChanged(); // 버튼 클릭 시 '수정 행위' 발생으로 기록

                    const input = document.getElementById('editable-address-input'); // 항상 최신 입력창을 찾음
                    let currentValue = input.value;
                    const act = button.dataset.action;
                    const val = button.dataset.value;

                    const parentContainer = e.currentTarget.closest('#address-pieces-container');
                    if (parentContainer && parentContainer.dataset.isPieceClicked === 'false') {
                        currentValue = '';
                        parentContainer.dataset.isPieceClicked = 'true';
                    }

                    switch (act) {
                        case 'add': input.value = currentValue + val; break;
                        case 'add-space': input.value = currentValue + (currentValue.length > 0 && !/[-\s]$/.test(currentValue) ? ' ' : '') + val; break;
                        case 'add-unit': input.value = currentValue + val + ' '; break;
                        case 'add-comma': input.value = currentValue + (currentValue.length > 0 && !/\s$/.test(currentValue) ? '' : '') + ', '; break;
                        case 'add-hyphen': input.value = currentValue + '-'; break;
                        case 'backspace-char': input.value = currentValue.slice(0, -1); break;
                        case 'backspace-word':
                            const lastSpaceIndex = currentValue.trimEnd().lastIndexOf(' ');
                            input.value = lastSpaceIndex > -1 ? currentValue.substring(0, lastSpaceIndex).trimEnd() : '';
                            break;
                        default: input.value = currentValue + (val !== undefined ? val : act); break;
                    }
                    try { autoResizeTextarea({ target: input }); } catch (err) {}
                });
                return button;
            };

            // ▼▼▼ [수정 시작] 모든 버튼을 복제하고 새 리스너를 연결합니다. ▼▼▼
            const localApplyBtn = document.getElementById('apply-address-btn');
            const localRevertBtn = document.getElementById('revert-address-btn');
            const localResetBtn = document.getElementById('reset-address-btn');

            const newApplyBtn = localApplyBtn.cloneNode(true);
            const newRevertBtn = localRevertBtn.cloneNode(true);
            const newResetBtn = localResetBtn.cloneNode(true);

            localApplyBtn.parentNode.replaceChild(newApplyBtn, localApplyBtn);
            localRevertBtn.parentNode.replaceChild(newRevertBtn, localRevertBtn);
            localResetBtn.parentNode.replaceChild(newResetBtn, localResetBtn);

            newApplyBtn.addEventListener('click', async () => {
                // 1. 클릭 즉시 버튼을 비활성화하여 중복 클릭 방지
                newApplyBtn.disabled = true;
                newApplyBtn.classList.add('opacity-50', 'cursor-not-allowed');

                try {
                    const currentInputValue = document.getElementById('editable-address-input').value;
                    // 2. await를 사용하여 주소 수정 작업이 완전히 끝날 때까지 기다림
                    await applyAddressEdit(currentInputValue.trim(), hasUserMadeChanges);
                } catch (error) {
                    console.error("주소 적용 중 오류 발생:", error);
                    // 오류가 발생해도 버튼은 다시 활성화되어야 함
                } finally {
                    // 3. 작업이 끝나면 (모달이 아직 열려있을 경우를 대비해) 버튼을 다시 활성화
                    // 모달이 닫히기 전에 이 코드가 실행될 수 있으므로, 버튼이 존재하는지 확인
                    const stillExistsBtn = document.getElementById('apply-address-btn');
                    if (stillExistsBtn) {
                        stillExistsBtn.disabled = false;
                        stillExistsBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }
            });

            newRevertBtn.addEventListener('click', () => {
                const item = deliveryItems.find(i => i.no === currentEditItemNo);
                if (item) {
                    const currentTextarea = document.getElementById('editable-address-input');
                    const originalBase = typeof item.ai_base_address !== 'undefined' ? item.ai_base_address : item.baseAddress;
                    const originalDetail = typeof item.ai_detail_address !== 'undefined' ? item.ai_detail_address : item.detailAddress;
                    currentTextarea.value = originalBase + (originalDetail ? `, ${originalDetail}` : '');
                    autoResizeTextarea({ target: currentTextarea });
                    document.getElementById('address-pieces-container').dataset.isPieceClicked = 'false';
                }
            });

            newResetBtn.addEventListener('click', () => {
                const currentTextarea = document.getElementById('editable-address-input');
                currentTextarea.value = '';
                autoResizeTextarea({ target: currentTextarea });
                document.getElementById('address-pieces-container').dataset.isPieceClicked = 'false';
            });
            // ▲▲▲ [수정 끝] ▲▲▲

            const basePieces = (item.ai_base_address || item.baseAddress || '').split(/[\s,]+/).filter(Boolean);
            basePieces.forEach(piece => addressPiecesContainer.appendChild(createKeyButton(piece, 'bg-blue-100 text-blue-800 hover:bg-blue-200 dark:bg-blue-900/50 dark:text-blue-300 dark:hover:bg-blue-900 px-3 !py-1.5 rounded-full', undefined, 'add-space')));

            const detailAddressSource = typeof item.ai_detail_address !== 'undefined' ? item.ai_detail_address : item.detailAddress;
            if (detailAddressSource) {
                addressPiecesContainer.appendChild(createKeyButton(',', 'bg-gray-200 text-gray-800 hover:bg-gray-300 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500 px-3 !py-1.5 rounded-full', undefined, 'add-comma'));
                const detailPieces = (detailAddressSource || '').split(/[\s,]+/).filter(Boolean);
                detailPieces.forEach(piece => addressPiecesContainer.appendChild(createKeyButton(piece, 'bg-green-100 text-green-800 hover:bg-green-200 dark:bg-green-900/50 dark:text-green-300 dark:hover:bg-green-900 px-3 !py-1.5 rounded-full', undefined, 'add-space')));
            }

            ['1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '0', '-'].forEach(key => {
                let action = 'add';
                let colorClass = 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500';
                if (['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'].includes(key)) {
                    colorClass = 'bg-green-100 text-green-800 hover:bg-green-200 dark:bg-green-900/50 dark:text-green-300 dark:hover:bg-green-900';
                }
                if (key === ',') action = 'add-comma';
                if (key === '-') action = 'add-hyphen';
                numberKeypad.appendChild(createKeyButton(key, colorClass, key, action));
            });

            // ▼▼▼ [수정 시작] 요청하신 4x2 그리드 레이아웃에 맞춰 버튼 생성 로직을 재구성합니다. ▼▼▼
            const unitKeypadButtons = [
                // 1행: 길, 번길
                { text: '길',    colorClass: 'bg-blue-100 hover:bg-blue-200 dark:bg-blue-900/50 dark:hover:bg-blue-900', value: '길',    action: 'add-unit' },
                { text: '번길',  colorClass: 'bg-blue-100 hover:bg-blue-200 dark:bg-blue-900/50 dark:hover:bg-blue-900', value: '번길',  action: 'add-unit' },
                // 2행: 동, 리
                { text: '동',    colorClass: 'bg-blue-100 hover:bg-blue-200 dark:bg-blue-900/50 dark:hover:bg-blue-900', value: '동',    action: 'add-unit' },
                { text: '리',    colorClass: 'bg-blue-100 hover:bg-blue-200 dark:bg-blue-900/50 dark:hover:bg-blue-900', value: '리',    action: 'add-unit' },
                // 3행: 호, 빈칸
                { text: '호',    colorClass: 'bg-blue-100 hover:bg-blue-200 dark:bg-blue-900/50 dark:hover:bg-blue-900', value: '호',    action: 'add-unit' },
                { text: '\u00A0', colorClass: 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500', value: ' ',     action: 'add' },
                // 4행: <, <<
                { text: '<',     colorClass: 'bg-gray-400 hover:bg-gray-500 text-white',                                 value: '<',     action: 'backspace-char' },
                { text: '<<',    colorClass: 'bg-red-500 hover:bg-red-600 text-white',                                   value: '<<',    action: 'backspace-word' }
            ];

            // 재구성된 버튼 정보를 기반으로 버튼을 순서대로 생성합니다.
            unitKeypadButtons.forEach(btnInfo => {
                const button = createKeyButton(btnInfo.text, btnInfo.colorClass, btnInfo.value, btnInfo.action);
                unitKeypad.appendChild(button);
            });
            // ▲▲▲ [수정 끝] ▲▲▲

            const modalContent = smartEditModal.querySelector('.smart-edit-modal-content');
            modalContent.style.maxHeight = `${window.innerHeight - 48}px`;

            document.body.classList.add('modal-open');
            smartEditModal.style.display = 'flex';
            history.pushState({ smartEditModalOpen: true }, "");
        };

        const closeSmartEditModal = () => {
            const modalContent = smartEditModal.querySelector('.smart-edit-modal-content');
            
            const closeModal = () => {
                document.body.classList.remove('modal-open');
                smartEditModal.style.display = 'none';
                modalContent.style.maxHeight = ''; // 고정했던 높이 제거
                currentEditItemNo = null;
            };

            if (history.state && history.state.smartEditModalOpen) {
                history.back(); // popstate 이벤트 리스너가 모달을 닫는 동작을 처리할 것임
            } else {
                closeModal();
            }
        };
        
        const applyAddressEdit = async (fullAddress, wasChanged) => {
            if (currentEditItemNo === null) return;
            
            showLoadingMessage('주소 검증 중...');

            const itemIndex = deliveryItems.findIndex(item => item.no === currentEditItemNo);
            if (itemIndex === -1) {
                closeConfirmationModal();
                showMessage('오류: 수정할 카드를 찾을 수 없습니다.');
                return;
            }

            const commaIndex = fullAddress.indexOf(',');
            let tempBaseAddress, tempDetailAddress;

            if (commaIndex > -1) {
                tempBaseAddress = fullAddress.substring(0, commaIndex).trim();
                tempDetailAddress = fullAddress.substring(commaIndex + 1).trim();
            } else {
                tempBaseAddress = fullAddress;
                tempDetailAddress = '';
            }

            const validationResult = await validateAddressWithKakao(tempBaseAddress, tempDetailAddress);
            closeConfirmationModal();

            const saveAddress = (base, detail, isValidated) => {
                // 전달받은 'wasChanged' 값으로 상태를 최종 결정
                if (wasChanged) {
                    deliveryItems[itemIndex].feedback_status = 'USER_CORRECTED';
                    console.log(`Item ${currentEditItemNo} final status saved as USER_CORRECTED.`);
                } else {
                    // 수정 행위가 없었다면, 상태를 변경하지 않음 (AI_CORRECT 또는 UNCONFIRMED 유지)
                    console.log(`Item ${currentEditItemNo} saved without changes to feedback_status.`);
                }

                deliveryItems[itemIndex].baseAddress = base;
                deliveryItems[itemIndex].detailAddress = detail;
                deliveryItems[itemIndex].addressLocation = null;
                deliveryItems[itemIndex].isAddressValidated = isValidated;
                
                saveDeliveryItemsToLocalStorage();
                renderDeliveryCards(activeFilter);
                closeSmartEditModal();
            };

            if (validationResult.validated) {
                saveAddress(validationResult.baseAddress, validationResult.detailAddress, true);
                showToastMessage('주소가 검증 및 저장되었습니다.');
            } else {
                const message = `카카오맵에서 주소를 찾을 수 없습니다. 입력하신 '${fullAddress}' 주소 그대로 저장하시겠습니까?`;
                openConfirmationModal(message, () => {
                    saveAddress(tempBaseAddress, tempDetailAddress, false);
                    showToastMessage('입력한 주소 그대로 저장되었습니다.');
                });
            }
        };
        
        smartEditExitBtn.addEventListener('click', closeSmartEditModal);
        editableAddressInput.addEventListener('input', autoResizeTextarea);
        confirmOkButton.addEventListener('click', () => { if (onConfirmCallback) onConfirmCallback(); closeConfirmationModal(); });
        confirmCancelButton.addEventListener('click', closeConfirmationModal);
        clearSignatureBtn.addEventListener('click', () => signatureTextInput.value = '');
        cancelSignatureBtn.addEventListener('click', closeSignatureModal);
        saveSignatureBtn.addEventListener('click', saveSignature);

        const saveDeliveryItemsToLocalStorage = () => {
            localStorage.setItem('deliveryItems', JSON.stringify(deliveryItems));
            localStorage.setItem('filterScrollPositions', JSON.stringify(filterScrollPositions));
        };

        // ▼▼▼ [수정] 송장번호 복사 헬퍼 함수 추가 및 handleStatusChange 원상 복구 ▼▼▼
        const copyHawbOnComplete = (itemNo) => {
            const item = deliveryItems.find(i => i.no === itemNo);
            if (item && item.hawbNo) {
                navigator.clipboard.writeText(item.hawbNo).then(() => {
                    showToastMessage(`송장번호 ${item.hawbNo} 복사 완료`);
                }).catch(err => {
                    console.error('송장번호 복사 실패:', err);
                    showToastMessage('송장번호 복사에 실패했습니다.', 2500);
                });
            }
        };

        // ▼▼▼ [추가 시작] 웹훅 전송 함수 ▼▼▼
        const sendWebhook = (item) => {
            const webhookUrl = localStorage.getItem('webhookUrl');
            if (!webhookUrl) {
                console.log("웹훅 URL이 설정되지 않아 전송을 건너뜁니다.");
                return;
            }

            // ▼▼▼ [핵심 수정] 복잡한 fetch 대신, CORS 제약이 없는 간단한 이미지 로드 방식으로 변경 ▼▼▼
            try {
                // 1. 눈에 보이지 않는 이미지 객체를 하나 만듭니다.
                const img = new Image();
                
                // 2. 이 이미지의 소스(src)를 우리가 호출하려는 웹훅 URL로 지정합니다.
                //    브라우저는 이 "이미지"를 불러오기 위해 해당 URL로 GET 요청을 보냅니다.
                //    이 요청 자체가 매크로드로이드의 트리거(신호)가 됩니다.
                img.src = webhookUrl;

                // 3. 성공/실패 여부와 관계없이 요청은 보내졌으므로, 사용자에게 피드백을 줍니다.
                console.log(`웹훅 호출 시도 (항목 ${item.no}): ${webhookUrl}`);
                showToastMessage(`${item.no}번 자동화 트리거 호출`);

            } catch (error) {
                // 이 방식은 거의 오류를 발생시키지 않지만, 만약을 위해 남겨둡니다.
                console.error(`웹훅 호출 중 오류 (항목 ${item.no}):`, error);
                showToastMessage(`자동화 트리거 호출 실패`, 3000);
            }
            // ▲▲▲ [수정 끝] ▲▲▲
        };
        // ▲▲▲ [추가 끝] ▲▲▲

        const handleStatusChange = (itemNo, newStatus, completionTime = null, completionType = null, completionDetail = null) => {
            deliveryItems = deliveryItems.map(item => {
                if (item.no === itemNo) {
                    const updatedItem = { ...item, status: newStatus, isHawbConfirmed: newStatus !== '배송전' };
                    if (completionTime !== null) updatedItem.deliveryCompletionTime = completionTime;
                    if (completionType !== null) updatedItem.completionType = completionType;
                    if (completionDetail !== null) updatedItem.completionDetail = completionDetail;
                    return updatedItem;
                }
                return item;
            });
            saveDeliveryItemsToLocalStorage();
            renderDeliveryCards(activeFilter);
            updateFilterCounts();
        };
        // ▲▲▲ [수정 끝] ▲▲▲

        const handleCheckboxToggleAndResetSearch = async (itemNo, newCheckboxState) => {
            const checkbox = document.querySelector(`input[data-action="toggle-hawb-confirm"][data-no="${itemNo}"]`);
            if (!checkbox) return;

            const itemIndex = deliveryItems.findIndex(item => item.no === itemNo);
            if (itemIndex === -1) return;

            if (newCheckboxState) {
                deliveryItems[itemIndex].isHawbConfirmed = true;
                deliveryItems[itemIndex].status = '배송중';
                
                // ▼▼▼ [수정] 주소가 수정되지 않았다면 'AI 정답'으로 기록 ▼▼▼
                if (deliveryItems[itemIndex].feedback_status !== 'USER_CORRECTED') {
                    deliveryItems[itemIndex].feedback_status = 'AI_CORRECT';
                }
                // ▲▲▲ [수정 끝] ▲▲▲
                
                saveDeliveryItemsToLocalStorage();
                searchTerm = '';
                invoiceNumberInput.value = '';
                renderDeliveryCards(activeFilter);
                updateFilterCounts();
                collapseSearch();

                if (!deliveryItems[itemIndex].addressLocation) {
                    try {
                        const coords = await getCoordsFromAddress(deliveryItems[itemIndex].baseAddress);
                        deliveryItems[itemIndex].addressLocation = coords;
                        saveDeliveryItemsToLocalStorage();
                        showToastMessage(`${itemNo}번 체크인 완료 (좌표 저장 성공)`);
                    } catch (error) {
                        console.error(`좌표 획득 실패 (항목 ${itemNo}):`, error.message);
                        showToastMessage(`${itemNo}번 체크인 완료 (좌표 저장 실패)`, 2500);
                    }
                } else {
                    showToastMessage(`${itemNo}번 체크인 완료 (좌표 이미 존재)`);
                }

            } else {
                deliveryItems[itemIndex].isHawbConfirmed = false;
                deliveryItems[itemIndex].status = '배송전';
                deliveryItems[itemIndex].feedback_status = 'UNCONFIRMED'; // ▼▼▼ [수정] 체크 해제 시 미확인으로
                deliveryItems[itemIndex].addressLocation = null;
                delete deliveryItems[itemIndex].distanceFromMe;
                
                saveDeliveryItemsToLocalStorage();
                searchTerm = '';
                invoiceNumberInput.value = '';
                renderDeliveryCards(activeFilter);
                updateFilterCounts();
                showToastMessage('체크인이 취소되었습니다.');
            }
        };
        
        const openMap = (item, noToast = false) => {
            const selectedMap = localStorage.getItem('selectedMap') || 'naver';
            const addressForMapSearch = item.baseAddress || '';
            
            // 싱글 탭일 때만 기본 텍스트를 복사하고 토스트 메시지를 띄움
            if (!noToast) {
                const textToCopy = `${item.no}. ${extractClipboardAddressPart(item)}`;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    showToastMessage(`'${textToCopy}' 복사 완료`);
                }).catch(err => {
                    console.error('클립보드 복사 실패:', err);
                    showMessage('클립보드 복사에 실패했습니다.', '복사 실패');
                });
            }

            let mapUrl = selectedMap === 'naver'
                ? `nmap://search?query=${encodeURIComponent(addressForMapSearch)}&appname=DeliveryApp`
                : `kakaomap://search?q=${encodeURIComponent(addressForMapSearch)}`;
            window.location.href = mapUrl;
        };

        const highlightHawbNo = (hawbNo, term) => {
            if (!hawbNo) return '';
            const formattedHawbNo = formatHawbNoForDisplay(hawbNo);
            if (!term || !formattedHawbNo.toLowerCase().includes(term.toLowerCase())) return formattedHawbNo;
            const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(${escapedTerm})`, 'gi');
            // ▼▼▼ [수정] 다크모드용 하이라이트 배경색(dark:bg-yellow-500/50) 추가 ▼▼▼
            return formattedHawbNo.replace(regex, `<span class="bg-yellow-200 dark:bg-yellow-500/50 rounded px-0.5">$1</span>`);
        };
        
        const renderDeliveryCards = (currentFilter, animationClass = '') => {
            if (currentFilter === '배송준비') { deliveryCardsContainer.innerHTML = ''; return; }

            let baseData = currentFilter !== '전체'
                ? deliveryItems.filter(item => item.status === currentFilter)
                : [...deliveryItems];

            let dataToRender = searchTerm
                ? baseData.filter(item => {
                    const cleanedSearchTerm = searchTerm.trim().replace(/[\s-]/g, '').toLowerCase();
                    const hawbMatch = item.hawbNo?.replace(/[\s-]/g, '').toLowerCase().includes(cleanedSearchTerm);
                    const phoneMatch = item.receiverTelephoneNo?.includes(cleanedSearchTerm);
                    return hawbMatch || phoneMatch;
                })
                : baseData;
            
            if (dataToRender.length === 0) {
                // ▼▼▼ [수정] 다크모드용 텍스트 색상(dark:text-gray-400) 추가 ▼▼▼
                deliveryCardsContainer.innerHTML = '<p class="text-center text-gray-600 dark:text-gray-400 px-4">해당하는 항목이 없습니다.</p>';
                return;
            }

            deliveryCardsContainer.innerHTML = dataToRender.map(data => {
                const selectedMap = localStorage.getItem('selectedMap') || 'naver';
                const mapButtonClass = selectedMap === 'naver' ? 'naver' : 'kakao';
                const isPhoneNumberInvalid = !isValidPhoneNumber(data.receiverTelephoneNo);
                const fullAddress = data.baseAddress + (data.detailAddress ? `, ${data.detailAddress}` : '');
                const isMapButtonActive = isValidAddressForMap(data.baseAddress) && ['전체', '배송전', '배송중'].includes(currentFilter);
                const distanceInfo = (currentSortOrder === 'distance' && data.distanceFromMe !== undefined && data.status === '배송중')
                    // ▼▼▼ [수정] 다크모드용 텍스트 색상(dark:text-purple-400) 추가 ▼▼▼
                    ? `<span class="block text-sm font-medium text-purple-600 dark:text-purple-400 -mt-1">(${data.distanceFromMe.toFixed(2)} km)</span>`
                    : '';
                
                let cardClasses = '';
                // ▼▼▼ [수정] 다크모드용 테두리 색상(dark:border-...) 추가 ▼▼▼
                let headerBorder = 'border-gray-200 dark:border-gray-600';
                let actionBorder = 'border-gray-200 dark:border-gray-600';

                if (data.status === '배송전') {
                    // ▼▼▼ [수정] 다크모드용 배경/테두리 색상 추가 ▼▼▼
                    cardClasses = 'bg-white dark:bg-gray-800 rounded-t-3xl rounded-bl-3xl border-2 border-gray-600 dark:border-gray-500';
                } else if (data.status === '배송중') {
                    // ▼▼▼ [수정] 다크모드용 배경/테두리 색상 추가 ▼▼▼
                    cardClasses = 'bg-blue-50 dark:bg-blue-900/30 rounded-t-3xl rounded-bl-3xl border-2 border-blue-600 dark:border-blue-500';
                    headerBorder = 'border-blue-200 dark:border-blue-700';
                    actionBorder = 'border-blue-200 dark:border-blue-700';
                } else if (data.status === '완료') {
                    // ▼▼▼ [수정] 다크모드용 배경/테두리 색상 추가 ▼▼▼
                    cardClasses = 'bg-gray-200 dark:bg-gray-700 rounded-t-3xl rounded-bl-3xl border-2 border-gray-300 dark:border-gray-600';
                }

                const showCompletedCard = !['전체', '배송전', '배송중'].includes(currentFilter) && data.status === '완료';
                const showInProgressButtons = !['전체', '배송전', '완료'].includes(currentFilter) && data.status === '배송중';

                const detailsHtml = `
                    <div class="flex items-start space-x-2.5">
                        <button data-action="open-map" data-no="${data.no}" class="map-icon-button rounded-full flex items-center justify-center ${mapButtonClass} ${isMapButtonActive ? '' : 'opacity-50 cursor-not-allowed'}" ${isMapButtonActive ? '' : 'disabled'}>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 22a1 1 0 0 1-1-1v-4a1 1 0 0 1 .445-.832l3-2a1 1 0 0 1 1.11 0l3 2A1 1 0 0 1 22 17v4a1 1 0 0 1-1 1z"/><path d="M18 10a8 8 0 0 0-16 0c0 4.993 5.539 10.193 7.399 11.799a1 1 0 0 0 .601.2"/><path d="M18 22v-3"/><circle cx="10" cy="10" r="3"/></svg>
                        </button>
                        <div class="pt-0.5">
                            <p class="text-base font-semibold ${currentFilter !== '배송중' ? 'cursor-pointer' : ''} ${data.isAddressValidated === false ? 'text-red-500 dark:text-red-400' : 'text-blue-600 dark:text-blue-400'}"
                               ${currentFilter !== '배송중' ? `data-action="open-smart-edit" data-no="${data.no}"` : ''}>
                                ${fullAddress.trim() ? fullAddress : '<span class="text-red-500 dark:text-red-400 cursor-pointer underline font-medium">[주소 없음 (터치하여 입력)]</span>'}
                            </p>
                            ${data.original_ocr_address ? `<p class="text-xs text-gray-500 dark:text-gray-400">(${data.original_ocr_address})</p>` : ''}
                        </div>
                    </div>
                    <div class="flex items-start space-x-2.5">
                        <div class="flex-shrink-0 pt-1 text-gray-500 dark:text-gray-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z"/><path d="M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2"/><path d="M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2"/><path d="M10 6h4"/><path d="M10 10h4"/><path d="M10 14h4"/><path d="M10 18h4"/></svg>
                        </div>
                        <div>
                            <p class="text-base text-blue-600 dark:text-blue-400 font-semibold">${data.companyNameKorean || 'N/A'}</p>
                            ${data.companyNameOriginal && data.companyNameOriginal !== data.companyNameKorean ? `<p class="text-xs text-gray-500 dark:text-gray-400">(${data.companyNameOriginal})</p>` : ''}
                        </div>
                    </div>
                    <div class="flex items-start space-x-2.5">
                        <div class="flex-shrink-0 pt-1 text-gray-500 dark:text-gray-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><path d="M16 3.128a4 4 0 0 1 0 7.744"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><circle cx="9" cy="7" r="4"/></svg>
                        </div>
                        <div>
                            <div class="flex items-center space-x-2">
                                <p class="text-base text-blue-600 dark:text-blue-400 font-semibold">${data.receiverNameKorean || 'N/A'}</p>
                                <button data-action="swap-name" data-no="${data.no}" class="p-1 text-gray-400 dark:text-gray-500 rounded-full">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>
                                </button>
                            </div>
                            ${data.receiverNameOriginal && data.receiverNameOriginal !== data.receiverNameKorean ? `<p class="text-xs text-gray-500 dark:text-gray-400">(${data.receiverNameOriginal})</p>` : ''}
                        </div>
                    </div>
                    <div class="flex items-start space-x-2.5">
                        <div class="flex-shrink-0 pt-1 text-gray-500 dark:text-gray-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="20" x="5" y="2" rx="2" ry="2"/><path d="M12 18h.01"/></svg>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-base font-semibold cursor-pointer ${isPhoneNumberInvalid || !data.receiverTelephoneNo ? 'text-red-500 dark:text-red-400 underline' : 'text-blue-600 dark:text-blue-400'}"
                                  data-action="edit-phone" data-no="${data.no}">
                                ${data.receiverTelephoneNo ? formatPhoneNumberForDisplay(data.receiverTelephoneNo) : '[번호 없음 (터치하여 입력)]'}
                            </span>
                            <a href="tel:${getCleanPhoneNumber(data.receiverTelephoneNo)}" class="px-3 py-1.5 rounded-full bg-transparent text-orange-500 border border-orange-500 hover:bg-orange-100 dark:text-orange-400 dark:border-orange-400 dark:hover:bg-orange-900/30 ${!data.receiverTelephoneNo ? 'hidden' : ''}">전화</a>
                            <a href="sms:${getCleanPhoneNumber(data.receiverTelephoneNo)}" class="px-3 py-1.5 rounded-full bg-transparent text-blue-500 border border-blue-500 hover:bg-blue-100 dark:text-blue-400 dark:border-blue-400 dark:hover:bg-blue-900/30 ${!data.receiverTelephoneNo ? 'hidden' : ''}">문자</a>
                        </div>
                    </div>
                    ${data.status === '완료' ? `<div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-600 flex justify-center"><button data-action="revert-delivery" data-no="${data.no}" class="px-4 py-2 rounded-md bg-red-500 text-white text-sm font-medium">되돌리기</button></div>` : ''}
                `;

                if (showCompletedCard) {
                    const isEditableText = ['본인전달', '직접입력'].includes(data.completionType);
                    const isSelectableLocation = !isEditableText && data.completionType !== '서명';

                    const completionDisplayHtml = data.completionType === '서명' && data.completionDetail 
                        ? `<span class="text-lg font-semibold text-gray-800 dark:text-gray-200 p-1 border border-dashed border-gray-400 dark:border-gray-500 rounded-md bg-gray-50 dark:bg-gray-600 inline-block">${data.completionDetail}</span>`
                        : (isEditableText || isSelectableLocation)
                            ? `<span data-action="edit-completion-detail" data-no="${data.no}" class="text-lg font-semibold text-gray-800 dark:text-gray-200 cursor-pointer">${data.completionType === '본인전달' ? (data.receiverNameKorean || '') : data.completionDetail}</span>`
                            : `<span class="text-lg font-semibold text-gray-800 dark:text-gray-200">${data.completionDetail || data.completionType}</span>`;

                    return `
                        <div class="${cardClasses} p-4 mb-4" data-no="${data.no}">
                            <div class="flex justify-between items-center">
                                <div class="text-xl font-semibold text-gray-700 dark:text-gray-300 text-left flex items-center ${data.isStruckThrough ? 'completed-strikethrough' : ''}">
                                    <span data-action="copy-completion" data-no="${data.no}" class="text-red-500 dark:text-red-400 text-2xl mr-4 cursor-pointer">${data.no}</span>
                                    ${completionDisplayHtml}
                                    <span data-action="edit-completion-time" data-no="${data.no}" class="ml-2 cursor-pointer">${formatCompletionTime(data.deliveryCompletionTime)}</span>
                                </div>
                                <button data-action="toggle-details" data-no="${data.no}" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-600 flex-shrink-0">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-600 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                                    </svg>
                                </button>
                            </div>
                            <div class="space-y-3 mt-4 pt-4 border-t border-gray-300 dark:border-gray-500" data-details-container="${data.no}" style="display:none;">
                                ${detailsHtml}
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="${cardClasses} p-6 mb-4" data-no="${data.no}">
                            <div class="flex justify-between items-start mb-4 pb-2 border-b ${headerBorder}">
                                <div class="flex justify-between items-start w-full">
                                    <div class="flex items-start space-x-4">
                                        <div>
                                            <h3 class="text-3xl font-semibold text-red-500 dark:text-red-400">${data.no}</h3>
                                            ${distanceInfo}
                                        </div>
                                        <div class="pt-1.5">
                                            <span data-action="copy-hawb" data-hawb-no="${data.hawbNo}" data-no="${data.no}" class="text-base font-bold text-gray-600 dark:text-gray-300 whitespace-nowrap">${highlightHawbNo(data.hawbNo, searchTerm)}</span>
                                        </div>
                                    </div>
                                    <div class="pt-1.5">
                                        <input type="checkbox" data-action="toggle-hawb-confirm" data-no="${data.no}" ${data.isHawbConfirmed ? 'checked' : ''} class="form-checkbox h-4 w-4 text-blue-600 border-gray-300 dark:border-gray-500 rounded ml-2"/>
                                    </div>
                                </div>
                            </div>
                            <div class="space-y-3" data-details-container="${data.no}">
                                ${detailsHtml}
                            </div>
                            ${showInProgressButtons ? `
                                <div class="mt-4 pt-4 border-t ${actionBorder} flex justify-between space-x-2 w-full">
                                    <button data-action="identity-verification" data-no="${data.no}" class="flex-1 px-3 py-2 rounded-lg bg-green-500 text-white text-sm font-semibold hover:bg-green-600 transition-colors">본인전달</button>
                                    <button data-action="open-location-modal" data-no="${data.no}" class="flex-1 px-3 py-2 rounded-lg bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition-colors">배송위치</button>
                                    <button data-action="sign-delivery" data-no="${data.no}" class="flex-1 px-3 py-2 rounded-lg bg-indigo-500 text-white text-sm font-semibold hover:bg-indigo-600 transition-colors">직접입력</button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            }).join('');
        
            if (animationClass) {
                deliveryCardsContainer.classList.remove('animate-slide-in-left', 'animate-slide-in-right');
                void deliveryCardsContainer.offsetWidth;
                deliveryCardsContainer.classList.add(animationClass);
            }
        };

    const updateFilterCounts = () => {
        const counts = {
            '전체': deliveryItems.length,
            '배송전': deliveryItems.filter(item => item.status === '배송전').length,
            '배송중': deliveryItems.filter(item => item.status === '배송중').length,
            '완료': deliveryItems.filter(item => item.status === '완료').length
        };

        for (const filter in counts) {
            const countElement = document.getElementById(`count-${filter}`);
            if (countElement) {
                const count = counts[filter];
                countElement.textContent = count > 99 ? '99+' : count;
                countElement.classList.toggle('hidden', count === 0);
            }
        }
    };
    
    const updateStickyHeaderPositions = () => {
        requestAnimationFrame(() => {
            const isScanVisible = activeFilter === '배송준비';
            scanSectionContainer.classList.toggle('hidden', !isScanVisible);
            dataManagementContainer.classList.toggle('hidden', !isScanVisible);
            versionInfoContainer.classList.toggle('hidden', !isScanVisible); 

            if (['전체', '배송전'].includes(activeFilter)) {
                searchBarContainer.style.display = 'block';
                actionBarContainer.style.display = 'none';
            } else if (['배송중', '완료'].includes(activeFilter)) {
                searchBarContainer.style.display = 'none';
                actionBarContainer.style.display = 'block';
                setupFab();
            } else {
                searchBarContainer.style.display = 'none';
                actionBarContainer.style.display = 'none';
            }
        });
    };
    
    const setupFab = () => {
        if (activeFilter !== '배송중' && activeFilter !== '완료') return;

        const fabMainButton = document.getElementById('fab-main-button');
        const fabOptions = document.getElementById('fab-options');

        // 1. 기존 아이콘들을 확실하게 제거하여 겹침 현상을 원천 방지합니다.
        while (fabOptions.firstChild) {
            fabOptions.removeChild(fabOptions.firstChild);
        }
        while (fabMainButton.firstChild) {
            fabMainButton.removeChild(fabMainButton.firstChild);
        }

        let allMenuItems = [];
        let currentSortType = '';
        let activeColorClass = '';

        // ▼▼▼ [수정] 보내주신 새 아이콘 SVG 코드로 교체 ▼▼▼
        // 배송중 필터 아이콘
        const iconJump = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5h10"/><path d="M11 12h10"/><path d="M11 19h10"/><path d="M4 4h1v5"/><path d="M4 9h2"/><path d="M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02"/></svg>`;
        const iconSortDistance = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="2" x2="5" y1="12" y2="12"/><line x1="19" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="5"/><line x1="12" x2="12" y1="19" y2="22"/><circle cx="12" cy="12" r="7"/></svg>`;
        const iconSortNo = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 16 4 4 4-4"/><path d="M7 20V4"/><rect x="15" y="4" width="4" height="6" ry="2"/><path d="M17 20v-6h-2"/><path d="M15 20h4"/></svg>`;
        
        // 완료 필터 아이콘
        const iconSortTime = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 6v6l4 2"/><circle cx="12" cy="12" r="10"/></svg>`;
        const iconCopyAll = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>`;

        if (activeFilter === '배송중') {
            allMenuItems = [
                // '카드선택(순번선택)'은 정렬 상태가 아니므로 'action' 타입으로 지정
                { icon: iconJump, action: 'jump-no', type: 'action' }, 
                // '순번순정렬'은 정렬 상태이므로 'sort' 타입으로 지정
                { icon: iconSortNo, action: 'sort-no', sortType: 'no', type: 'sort' },
                // '거리순정렬'은 정렬 상태이므로 'sort' 타입으로 지정
                { icon: iconSortDistance, action: 'sort-distance', sortType: 'distance', type: 'sort' }
            ];
            currentSortType = deliveryInProgressSortOrder;
            activeColorClass = 'bg-blue-600 text-white';
        } else if (activeFilter === '완료') {
            allMenuItems = [
                // '순번순정렬'은 정렬 상태이므로 'sort' 타입으로 지정
                { icon: iconSortNo, action: 'sort-no-completed', sortType: 'no', type: 'sort' },
                // '완료시간순 정렬'은 정렬 상태이므로 'sort' 타입으로 지정
                { icon: iconSortTime, action: 'sort-time', sortType: 'time', type: 'sort' },
                // ▼▼▼ [이 부분 추가] ▼▼▼
                { icon: iconCopyAll, action: 'copy-all-completed', type: 'action' }
                // ▲▲▲ [추가 끝] ▲▲▲
            ];
            currentSortType = completedSortOrder;
            activeColorClass = 'bg-gray-800 text-white dark:bg-gray-200 dark:text-gray-800';
        }

        // 2. 메인 버튼에 표시할 '정렬 아이콘'을 명확하게 찾습니다.
        // 'sort' 타입 중에서 현재 정렬 상태와 일치하는 것을 찾고, 없으면 첫 번째 'sort' 타입을 기본값으로 합니다.
        const sortItems = allMenuItems.filter(item => item.type === 'sort');
        let activeSortItem = sortItems.find(item => item.sortType === currentSortType) || sortItems[0];

        // 3. 메인 FAB 버튼에는 위에서 찾은 '정렬 아이콘' 하나만 표시합니다.
        if (activeSortItem) {
            fabMainButton.innerHTML = activeSortItem.icon;
        }
        fabMainButton.className = `w-10 h-10 flex-shrink-0 flex items-center justify-center rounded-full transition-colors duration-200 ${activeColorClass}`;
        fabMainButton.dataset.action = 'toggle-fab';

        // 4. 옵션 버튼 목록에는 메인 버튼에 표시된 것을 제외한 나머지 모든 아이템을 포함합니다.
        const optionItems = allMenuItems.filter(item => item !== activeSortItem);

        optionItems.forEach(item => {
            const button = document.createElement('button');
            button.className = 'w-10 h-10 flex-shrink-0 flex items-center justify-center rounded-full bg-white dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-600 shadow-md';
            button.innerHTML = item.icon;
            button.dataset.action = item.action;
            fabOptions.appendChild(button);
        });
    };
    const sortItemsByNumber = () => {
        deliveryInProgressSortOrder = 'no';
        currentSortOrder = 'no';
        deliveryItems.sort((a, b) => a.no - b.no);
        renderDeliveryCards(activeFilter);
        setupFab();
    };

    const sortItemsByDistanceSilent = async () => {
        if (activeFilter !== '배송중' || deliveryInProgressSortOrder !== 'distance') return;
        try {
            const myLocation = await getCurrentLocation(5000);
            const inProgressItems = deliveryItems.filter(item => item.status === '배송중');
            const otherItems = deliveryItems.filter(item => item.status !== '배송중');
            const itemsWithCoords = inProgressItems.filter(item => item.addressLocation);
            const itemsWithoutCoords = inProgressItems.filter(item => !item.addressLocation);
            
            itemsWithCoords.forEach(item => { item.distanceFromMe = calculateDistance(myLocation, item.addressLocation); });
            itemsWithCoords.sort((a, b) => a.distanceFromMe - b.distanceFromMe);
            
            deliveryItems = [...itemsWithCoords, ...itemsWithoutCoords, ...otherItems];
            renderDeliveryCards(activeFilter);
            console.log('자동 거리순 정렬 완료.');
        } catch (error) {
            console.log('자동 정렬 실패 (GPS 신호 없음):', error.message);
        }
    };

    const sortItemsByDistance = async (silent = false) => {
        if (activeFilter !== '배송중') {
            showToastMessage("'배송중' 필터에서만 거리순 정렬이 가능합니다.");
            return;
        }
        
        deliveryInProgressSortOrder = 'distance';
        currentSortOrder = 'distance';

        if (!silent) {
            showLoadingMessage('현재 위치를 기반으로 거리를 계산 중입니다...');
        }

        try {
            const myLocation = await getCurrentLocation();
            
            const inProgressItems = deliveryItems.filter(item => item.status === '배송중');
            const otherItems = deliveryItems.filter(item => item.status !== '배송중');

            // 좌표가 없는 항목들의 좌표를 먼저 가져옵니다.
            const itemsToGeocode = inProgressItems.filter(item => !item.addressLocation);
            if (itemsToGeocode.length > 0) {
                if (!silent) {
                    confirmationModalBody.querySelector('p').textContent = `주소 좌표 변환 중... (0/${itemsToGeocode.length})`;
                }
                await Promise.all(itemsToGeocode.map(async (item, index) => {
                    try {
                        const coords = await getCoordsFromAddress(item.baseAddress);
                        item.addressLocation = coords;
                        if (!silent) {
                            confirmationModalBody.querySelector('p').textContent = `주소 좌표 변환 중... (${index + 1}/${itemsToGeocode.length})`;
                        }
                    } catch (error) {
                        console.warn(`항목 ${item.no}의 좌표 변환 실패:`, error.message);
                    }
                }));
            }

            // 모든 '배송중' 항목에 대해 거리 계산
            inProgressItems.forEach(item => {
                if (item.addressLocation) {
                    item.distanceFromMe = calculateDistance(myLocation, item.addressLocation);
                } else {
                    item.distanceFromMe = Infinity; // 좌표 없는 항목은 맨 뒤로
                }
            });

            // 거리순으로 정렬
            inProgressItems.sort((a, b) => a.distanceFromMe - b.distanceFromMe);

            // 전체 배열 재구성
            deliveryItems = [...inProgressItems, ...otherItems];
            
            saveDeliveryItemsToLocalStorage();
            renderDeliveryCards(activeFilter);
            if (!silent) {
                showToastMessage('거리순으로 정렬되었습니다.');
            }
        } catch (error) {
            console.error('거리순 정렬 오류:', error);
            if (!silent) {
                showMessage(`거리 계산에 실패했습니다: ${error.message}`, '오류');
            } else {
                showToastMessage('위치 정보를 가져올 수 없어 새로고침에 실패했습니다.', 2500);
            }
        } finally {
            if (!silent) {
                closeConfirmationModal();
            }
            setupFab();
        }
    };

    // ▼▼▼ [수정] Tailwind JIT 컴파일러를 위한 주석 (무채색 테마 반영) ▼▼▼
    // 이 주석은 JavaScript 변수 안에 있는 클래스 이름을
    // Tailwind가 빌드 시 인식하여 최종 CSS에 포함시키도록 하는 역할을 합니다.
    //
    // 필터 버튼 활성 클래스:
    // bg-blue-100 dark:bg-gray-700 text-blue-600 dark:text-gray-100
    //
    // 필터 버튼 비활성 클래스:
    // bg-transparent text-gray-500 dark:text-gray-400
    const changeFilter = (newFilter, animationClass = '', isInitialLoad = false) => {
        if (newFilter === activeFilter && !isInitialLoad) return;

        localStorage.setItem('lastActiveFilter', newFilter);

        collapseSearch();
        const fabOptions = document.getElementById('fab-options');
        if (fabOptions) fabOptions.classList.remove('expanded');
        if (!isInitialLoad) {
            searchTerm = '';
            invoiceNumberInput.value = '';
        }

        const mainContentWrapper = document.getElementById('main-content-wrapper');
        filterScrollPositions[activeFilter] = mainContentWrapper.scrollTop;
        activeFilter = newFilter;

        if (newFilter === '배송중') {
            currentSortOrder = deliveryInProgressSortOrder;
            if (deliveryInProgressSortOrder === 'distance') {
                const itemsWithDistance = deliveryItems.filter(item => item.distanceFromMe !== undefined);
                const itemsWithoutDistance = deliveryItems.filter(item => item.distanceFromMe === undefined);
                itemsWithDistance.sort((a, b) => a.distanceFromMe - b.distanceFromMe);
                deliveryItems = [...itemsWithDistance, ...itemsWithoutDistance];
            } else { 
                deliveryItems.sort((a, b) => a.no - b.no);
            }
        } else if (newFilter === '완료') {
            currentSortOrder = completedSortOrder;
            if (completedSortOrder === 'time') {
                const completedItems = deliveryItems.filter(item => item.status === '완료');
                const otherItems = deliveryItems.filter(item => item.status !== '완료');
                completedItems.sort((a, b) => {
                    if (!a.deliveryCompletionTime) return 1;
                    if (!b.deliveryCompletionTime) return -1;
                    return a.deliveryCompletionTime.localeCompare(b.deliveryCompletionTime);
                });
                deliveryItems = [...completedItems, ...otherItems];
            } else { 
                deliveryItems.sort((a, b) => a.no - b.no);
            }
        } else { 
            currentSortOrder = 'no';
            deliveryItems.sort((a, b) => a.no - b.no);
        }

        filterButtonsContainer.querySelectorAll('button[data-filter]').forEach(btn => {
            const svg = btn.querySelector('svg');
            const isActive = btn.dataset.filter === newFilter;
            
            const baseClasses = 'relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors';
            const activeClasses = 'bg-blue-100 dark:bg-gray-700 text-blue-600 dark:text-gray-100';
            const inactiveClasses = 'bg-transparent text-gray-500 dark:text-gray-400';

            btn.className = `${baseClasses} ${isActive ? activeClasses : inactiveClasses}`;
        });
        
        renderDeliveryCards(newFilter, animationClass);
        updateStickyHeaderPositions();

        const button = filterButtonsContainer.querySelector(`button[data-filter="${newFilter}"]`);
        if (button) button.scrollIntoView({ behavior: 'smooth', inline: 'center' });
        
        setTimeout(() => {
            mainContentWrapper.scrollTo({ top: filterScrollPositions[newFilter] || 0, behavior: 'auto' });
        }, 0);
    };
    
    filterButtonsContainer.addEventListener('click', (event) => {
    const button = event.target.closest('button[data-filter]');
    if (!button) return;
    triggerVibration(); // <-- [추가]
    const newFilter = button.dataset.filter;
        
        const oldIndex = filterCategories.indexOf(activeFilter);
        const newIndex = filterCategories.indexOf(newFilter);
        const animation = newIndex > oldIndex ? 'animate-slide-in-right' : 'animate-slide-in-left';

        changeFilter(newFilter, animation);
    });

    invoiceNumberInput.addEventListener('input', (event) => {
        searchTerm = event.target.value.trim();
        renderDeliveryCards(activeFilter);
        document.getElementById('main-content-wrapper').scrollTo({ top: 0, behavior: 'auto' });
        filterScrollPositions[activeFilter] = 0;
    });

    resetButton.addEventListener('click', () => {
        searchTerm = '';
        invoiceNumberInput.value = '';
        renderDeliveryCards(activeFilter);
    });

    const collapseSearch = () => {
        searchTerm = '';
        invoiceNumberInput.value = '';
    };

    document.addEventListener('click', (event) => {
        const clickedElement = event.target;
        const fabPanel = document.getElementById('fab-panel');
        if (!fabPanel.contains(clickedElement)) {
            document.getElementById('fab-options').classList.remove('expanded');
        }
    });

    deliverySheetImageInput.addEventListener('change', (event) => {
        currentFileToScan = event.target.files;
        selectedFilesDisplay.textContent = currentFileToScan.length > 0 ? `선택된 파일: ${Array.from(currentFileToScan).map(f => f.name).join(', ')}` : '선택된 파일 없음';
    });

    async function performScan(filesToScan) {
        const CONCURRENT_LIMIT = 4;
        const totalFiles = filesToScan.length;
        let completedCount = 0;

        scanProgressModalText.textContent = `이미지 리사이징 중 (0/${totalFiles})...`;
        const resizePromises = filesToScan.map((file, index) => {
            if (isScanCancelled) return Promise.reject(new Error("Scan cancelled"));
            return resizeImage(file).then(resizedObject => {
                if (isScanCancelled) throw new Error("Scan cancelled");
                scanProgressModalText.textContent = `이미지 리사이징 중 (${index + 1}/${totalFiles})...`;
                return resizedObject;
            });
        });

        const resizedImageObjects = await Promise.all(resizePromises);
        if (isScanCancelled) return { cancelled: true };

        scanProgressModalText.textContent = `리사이징 완료, API 요청 시작...`;
        
        const tempMergedResults = new Map();
        const failedFileObjectsForRetry = [];
        const requestQueue = [...resizedImageObjects]; 

        const updateApiProgress = () => {
            completedCount++;
            scanProgressModalText.textContent = `API 처리 중 (${completedCount}/${totalFiles})...`;
        };

        const processApiRequest = async (resizedObject) => {
            const { file, data: base64ImageData } = resizedObject;
            let lastError = null;

            for (let attempt = 1; attempt <= 3; attempt++) {
                if (isScanCancelled) throw new Error("Scan cancelled");
                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: GEMINI_PROMPT }, { inlineData: { mimeType: 'image/jpeg', data: base64ImageData } }] }],
                        generationConfig: { temperature: 0, responseMimeType: "application/json" }
                    };
                    const tempApiKeyForLocalTest = "AIzaSyBWVr60kCgEa9zy5XR7q88vMi8zEH7RQCQ";
                    const directApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${tempApiKeyForLocalTest}`;

                    const response = await fetch(directApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) { throw new Error(`API 요청 실패 (상태: ${response.status})`); }
                    
                    const result = await response.json();

                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        const parsedData = JSON.parse(result.candidates[0].content.parts[0].text);
                        if (Array.isArray(parsedData) && parsedData.length > 0) {
                             return parsedData;
                        }
                    }
                    throw new Error("AI가 유효한 배열 형식으로 응답하지 않았습니다.");
                } catch (error) {
                    if (isScanCancelled) throw error;
                    lastError = error;
                    console.warn(`파일(${file.name}) 처리 시도 ${attempt} 실패:`, error);
                    if (attempt < 3) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
            }
            throw lastError;
        };
        
        const worker = async () => {
            while (requestQueue.length > 0 && !isScanCancelled) {
                const requestObject = requestQueue.shift(); 
                if (requestObject) {
                    try {
                        const apiResultArray = await processApiRequest(requestObject);
                        if (isScanCancelled) return;

                        for (const geminiItem of apiResultArray) {
                            const no = parseInt(geminiItem.no || '0', 10);
                            if (no === 0) continue;
                            
                            if (geminiItem.baseAddressKorean && geminiItem.detailAddressKorean) {
                                geminiItem.detailAddressKorean = geminiItem.detailAddressKorean.replace(/,/g, ' ');
                            }

                            const validationResult = await validateAddressWithKakao(geminiItem.baseAddressKorean, geminiItem.detailAddressKorean);
                            geminiItem.baseAddressKorean = validationResult.baseAddress;
                            geminiItem.detailAddressKorean = validationResult.detailAddress;
                            geminiItem.isAddressValidated = validationResult.validated;

                            tempMergedResults.set(no, geminiItem);
                        }
                    } catch (error) {
                        if (isScanCancelled) return;
                        console.error(`파일 스캔 오류 (${requestObject.file.name}):`, error);
                        failedFileObjectsForRetry.push(requestObject.file);
                    } finally {
                        if (!isScanCancelled) {
                            updateApiProgress();
                        }
                    }
                }
            }
        };

        const workerPromises = Array.from({ length: CONCURRENT_LIMIT }, () => worker());
        await Promise.all(workerPromises);

        if (isScanCancelled) return { cancelled: true };

        let newCount = 0;
        let updateCount = 0;
        const allNewItems = Array.from(tempMergedResults.values()); 

        if (allNewItems.length > 0) {
            const finalItems = allNewItems.map(item => ({
                no: parseInt(item.no, 10),
                hawbNo: item.hawbNo || '',
                baseAddress: item.baseAddressKorean || '',
                detailAddress: item.detailAddressKorean || '',
                
                // ▼▼▼ [수정] 'original_ocr_address'의 소스를 'rawOcrAddress'로 변경 ▼▼▼
                feedback_status: 'UNCONFIRMED', // 'UNCONFIRMED', 'AI_CORRECT', 'USER_CORRECTED'
                original_ocr_address: item.rawOcrAddress || item.receiverAddress || '', // AI가 본 이미지의 원본 텍스트
                ai_base_address: item.baseAddressKorean || '',   // AI가 추출한 기본 주소
                ai_detail_address: item.detailAddressKorean || '', // AI가 추출한 상세 주소
                // ▲▲▲ [수정 끝] ▲▲▲

                companyNameOriginal: item.receiverCompanyName || '',
                receiverNameOriginal: item.receiverName || '',
                companyNameKorean: item.receiverCompanyNameKorean || item.receiverCompanyName || '',
                receiverNameKorean: item.receiverNameKorean || item.receiverName || '',
                receiverNameKoreanOriginal: item.receiverNameKorean || item.receiverName || '',
                receiverTelephoneNo: item.receiverPhone ? getCleanPhoneNumber(item.receiverPhone) : '',
                status: '배송전', isHawbConfirmed: false,
                deliveryCompletionTime: null, completionType: null, completionDetail: null,
                addressLocation: null,
                isStruckThrough: false,
                isAddressValidated: item.isAddressValidated
            }));
            
            finalItems.forEach(newItem => {
                const existingItemIndex = deliveryItems.findIndex(item => item.no === newItem.no);
                if (existingItemIndex > -1) {
                    deliveryItems[existingItemIndex] = { ...deliveryItems[existingItemIndex], ...newItem };
                    updateCount++;
                } else {
                    deliveryItems.push(newItem);
                    newCount++;
                }
            });
            deliveryItems.sort((a, b) => a.no - b.no);
            saveDeliveryItemsToLocalStorage();
        }
        return { newCount, updateCount, failedFiles: failedFileObjectsForRetry };
    }
    
    scanAndGenerateButton.addEventListener('click', async () => {
        if (!currentFileToScan || currentFileToScan.length === 0) { showMessage('스캔할 이미지를 선택해주세요.'); return; }
        
        isScanCancelled = false;
        scanProgressModal.style.display = 'flex';
        document.body.classList.add('modal-open');

        const startTime = Date.now();
        failedFileObjects = []; 

        try {
            const initialFiles = Array.from(currentFileToScan);
            const result = await performScan(initialFiles);

            if (result.cancelled) {
                showToastMessage("스캔이 중단되었습니다.");
                return;
            }

            const endTime = Date.now();
            const elapsedTime = Math.round((endTime - startTime) / 1000);
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;
            const timeString = `(소요 시간: ${minutes}분 ${seconds}초)`;

            if (result.failedFiles.length === 0) {
                showMessage(`${result.updateCount}개의 카드가 업데이트되고 ${result.newCount}개의 카드가 새로 생성되었습니다. ${timeString}`);
            } else {
                failedFileObjects = result.failedFiles;
                const successCount = initialFiles.length - failedFileObjects.length;
                const failedFileNames = failedFileObjects.map(f => f.name);
                
                const message = `총 ${initialFiles.length}개 중 ${successCount}개 파일 스캔 성공. ${timeString}\n\n실패한 ${failedFileObjects.length}개 파일을 다시 스캔하시겠습니까?\n- ${failedFileNames.join('\n- ')}`;

                const onRetry = async () => {
                    isScanCancelled = false;
                    scanProgressModal.style.display = 'flex';
                    document.body.classList.add('modal-open');
                    
                    const retryResult = await performScan(failedFileObjects);
                    
                    scanProgressModal.style.display = 'none';
                    document.body.classList.remove('modal-open');

                    if (retryResult.cancelled) {
                        showToastMessage("재시도가 중단되었습니다.");
                        return;
                    }

                    if (retryResult.failedFiles.length === 0) {
                        showMessage(`재시도 성공: ${retryResult.updateCount + retryResult.newCount}개의 카드가 추가/업데이트되었습니다.`);
                    } else {
                        const stillFailingNames = retryResult.failedFiles.map(f => f.name);
                        showMessage(`재시도 후에도 아래 ${stillFailingNames.length}개 파일이 실패했습니다.\n- ${stillFailingNames.join('\n- ')}`, '재시도 일부 실패');
                    }
                    renderDeliveryCards(activeFilter);
                    updateFilterCounts();
                };
                openConfirmationModal(message, onRetry, '실패 파일 재시도', '나중에');
            }
        } catch (error) {
            if (error.message !== "Scan cancelled") {
                console.error("전체 스캔 프로세스 오류:", error);
                showMessage(`스캔 중 오류가 발생했습니다: ${error.message}`, "오류");
            } else {
                showToastMessage("스캔이 중단되었습니다.");
            }
        } finally {
            scanProgressModal.style.display = 'none';
            document.body.classList.remove('modal-open');
            deliverySheetImageInput.value = '';
            currentFileToScan = null;
            selectedFilesDisplay.textContent = '선택된 파일 없음';
            renderDeliveryCards(activeFilter);
            updateFilterCounts();
            updateStickyHeaderPositions();
        }
    });
    
    exportDataButton.addEventListener('click', () => {
        if (deliveryItems.length === 0) { showMessage("저장할 데이터가 없습니다."); return; }
        try {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            
            const formattedDateTime = `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
            const fileName = `SF-${formattedDateTime}.json`;

            const dataStr = JSON.stringify(deliveryItems, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToastMessage(`데이터가 '${fileName}' 파일로 저장되었습니다.`);
        } catch (error) {
            showMessage(`데이터 저장 중 오류가 발생했습니다: ${error.message}`, "오류");
        }
    });

    importDataInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        openConfirmationModal( `'${file.name}' 파일의 데이터로 현재 목록을 모두 덮어씁니다. 계속하시겠습니까?`, () => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (!Array.isArray(importedData)) throw new Error("파일 형식이 올바르지 않습니다 (배열이 아님).");
                        
                        const firstItem = importedData[0];
                        if (importedData.length > 0 && typeof firstItem.no === 'undefined' && typeof firstItem.baseAddress === 'undefined') {
                           throw new Error("파일 내용이 올바른 배송 데이터 형식이 아닙니다.");
                        }
                        
                        deliveryItems = importedData;

                        saveDeliveryItemsToLocalStorage();
                        updateFilterCounts();
                        updateStickyHeaderPositions();
                        renderDeliveryCards(activeFilter);
                        showMessage(`'${file.name}' 파일에서 ${deliveryItems.length}개의 항목을 불러왔습니다.`);
                    } catch (error) {
                        showMessage(`파일을 불러오는 중 오류가 발생했습니다: ${error.message}`, "오류");
                    } finally {
                        importDataInput.value = '';
                    }
                };
                reader.onerror = () => { showMessage("파일을 읽는 데 실패했습니다.", "오류"); importDataInput.value = ''; };
                reader.readAsText(file);
            }
        );
    });

        document.addEventListener('DOMContentLoaded', () => {
            // ▼▼▼ [추가] 저장된 정렬 순서 불러오기 ▼▼▼
            deliveryInProgressSortOrder = localStorage.getItem('deliveryInProgressSortOrder') || 'no';
            completedSortOrder = localStorage.getItem('completedSortOrder') || 'no';
            // ▲▲▲ [추가 끝] ▲▲▲

            // ▼▼▼ [추가 시작] 웹훅 URL 저장 및 불러오기 로직 ▼▼▼
            const webhookUrlInput = document.getElementById('webhook-url-input');
            const saveWebhookUrlButton = document.getElementById('save-webhook-url-button');

            // 페이지 로드 시 저장된 URL 불러오기
            const savedWebhookUrl = localStorage.getItem('webhookUrl');
            if (savedWebhookUrl) {
                webhookUrlInput.value = savedWebhookUrl;
            }

            // 저장 버튼 클릭 이벤트
            saveWebhookUrlButton.addEventListener('click', () => {
                const urlToSave = webhookUrlInput.value.trim();
                if (urlToSave) {
                    localStorage.setItem('webhookUrl', urlToSave);
                    showToastMessage('웹훅 URL이 저장되었습니다.');
                } else {
                    localStorage.removeItem('webhookUrl');
                    showToastMessage('웹훅 URL이 삭제되었습니다.');
                }
            });
            // ▲▲▲ [추가 끝] ▲▲▲

            initializeTheme(); // <-- 테마 초기화 함수 호출

            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./service-worker.js').then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    }).catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
                });
            }
            
            if ('Notification' in window && Notification.permission === 'default') {
                setTimeout(() => { Notification.requestPermission(); }, 3000);
            }

            resizeAppContainer();
            window.addEventListener('resize', resizeAppContainer);
            setVersionInfo();
            setupDelegatedEventListeners();

            const mapSelectionContainer = document.getElementById('map-selection-container');
            const mapSelectButtons = mapSelectionContainer.querySelectorAll('.map-select-btn');

            const updateMapSelectionUI = () => {
                const selectedMap = localStorage.getItem('selectedMap') || 'naver';
                mapSelectButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.map === selectedMap);
                });
                if (['전체', '배송전', '배송중', '완료'].includes(activeFilter)) {
                    renderDeliveryCards(activeFilter);
                }
            };

            mapSelectionContainer.addEventListener('click', (event) => {
                const selectedButton = event.target.closest('.map-select-btn');
                if (selectedButton) {
                    const mapType = selectedButton.dataset.map;
                    localStorage.setItem('selectedMap', mapType);
                    updateMapSelectionUI();
                }
            });
            updateMapSelectionUI();

            // ▼▼▼ [수정] 새로운 테마 UI를 위한 이벤트 리스너 설정 ▼▼▼
    const lightBtn = document.getElementById('light-theme-btn');
    const darkBtn = document.getElementById('dark-theme-btn');
    const systemThemeToggle = document.getElementById('system-theme-toggle');

    if (lightBtn) {
        lightBtn.addEventListener('click', () => applyTheme('light'));
    }
    if (darkBtn) {
        darkBtn.addEventListener('click', () => applyTheme('dark'));
    }
    if (systemThemeToggle) {
        systemThemeToggle.addEventListener('change', (event) => {
            if (event.target.checked) {
                applyTheme('system');
            } else {
                // 시스템 모드를 끌 때, 현재 보이는 테마를 수동 선택한 것으로 간주
                const currentEffectiveTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
                applyTheme(currentEffectiveTheme);
            }
        });
    }
    // ▲▲▲ [수정 끝] ▲▲▲

            // ▼▼▼ [수정] 바코드 스캐너 실행 로직을 함수로 분리하여 재사용 ▼▼▼
            const openBarcodeScanner = () => {
                const returnUrlFormat = `https://shoo2668.github.io/sf/?hawb={CODE}&filter=전체`;
                const encodedReturnUrl = encodeURIComponent(returnUrlFormat);
                const scannerUrl = `zxing://scan/?ret=${encodedReturnUrl}`;
                showToastMessage('스캐너 앱을 실행합니다...', 1000);
                window.location.href = scannerUrl;
            };

            const barcodeScanButton = document.getElementById('barcode-scan-button');
            if (barcodeScanButton) {
                barcodeScanButton.addEventListener('click', openBarcodeScanner);
            }

            const searchScanButton = document.getElementById('search-scan-button');
            if (searchScanButton) {
                searchScanButton.addEventListener('click', openBarcodeScanner);
            }
            // ▲▲▲ [수정 끝] ▲▲▲

            clearAllCardsButton.addEventListener('click', () => {
                openConfirmationModal("모든 카드를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.", () => {
                    deliveryItems = [];
                    saveDeliveryItemsToLocalStorage();
                    renderDeliveryCards(activeFilter);
                    updateFilterCounts();
                    showToastMessage("모든 카드가 삭제되었습니다.");
                });
            });

            scanProgressCancelBtn.addEventListener('click', () => {
                isScanCancelled = true;
                scanProgressModal.style.display = 'none';
                document.body.classList.remove('modal-open');
            });

            // ▼▼▼ [수정 시작] 배송 위치 모달 버튼 이벤트 위임 처리 ▼▼▼
            deliveryLocationModal.addEventListener('click', (event) => {
                const button = event.target.closest('button');
                if (!button) return;

                const buttonId = button.id;

                if (buttonId === 'location-modal-cancel') {
                    closeDeliveryLocationModal();
                    return;
                }

                if (buttonId === 'location-modal-confirm-no-sms' || buttonId === 'location-modal-confirm-with-sms') {
                    const selectedOption = document.querySelector('input[name="delivery-location"]:checked');
                    if (!selectedOption) {
                        showMessage('배송 위치를 선택해주세요.');
                        return;
                    }

                    let location = selectedOption.value;
                    if (location === '기타') {
                        const otherInput = document.getElementById('other-location-input');
                        location = otherInput.value.trim();
                        if (!location) {
                            showMessage('기타 배송 위치를 입력해주세요.');
                            return;
                        }
                    }

                    const itemNo = currentLocationEditItemNo;
                    const currentItem = deliveryItems.find(i => i.no === itemNo);
                    if (!currentItem) return;

                    const isNewCompletion = currentItem.status !== '완료';

                    if (isNewCompletion) {
                        copyHawbOnComplete(itemNo);
                    }

                    const completionTime = isNewCompletion ? new Date().toLocaleString('ko-KR', dateTimeFormatOptions) : currentItem.deliveryCompletionTime;
                    handleStatusChange(itemNo, '완료', completionTime, location, location);

                    sortItemsByDistanceSilent();
                    showToastMessage(`${itemNo}번: ${location} 완료`);

                    if (isNewCompletion) {
                        const updatedItem = deliveryItems.find(i => i.no === itemNo);
                        if (updatedItem) {
                            sendCompletionNotification(updatedItem);
                            
                            // ▼▼▼ [추가] 웹훅 전송 (문자보내기 버튼 제외) ▼▼▼
                            if (buttonId !== 'location-modal-confirm-with-sms') {
                                sendWebhook(updatedItem);
                            }
                        }

                        // '문자 보내기' 버튼을 눌렀을 때만 SMS 실행
                        if (buttonId === 'location-modal-confirm-with-sms') {
                            const cleanPhoneNumber = getCleanPhoneNumber(currentItem.receiverTelephoneNo);
                            if (cleanPhoneNumber && cleanPhoneNumber.startsWith('010')) {
                                setTimeout(() => {
                                    const messageBody = `SF택배 퀵배송 왔습니다. (${location})`;
                                    window.location.href = `sms:${cleanPhoneNumber}?body=${encodeURIComponent(messageBody)}`;
                                }, 500);
                            }
                        }
                    }
                    
                    closeDeliveryLocationModal();
                }
            });
            // ▲▲▲ [수정 끝] ▲▲▲

            invoiceNumberInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') { event.preventDefault(); invoiceNumberInput.blur(); }
            });

            setTimeout(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const hawbFromUrl = urlParams.get('hawb');
                const filterFromUrl = urlParams.get('filter');

                if (hawbFromUrl) {
                    changeFilter('전체', '', true);
                    searchTerm = hawbFromUrl;
                    invoiceNumberInput.value = hawbFromUrl;
                    renderDeliveryCards('전체');
                } else {
                    if (filterFromUrl && filterCategories.includes(filterFromUrl)) {
                        changeFilter(filterFromUrl, '', true);
                    } else {
                        changeFilter('배송준비', '', true);
                    }
                }
            }, 0);

            const mainContent = document.getElementById('main-content-wrapper');
            refreshIndicator = document.getElementById('refresh-indicator');

            mainContent.addEventListener('touchstart', (e) => {
                if (mainContent.scrollTop === 0 && !isRefreshing && activeFilter === '배송중' && deliveryInProgressSortOrder === 'distance') {
                    pullStartY = e.touches[0].pageY;
                } else {
                    pullStartY = 0;
                }
            }, { passive: true });

            mainContent.addEventListener('touchmove', (e) => {
                if (pullStartY === 0 || isRefreshing) return;
                const pullDistance = e.touches[0].pageY - pullStartY;
                if (pullDistance > 0) {
                    const opacity = Math.min(pullDistance / 100, 1);
                    refreshIndicator.style.opacity = opacity;
                    refreshIndicator.style.transform = `translateY(${Math.min(pullDistance, 100) - 48}px)`;
                }
            }, { passive: true });

            mainContent.addEventListener('touchend', (e) => {
                if (pullStartY === 0 || isRefreshing) return;
                const pullDistance = e.changedTouches[0].pageY - pullStartY;
                
                const resetIndicator = () => {
                    refreshIndicator.classList.remove('visible');
                    refreshIndicator.style.opacity = 0;
                    refreshIndicator.style.transform = 'translateY(-100%)';
                };

                if (pullDistance > 100 && activeFilter === '배송중' && deliveryInProgressSortOrder === 'distance') {
                    isRefreshing = true;
                    refreshIndicator.classList.add('visible');
                    // ▼▼▼ [수정] sortItemsByDistance(true) 호출 추가 ▼▼▼
                    sortItemsByDistance(true).finally(() => {
                        isRefreshing = false;
                        pullStartY = 0;
                        resetIndicator();
                    });
                } else {
                    resetIndicator();
                }
            });

            let pullDownStartY = 0;
            document.body.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) pullDownStartY = e.touches[0].clientY;
            }, { passive: true });

            window.addEventListener('touchmove', (event) => {
                const touchY = event.touches[0].clientY;
                const isPullingDown = touchY > pullDownStartY;
                if (!isPullingDown) return;

                const mainContent = document.getElementById('main-content-wrapper');
                const smartEditScroll = document.getElementById('smart-edit-scroll-area');
                const numberJumpList = document.getElementById('number-jump-list');

                let scrollableElement = null;
                if (mainContent && mainContent.contains(event.target)) scrollableElement = mainContent;
                else if (smartEditScroll && smartEditScroll.contains(event.target)) scrollableElement = smartEditScroll;
                else if (numberJumpList && numberJumpList.contains(event.target)) scrollableElement = numberJumpList;

                // ▼▼▼ [수정] 이벤트가 취소 가능한 경우에만 preventDefault()를 호출하도록 변경 ▼▼▼
                if ((scrollableElement && scrollableElement.scrollTop === 0) || !scrollableElement) {
                    if (event.cancelable) {
                        event.preventDefault();
                    }
                }
            }, { passive: false });

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    justReturnedFromExternalApp = true;
                    setTimeout(() => { justReturnedFromExternalApp = false; }, 500);
                }
            });

            history.pushState(null, '', location.href);
            window.addEventListener('popstate', (event) => {
                if (smartEditModal.style.display === 'flex') {
                    const modalContent = smartEditModal.querySelector('.smart-edit-modal-content');
                    document.body.classList.remove('modal-open');
                    smartEditModal.style.display = 'none';
                    modalContent.style.maxHeight = ''; // 고정했던 높이 제거
                    currentEditItemNo = null;
                    return;
                }
                if (justReturnedFromExternalApp) {
                    justReturnedFromExternalApp = false;
                    history.pushState(null, '', location.href);
                    return;
                }
                if (backButtonPressedOnce) {
                    history.back(); 
                    return;
                }
                backButtonPressedOnce = true;
                showToastMessage('한 번 더 누르면 종료됩니다.', 2000);
                setTimeout(() => { backButtonPressedOnce = false; }, 2000);
                history.pushState(null, '', location.href);
            });

            document.body.addEventListener('touchstart', (event) => {
                const touch = event.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartTime = Date.now();
            }, { passive: true });

            let isSwiping = false;
            document.body.addEventListener('touchmove', () => {
                if (!isSwiping) {
                    filterButtonsContainer.querySelectorAll('button').forEach(btn => btn.style.pointerEvents = 'none');
                }
                isSwiping = true;
            }, { passive: true });

            document.body.addEventListener('touchend', (event) => {
                if (isSwiping) {
                    setTimeout(() => {
                        filterButtonsContainer.querySelectorAll('button').forEach(btn => btn.style.pointerEvents = 'auto');
                        isSwiping = false;
                    }, 100);
                }
                if (signatureModal.style.display === 'flex' || confirmationModal.style.display === 'flex' || smartEditModal.style.display === 'flex' || numberJumpModal.style.display === 'flex') {
                    return;
                }
                const touch = event.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                const duration = Date.now() - touchStartTime;
                if (duration > 500 || Math.abs(diffX) < 75 || Math.abs(diffX) < Math.abs(diffY) * 2) {
                    return;
                }
                const currentFilterIndex = filterCategories.indexOf(activeFilter);
                if (diffX > 0) {
                    if (currentFilterIndex > 0) {
                        const prevFilter = filterCategories[currentFilterIndex - 1];
                        changeFilter(prevFilter, 'animate-slide-in-left');
                    }
                } else {
                    if (currentFilterIndex < filterCategories.length - 1) {
                        const nextFilter = filterCategories[currentFilterIndex + 1];
                        changeFilter(nextFilter, 'animate-slide-in-right');
                    }
                }
            });

            actionBarContainer.addEventListener('click', async (event) => {
    const button = event.target.closest('button');
    if (!button) return;
    triggerVibration(); // <-- [추가]
    const action = button.dataset.action;
                if (!action) return;
                const fabOptions = document.getElementById('fab-options');
                if (action === 'toggle-fab') {
                    fabOptions.classList.toggle('expanded');
                    return;
                }
                if (button.parentNode.id === 'fab-options') {
                    fabOptions.classList.remove('expanded');
                    if (action === 'sort-distance') {
                        deliveryInProgressSortOrder = 'distance';
                        localStorage.setItem('deliveryInProgressSortOrder', 'distance'); // <-- [추가]
                    } else if (action === 'sort-no') {
                        deliveryInProgressSortOrder = 'no';
                        localStorage.setItem('deliveryInProgressSortOrder', 'no'); // <-- [추가]
                    } else if (action === 'sort-time') {
                        completedSortOrder = 'time';
                        localStorage.setItem('completedSortOrder', 'time'); // <-- [추가]
                    } else if (action === 'sort-no-completed') {
                        completedSortOrder = 'no';
                        localStorage.setItem('completedSortOrder', 'no'); // <-- [추가]
                    }
                }
                switch (action) {
                    // ▼▼▼ [이 부분 추가] ▼▼▼
                    case 'copy-all-completed':
                        {
                            // 1. 전체 deliveryItems에서 status가 '완료'인 항목만 필터링합니다.
                            const completedItems = deliveryItems.filter(item => item.status === '완료');

                            if (completedItems.length === 0) {
                                showToastMessage('복사할 완료 항목이 없습니다.');
                                break;
                            }

                            // 2. 순번(no)을 기준으로 오름차순 정렬하여 순서대로 복사되도록 합니다.
                            completedItems.sort((a, b) => a.no - b.no);

                            // 3. 각 항목을 "순번 - 내용 [시간]" 형식의 문자열로 변환합니다.
                            const textLines = completedItems.map(item => {
                                // 개별 항목 복사 로직과 동일하게 완료 내용을 결정합니다.
                                const completionText = item.completionType === '본인전달'
                                    ? (item.receiverNameKorean || '')
                                    : (item.completionDetail || item.completionType || '');
                                // 완료 시간을 HH:MM 형식으로 포맷팅합니다.
                                const timeText = formatCompletionTime(item.deliveryCompletionTime);
                                return `${item.no} - ${completionText} [${timeText}]`;
                            });

                            // 4. 변환된 문자열 배열을 줄바꿈(\n)으로 합쳐 최종 텍스트를 만듭니다.
                            const textToCopy = textLines.join('\n');

                            // 5. 클립보드에 복사하고 사용자에게 알림을 표시합니다.
                            navigator.clipboard.writeText(textToCopy).then(() => {
                                showToastMessage(`완료된 항목 ${completedItems.length}개 복사 완료`);
                            }).catch(err => {
                                console.error('전체 완료 항목 복사 실패:', err);
                                showMessage('클립보드 복사에 실패했습니다.');
                            });
                        }
                        break;
                    // ▲▲▲ [추가 끝] ▲▲▲
                    case 'sort-distance': sortItemsByDistance(); break;
                    case 'sort-no': sortItemsByNumber(); showToastMessage('순번순으로 정렬되었습니다.'); break;
                    case 'sort-no-completed':
                        completedSortOrder = 'no';
                        currentSortOrder = 'no';
                        deliveryItems.sort((a, b) => a.no - b.no);
                        renderDeliveryCards(activeFilter);
                        showToastMessage('순번순으로 정렬되었습니다.');
                        break;
                    case 'jump-no':
                        numberJumpList.innerHTML = '';
                        if (deliveryItems.length === 0) {
                            numberJumpList.innerHTML = '<p class="text-gray-500 dark:text-gray-400 col-span-5 text-center">카드가 없습니다.</p>';
                        } else {
                            const maxNo = Math.max(0, ...deliveryItems.map(item => item.no));
                            const itemsMap = new Map(deliveryItems.map(item => [item.no, item.status]));
                            for (let i = 1; i <= maxNo; i++) {
                                const status = itemsMap.get(i);
                                const btn = document.createElement('div');
                                btn.textContent = i;
                                if (status === '배송중') {
                                    btn.className = 'number-jump-item active';
                                    btn.dataset.no = i;
                                    btn.onclick = () => {
                                        const targetCard = document.querySelector(`[data-no="${i}"]`);
                                        if (targetCard) targetCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                        numberJumpModal.style.display = 'none';
                                    };
                                } else if (status) {
                                    btn.className = 'number-jump-item inactive';
                                } else {
                                    btn.className = 'number-jump-item placeholder';
                                    btn.innerHTML = ' ';
                                }
                                numberJumpList.appendChild(btn);
                            }
                        }
                        numberJumpModal.style.display = 'flex';
                        break;
                    case 'sort-time':
                        completedSortOrder = 'time';
                        currentSortOrder = 'time';
                        const completedItems = deliveryItems.filter(item => item.status === '완료');
                        const otherItems = deliveryItems.filter(item => item.status !== '완료');
                        completedItems.sort((a, b) => {
                            if (!a.deliveryCompletionTime) return 1;
                            if (!b.deliveryCompletionTime) return -1;
                            return a.deliveryCompletionTime.localeCompare(b.deliveryCompletionTime);
                        });
                        deliveryItems = [...completedItems, ...otherItems];
                        renderDeliveryCards(activeFilter);
                        showToastMessage('빠른 완료시간순으로 정렬되었습니다.');
                        break;
                }
                if (button.parentNode.id === 'fab-options') {
                    setTimeout(setupFab, 50);
                }
            });

            numberJumpClose.addEventListener('click', () => numberJumpModal.style.display = 'none');
            numberJumpModal.addEventListener('click', (event) => { if (event.target === numberJumpModal) numberJumpModal.style.display = 'none'; });
            smartEditExitBtn.addEventListener('click', closeSmartEditModal);
            smartEditModal.addEventListener('click', (event) => { if (event.target === smartEditModal) closeSmartEditModal(); });
            cancelSignatureBtn.addEventListener('click', closeSignatureModal);
            signatureModal.addEventListener('click', (event) => { if (event.target === signatureModal) closeSignatureModal(); });

            // ▼▼▼ [추가 시작] 수동 카드 추가 모달 이벤트 리스너 ▼▼▼
            manualAddCardButton.addEventListener('click', openManualAddModal);
            manualAddCancelBtn.addEventListener('click', closeManualAddModal);
            manualAddCreateBtn.addEventListener('click', handleCreateManualCard);
            manualAddCardModal.addEventListener('click', (event) => {
                if (event.target === manualAddCardModal) closeManualAddModal();
            });
            // ▲▲▲ [추가 끝] ▲▲▲

            const storedItems = localStorage.getItem('deliveryItems');
            if (storedItems) {
                let parsedItems = JSON.parse(storedItems);
                deliveryItems = parsedItems.map(item => {
                    if (typeof item.addressLocation === 'undefined') item.addressLocation = null;
                    if (typeof item.isStruckThrough === 'undefined') item.isStruckThrough = false;
                    if (typeof item.isAddressValidated === 'undefined') item.isAddressValidated = true;
                    return item;
                }).sort((a, b) => a.no - b.no);
            }
            const storedScroll = localStorage.getItem('filterScrollPositions');
            if (storedScroll) filterScrollPositions = JSON.parse(storedScroll);
            updateFilterCounts();
            
            const urlParamsForCheck = new URLSearchParams(window.location.search);
            if (!urlParamsForCheck.has('hawb') && !urlParamsForCheck.has('filter')) {
                const lastFilter = localStorage.getItem('lastActiveFilter') || '배송준비';
                changeFilter(lastFilter, '', true);
            }

            const handleUrlParams = (url) => {
                const urlParams = new URLSearchParams(url.search);
                const hawbFromUrl = urlParams.get('hawb');
                if (hawbFromUrl) {
                    changeFilter('전체', '', true);
                    searchTerm = hawbFromUrl;
                    invoiceNumberInput.value = hawbFromUrl;
                    renderDeliveryCards('전체');
                    const cleanUrl = `${window.location.origin}${window.location.pathname}`;
                    window.history.replaceState({}, '', cleanUrl);
                }
            };

            if ('launchQueue' in window) {
                window.launchQueue.setConsumer(launchParams => {
                    if (launchParams.targetURL) {
                        const url = new URL(launchParams.targetURL);
                        handleUrlParams(url);
                    }
                });
            } else {
                const url = new URL(window.location.href);
                handleUrlParams(url);
            }
        });
    </script>
</body>
</html>