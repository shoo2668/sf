<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>배송 시트</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="manifest" href="manifest.json">
    <!-- ▼▼▼ [수정] theme-color에 id를 추가하여 JS로 제어할 수 있도록 함 ▼▼▼ -->
    <meta name="theme-color" content="#ffffff" id="theme-color-meta">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- ▼▼▼ [추가] Tailwind CSS CDN 버전을 위한 다크모드 설정 ▼▼▼ -->
    <script>
        tailwind.config = {
            darkMode: 'class', // 'class' 전략을 사용하여 <html> 태그에 'dark' 클래스가 있을 때 다크모드를 활성화합니다.
            theme: {
                extend: {
                    // 필요하다면 여기에 커스텀 테마를 추가할 수 있습니다.
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ▼▼▼ [추가] 설정 섹션을 카드 형태로 만들기 위한 스타일 ▼▼▼ */
        .setting-section {
            background-color: var(--page-bg);
            padding: 1rem; /* 16px */
            border-radius: 0.5rem; /* 8px */
            box-shadow: var(--card-shadow);
        }
        .setting-section-title {
            font-size: 1rem; /* 16px */
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem; /* 12px */
        }
        /* ▲▲▲ [추가 끝] ▲▲▲ */
        /* ▼▼▼ [추가] 새로운 테마 스위치 UI를 위한 스타일 ▼▼▼ */
#theme-switch-container.disabled {
    opacity: 0.5;
    pointer-events: none;
}
/* ▲▲▲ [추가 끝] ▲▲▲ */
        /* ▼▼▼ [수정] CSS 변수 정의 (라이트/다크 모드) ▼▼▼ */
        :root {
            --page-bg: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --modal-bg: #ffffff;
            --active-btn-bg: #ffffff;
            --active-btn-shadow: 0 1px 3px rgba(0,0,0,0.1);
            --search-bar-border: #2563eb;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }

        html.dark {
            color-scheme: dark;
            --page-bg: #111827; /* gray-900 */
            --text-primary: #f9fafb; /* gray-50 */
            --text-secondary: #9ca3af; /* gray-400 */
            --modal-bg: #1f2937; /* gray-800 */
            --active-btn-bg: #374151; /* gray-700 */
            --active-btn-shadow: 0 1px 3px rgba(0,0,0,0.3);
            --search-bar-border: #3b82f6; /* blue-500 */
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -2px rgba(0, 0, 0, 0.2);
        }
        /* ▲▲▲ [수정 끝] ▲▲▲ */

        .map-select-btn {
            color: var(--text-secondary);
        }
        .map-select-btn.active {
            background-color: var(--active-btn-bg);
            color: var(--text-primary);
            box-shadow: var(--active-btn-shadow);
        }
        .map-icon-button {
            width: 28px;
            height: 28px;
            flex-shrink: 0;
        }
        .map-icon-button.naver {
            background-color: #2DB400;
        }
        .map-icon-button.naver svg {
            stroke: white;
        }
        .map-icon-button.kakao {
            background-color: #FEE500;
        }
        .map-icon-button.kakao svg {
            stroke: #0085FF;
        }

        #refresh-indicator {
            transform: translateY(-100%);
            transition: transform 0.3s, opacity 0.3s;
            z-index: 10;
        }
        #refresh-indicator.visible {
            opacity: 1;
            transform: translateY(1rem);
        }
        html {
            scroll-behavior: smooth !important;
            height: 100%;
            overflow: auto; 
        }
        body {
            /* ▼▼▼ [추가] CSS 변수를 사용하여 body의 기본 배경/텍스트 색상 설정 ▼▼▼ */
            background-color: var(--page-bg);
            color: var(--text-primary);
            /* ▲▲▲ [추가 끝] ▲▲▲ */
            font-family: 'Inter', sans-serif;
            margin: 0;
            height: 100%;
            overflow-y: auto;
            overscroll-behavior: contain;
        }

        body.modal-open {
            overflow: hidden;
        }

        .signature-modal, .confirmation-modal, .smart-edit-modal, .number-jump-modal {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 50;
        }

        .confirmation-modal { z-index: 51; }

        /* ▼▼▼ [수정] 모달 배경색에 CSS 변수 적용 ▼▼▼ */
        .signature-modal-content, .confirmation-modal-content, .smart-edit-modal-content, .number-jump-modal-content {
            background-color: var(--modal-bg);
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            padding: 1.5rem;
            width: 100%;
            max-width: 28rem;
            max-height: calc(100vh - 3rem);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #smart-edit-scroll-area, #number-jump-list {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        #smart-edit-scroll-area, #number-jump-list {
            flex: 1 1 auto;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .key-button { position: relative; overflow: visible !important; -webkit-tap-highlight-color: transparent; }
        .key-pop {
            position: absolute;
            bottom: 80%;
            left: 50%;
            transform: translateX(-50%) scale(0.8);
            transform-origin: bottom center;
            background-color: #374151;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 1.25rem;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 10;
            min-width: 100%;
            text-align: center;
            white-space: nowrap;
        }
        .key-button:active .key-pop {
            opacity: 1;
            transform: translateX(-50%) scale(1) translateY(-8px);
        }
        .filter-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            border-radius: 9999px;
            background-color: #2563eb;
            color: white;
            font-size: 12px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            /* ▼▼▼ [수정] 기본 테두리 색상을 CSS 변수로 변경 ▼▼▼ */
            border: 2px solid var(--page-bg);
            transition: transform 0.2s, opacity 0.2s;
            transform: scale(1);
            opacity: 1;
        }
        /* ▼▼▼ [삭제] 기존 다크모드 테두리 색상 지정 코드는 더 이상 필요 없음 ▼▼▼
        html.dark .filter-badge {
            border-color: #1f2937; 
        }
        */
        .filter-badge.hidden {
            transform: scale(0.5);
            opacity: 0;
            pointer-events: none;
        }
        #address-pieces-container button { margin: 0.25rem; padding: 0.25rem 0.75rem; border-radius: 9999px; font-size: 0.875rem; font-weight: 500; transition: background-color 0.2s; }

        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #2563eb; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        html.dark .spinner { border-left-color: #60a5fa; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .animate-slide-in-left { animation: slideInLeft 0.3s ease-out forwards; }
        @keyframes slideInLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .animate-slide-in-right { animation: slideInRight 0.3s ease-out forwards; }
        @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        #delivery-cards-container { transition: transform 0.1s ease-out; will-change: transform; }
        #toast-container { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; flex-direction: column; align-items: center; gap: 8px; pointer-events: none; }
        .toast-message { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 10px 20px; border-radius: 20px; font-size: 0.875rem; box-shadow: 0 2px 10px rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.5s, transform 0.5s; transform: translateY(20px); }
        html.dark .toast-message { background-color: rgba(240, 240, 240, 0.9); color: #111827; }
        .toast-message.show { opacity: 1; transform: translateY(0); }
        #number-jump-list { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem; overflow-y: auto; padding: 0.5rem; margin: -0.5rem; max-height: 60vh; }
        .number-jump-item { min-width: 50px; padding: 0.75rem; border-radius: 0.5rem; font-weight: 600; text-align: center; transition: background-color 0.2s, color 0.2s; }
        .number-jump-item.active { background-color: #2563eb; color: white; cursor: pointer; }
        .number-jump-item.active:hover { background-color: #1d4ed8; }
        .number-jump-item.inactive { background-color: #f3f4f6; color: #9ca3af; cursor: not-allowed; }
        html.dark .number-jump-item.inactive { background-color: #374151; color: #6b7280; }
        .number-jump-item.placeholder { background-color: transparent; }
        .bottom-bar { position: fixed; bottom: 0; left: 0; width: 100vw; z-index: 46; transition: transform 0.3s ease-out; background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border-top: 1px solid #e5e7eb; }
        html.dark .bottom-bar { background-color: rgba(31, 41, 55, 0.8); border-top-color: #4b5563; }
        .bottom-bar.hidden { transform: translateY(100%); }
        .completed-strikethrough {
            text-decoration: line-through;
            color: #6b7280; /* gray-500 */
        }
        html.dark .completed-strikethrough { color: #9ca3af; }
        #fab-options button {
            width: 0;
            padding: 0;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s ease-in-out;
        }
        #fab-options.expanded button {
            width: 3rem;
            padding: 0.75rem;
            opacity: 1;
            transform: scale(1);
        }
        /* ▼▼▼ [수정] 검색창 그림자 및 테두리에 CSS 변수 적용 ▼▼▼ */
        #search-bar {
            box-shadow: var(--card-shadow);
            border: 2px solid var(--search-bar-border);
            z-index: 45;
        }
    </style>
</head>
<!-- ▼▼▼ [수정] CSS 변수로 색상을 제어하므로, 직접적인 색상 클래스 제거 ▼▼▼ -->
<body class="font-sans">
    <div id="app-container" class="h-screen flex flex-col">

        <!-- ▼▼▼ [수정] 상단 필터 컨테이너에 다크모드 클래스 추가 ▼▼▼ -->
        <div id="filter-buttons-container" class="z-20 flex-shrink-0 bg-white dark:bg-gray-800 shadow-md border-b border-gray-200 dark:border-gray-700">
            <div class="max-w-md mx-auto w-full min-w-[320px] p-2">
                <div class="flex justify-around">
                    <!-- 버튼들은 JS에서 동적으로 클래스가 제어됩니다 -->
                    <button data-filter="배송준비" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8"/><path d="M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg>
                    </button>
                    <button data-filter="전체" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M3 5h.01"/><path d="M3 12h.01"/><path d="M3 19h.01"/><path d="M8 5h13"/><path d="M8 12h13"/><path d="M8 19h13"/></svg>
                        <span id="count-전체" class="filter-badge">0</span>
                    </button>
                    <button data-filter="배송전" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z"/><path d="M12 22V12"/><polyline points="3.29 7 12 12 20.71 7"/><path d="m7.5 4.27 9 5.15"/></svg>
                        <span id="count-배송전" class="filter-badge">0</span>
                    </button>
                    <button data-filter="배송중" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M14 18V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v11a1 1 0 0 0 1 1h2"/><path d="M15 18H9"/><path d="M19 18h2a1 1 0 0 0 1-1v-3.65a1 1 0 0 0-.22-.624l-3.48-4.35A1 1 0 0 0 17.52 8H14"/><circle cx="17" cy="18" r="2"/><circle cx="7" cy="18" r="2"/></svg>
                        <span id="count-배송중" class="filter-badge">0</span>
                    </button>
                    <button data-filter="완료" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M21.801 10A10 10 0 1 1 17 3.335"/><path d="m9 11 3 3L22 4"/></svg>
                        <span id="count-완료" class="filter-badge">0</span>
                    </button>
                </div>
            </div>
        </div>

        <div id="main-content-wrapper" class="flex-1 overflow-y-auto min-h-0 relative" style="overscroll-behavior: contain;">
            <div id="refresh-indicator" class="absolute top-0 left-0 right-0 flex justify-center items-center h-12 opacity-0 transition-opacity duration-300 pointer-events-none">
                <div class="spinner"></div>
            </div>
            <div class="max-w-md mx-auto p-4 sm:p-6 lg:p-8">
          <!-- ▼▼▼ [수정] 설정 항목들을 재구성 ▼▼▼ -->
                <div id="data-management-container" class="w-full min-w-[320px] space-y-4 hidden">
                    <!-- ▼▼▼ [수정] 환경설정 섹션 (테마, 지도, 데이터 통합) ▼▼▼ -->
                    <div class="setting-section">
                        <!-- 테마 설정 항목 -->
                        <div class="flex items-center justify-between">
                            <h3 class="setting-section-title !mb-0">테마</h3>
                            <div class="flex items-center">
                                <!-- 라이트/다크 아이콘 스위치 -->
                                <div id="theme-switch-container" class="relative flex items-center p-1 rounded-md bg-gray-100 dark:bg-gray-700">
                                    <div id="theme-glider" class="absolute h-8 w-8 bg-white dark:bg-gray-500 rounded-md shadow-sm transition-all duration-300 ease-in-out"></div>
                                    <button id="light-theme-btn" data-theme="light" class="relative z-10 w-8 h-8 flex items-center justify-center text-gray-600 dark:text-gray-300">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
                                    </button>
                                    <button id="dark-theme-btn" data-theme="dark" class="relative z-10 w-8 h-8 flex items-center justify-center text-gray-600 dark:text-gray-300">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.985 12.486a9 9 0 1 1-9.473-9.472c.405-.022.617.46.402.803a6 6 0 0 0 8.268 8.268c.344-.215.825-.004.803.401"/></svg>
                                    </button>
                                </div>
                                <!-- 시스템 테마 토글 스위치 -->
                                <div class="flex items-center space-x-2 pl-3">
                                    <span class="text-sm font-medium text-gray-700 dark:text-gray-300">시스템</span>
                                    <label for="system-theme-toggle" class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="system-theme-toggle" class="sr-only peer">
                                        <div class="w-11 h-6 bg-gray-300 dark:bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- 구분선 -->
                        <hr class="my-4 border-gray-200 dark:border-gray-700">

                        <!-- 지도 설정 항목 -->
                        <div class="flex items-center justify-between">
                            <h3 class="setting-section-title !mb-0">지도</h3>
                            <div id="map-selection-container" class="flex space-x-1 rounded-lg bg-gray-100 dark:bg-gray-700 p-1">
                                <button data-map="naver" class="map-select-btn px-4 py-1 text-sm font-semibold rounded-md transition-colors">네이버</button>
                                <button data-map="kakao" class="map-select-btn px-4 py-1 text-sm font-semibold rounded-md transition-colors">카카오</button>
                            </div>
                        </div>

                        <!-- 구분선 -->
                        <hr class="my-4 border-gray-200 dark:border-gray-700">

                        <!-- 데이터 관리 항목 -->
                        <div class="flex items-center justify-between">
                            <h3 class="setting-section-title !mb-0">데이터 관리</h3>
                            <div class="flex items-center space-x-2">
                                <button id="exportDataButton" class="w-10 h-10 flex items-center justify-center rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"/><path d="M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7"/><path d="M7 3v4a1 1 0 0 0 1 1h7"/></svg>
                                </button>
                                <label for="importDataInput" class="w-10 h-10 flex items-center justify-center rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600 cursor-pointer">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"/></svg>
                                </label>
                                <input type="file" id="importDataInput" class="hidden" accept=".json"/>
                            </div>
                        </div>
                    </div>

                    <!-- 앱 초기화 섹션 -->
                    <div class="setting-section">
                        <h3 class="setting-section-title">앱 초기화</h3>
                        <button id="clearAllCardsButton" class="w-full px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">모든 카드 삭제</button>
                    </div>
                </div>
                <!-- ▲▲▲ [수정 끝] ▲▲▲ -->

                <div id="scan-section-container" class="mb-6 p-4 bg-white dark:bg-gray-800 rounded-lg shadow-lg w-full min-w-[320px] hidden">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3">송장 스캔하여 카드 생성</h3>
                    <div class="flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 sm:space-x-3">
                        <input type="file" id="deliverySheetImage" accept="image/*" multiple class="hidden"/>
                        <label for="deliverySheetImage" class="flex-1 w-full text-sm text-blue-700 dark:text-blue-300 py-2 px-4 rounded-md border border-blue-300 dark:border-blue-600 bg-blue-50 dark:bg-blue-900/30 font-semibold cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900/50 text-center whitespace-nowrap">사진 선택</label>
                        <button id="scanAndGenerateButton" class="w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">스캔하여 카드 생성</button>
                    </div>
                    <div id="selected-files-display" class="mt-2 text-sm text-gray-600 dark:text-gray-400 text-center">선택된 파일 없음</div>
                    <div id="scan-loading-indicator" class="hidden mt-3 text-center text-sm text-blue-600 dark:text-blue-400">
                        <div class="spinner mx-auto mb-2"></div>
                        <p id="scan-progress-text">송장 스캔 중...</p>
                    </div>
                    <div id="scan-error-message" class="hidden mt-3 text-center text-sm text-red-600 dark:text-red-400">스캔 실패: <span id="scan-error-text"></span></div>
                </div>
                
                <div id="version-info-container" class="mb-6 text-center hidden">
                    <p id="version-text" class="text-xs text-gray-600 dark:text-gray-400 font-mono"></p>
                    <p id="version-changelog" class="text-xs text-gray-500 dark:text-gray-500"></p>
                </div>

                <div id="delivery-cards-container" class="pb-14"></div>
            </div>
        </div>
    </div>

    <div id="toast-container"></div>

    <div id="search-bar-container" class="fixed bottom-0 left-0 w-full z-40">
        <div class="max-w-md mx-auto px-4 sm:px-6 lg:px-8 pb-3">
            <!-- ▼▼▼ [수정] 검색창에 다크모드 클래스 추가 ▼▼▼ -->
            <div id="search-bar" class="flex items-center w-full p-1.5 rounded-2xl bg-white/90 dark:bg-gray-800/80 backdrop-blur-md border dark:border-gray-600">
                <div class="pl-2 pr-1 text-gray-400 dark:text-gray-500">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
                </div>
                <input type="tel" id="invoiceNumber" name="invoiceNumber" placeholder="송장번호 또는 전화번호 검색" class="flex-grow flex-shrink min-w-0 px-2 py-2 bg-transparent border-none focus:ring-0 outline-none text-base placeholder:text-gray-500 dark:placeholder:text-gray-400" inputmode="numeric" pattern="[0-9]*"/>
                <button id="barcode-scan-button" class="w-10 h-10 flex-shrink-0 flex items-center justify-center text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-teal-600 dark:text-teal-400"><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><path d="M8 7v10"/><path d="M12 7v10"/><path d="M17 7v10"/></svg>
                </button>
                <button id="resetButton" class="w-10 h-10 flex-shrink-0 flex items-center justify-center text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M10 5a2 2 0 0 0-1.344.519l-6.328 5.74a1 1 0 0 0 0 1.481l6.328 5.741A2 2 0 0 0 10 19h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2z"/><path d="m12 9 6 6"/><path d="m18 9-6 6"/></svg>
                </button>
            </div>
        </div>
    </div>

    <div id="action-bar-container" class="fixed bottom-0 left-0 w-full z-40 pointer-events-none">
        <div class="max-w-md mx-auto w-full min-w-[320px] p-4 flex justify-end">
            <!-- ▼▼▼ [수정] FAB 패널에 다크모드 클래스 추가 ▼▼▼ -->
            <div id="fab-panel" class="flex items-center space-x-1 p-1.5 rounded-full bg-white/80 dark:bg-gray-800/80 backdrop-blur-md shadow-lg border border-gray-200 dark:border-gray-600 pointer-events-auto">
                <div id="fab-options" class="flex items-center space-x-1"></div>
                <button id="fab-main-button" class="w-10 h-10 flex-shrink-0 flex items-center justify-center rounded-full transition-colors duration-200">
                </button>
            </div>
        </div>
    </div>

    <!-- 모달들은 CSS 변수를 통해 배경색이 제어됩니다. 내부 텍스트/버튼 색상만 조정합니다. -->
    <div id="number-jump-modal" class="number-jump-modal" style="display: none;">
        <div class="number-jump-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">번호로 이동</h2>
            <div id="number-jump-list"></div>
            <div class="flex justify-end mt-6">
                <button id="number-jump-close" class="px-4 py-2 bg-gray-400 dark:bg-gray-600 text-white rounded-md hover:bg-gray-500 dark:hover:bg-gray-500 text-sm font-medium">닫기</button>
            </div>
        </div>
    </div>

    <div id="signature-modal" class="signature-modal" style="display: none;">
        <div class="signature-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">서명 입력</h2>
            <div class="signature-input-container">
                <textarea id="signature-text-input" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200" rows="3" placeholder="여기에 서명 내용을 입력하세요."></textarea>
            </div>
            <div class="flex justify-end space-x-2 mt-4">
                <button id="clearSignature" class="px-4 py-2 rounded-md bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-sm font-medium hover:bg-gray-400 dark:hover:bg-gray-500">지우기</button>
                <button id="cancelSignature" class="px-4 py-2 rounded-md bg-red-500 text-white text-sm font-medium hover:bg-red-600">취소</button>
                <button id="saveSignature" class="px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">저장</button>
            </div>
        </div>
    </div>

    <div id="confirmation-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200" id="confirmation-modal-title">확인</h2>
            <div id="confirmation-modal-body">
                <p class="text-base text-gray-700 dark:text-gray-300 mb-6" id="confirmation-modal-message"></p>
            </div>
            <div class="flex justify-between space-x-2 mt-4" id="confirmation-modal-buttons">
                <button id="confirmCancelButton" class="w-1/2 px-4 py-2 rounded-md bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-sm font-medium hover:bg-gray-400 dark:hover:bg-gray-500">취소</button>
                <button id="confirmOkButton" class="w-1/2 px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">확인</button>
            </div>
        </div>
    </div>

    <div id="smart-edit-modal" class="smart-edit-modal" style="display: none;">
        <div class="smart-edit-modal-content">
            <div id="smart-edit-scroll-area">
                <div class="mb-4">
                    <h3 class="text-sm font-semibold text-gray-600 dark:text-gray-400 mb-1">AI 추출 원본 (참조용)</h3>
                    <p id="original-address-display" class="p-2 bg-gray-100 dark:bg-gray-700 rounded-md text-gray-800 dark:text-gray-300 text-sm font-mono break-all"></p>
                </div>

                <div class="mb-2">
                    <h3 class="text-sm font-semibold text-gray-600 dark:text-gray-400 mb-1">주소 조각 (클릭하여 추가)</h3>
                    <div id="address-pieces-container" class="flex flex-wrap p-2 bg-gray-50 dark:bg-gray-900 rounded-md border border-gray-200 dark:border-gray-600 min-h-[40px]"></div>
                </div>
                
                <div id="fixed-buttons-container" class="mt-2 grid grid-cols-2 gap-4">
                    <div id="number-keypad" class="grid grid-cols-3 gap-2"></div>
                    <div id="unit-keypad" class="grid grid-cols-2 gap-2"></div>
                </div>

                <hr class="my-4 border-gray-300 dark:border-gray-600"/>

                <div class="mt-4">
                    <div class="flex justify-between items-center mb-2">
                         <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200">주소 조각 편집</h3>
                         <div class="flex items-center space-x-2">
                            <button id="reset-pieces-btn" class="p-1.5 text-red-500 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                            </button>
                            <button id="apply-pieces-btn" class="px-4 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-sm font-medium">수정 완료</button>
                         </div>
                    </div>
                    <textarea id="pieces-address-input" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200 focus:ring-blue-500 focus:border-blue-500 resize-none overflow-hidden" rows="1" readonly></textarea>
                </div>
                
                <div class="mt-4">
                     <div class="flex justify-between items-center mb-2">
                         <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200">직접 주소 편집</h3>
                         <div class="flex items-center space-x-2">
                             <button id="revert-direct-btn" class="p-1.5 text-blue-600 dark:text-blue-400 hover:bg-blue-100 dark:hover:bg-blue-900/30 rounded-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>
                            </button>
                             <button id="reset-direct-btn" class="p-1.5 text-red-500 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                            </button>
                            <button id="apply-direct-btn" class="px-4 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-sm font-medium">수정 완료</button>
                         </div>
                    </div>
                    <textarea id="direct-address-input" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:ring-blue-500 focus:border-blue-500 resize-none overflow-hidden" rows="2"></textarea>
                </div>

            </div>
            <div class="flex justify-end mt-auto pt-4 border-t border-gray-200 dark:border-gray-700">
                <button id="smart-edit-exit" class="px-4 py-2 bg-gray-400 dark:bg-gray-600 text-white rounded-md hover:bg-gray-500 dark:hover:bg-gray-500 text-sm font-medium">나가기</button>
            </div>
        </div>
    </div>

    <div id="completion-options-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-6 text-gray-800 dark:text-gray-200" id="completion-options-title">완료 옵션 선택</h2>
            <div id="completion-options-list" class="space-y-3"></div>
            <div class="flex justify-end mt-8">
                <button id="completion-options-cancel" class="px-4 py-2 bg-gray-400 dark:bg-gray-600 text-white rounded-md hover:bg-gray-500 dark:hover:bg-gray-500 text-sm font-medium">취소</button>
            </div>
        </div>
    </div>

    <div id="delivery-location-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200" id="delivery-location-title">배송 위치 선택</h2>
            <div id="delivery-location-card-info" class="mb-4"></div>
            <div id="delivery-location-options" class="space-y-1"></div>
            <div class="flex justify-between space-x-2 mt-6">
                <button id="location-modal-cancel" class="w-1/2 px-4 py-2 rounded-md bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-sm font-medium hover:bg-gray-400 dark:hover:bg-gray-500">취소</button>
                <button id="location-modal-confirm" class="w-1/2 px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">배송 완료</button>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        // ▼▼▼▼▼ [수정] 새로운 UI에 맞춘 다크모드 테마 제어 로직 ▼▼▼▼▼
const themeColorMeta = document.getElementById('theme-color-meta');

const applyTheme = (themePreference) => {
    const systemThemeToggle = document.getElementById('system-theme-toggle');
    const themeSwitchContainer = document.getElementById('theme-switch-container');
    const themeGlider = document.getElementById('theme-glider');
    const lightBtn = document.getElementById('light-theme-btn');
    const darkBtn = document.getElementById('dark-theme-btn');

    let effectiveTheme = themePreference;
    const isSystemMode = themePreference === 'system';

    if (isSystemMode) {
        effectiveTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    // 1. HTML 클래스 및 메타 태그 업데이트
    if (effectiveTheme === 'dark') {
        document.documentElement.classList.add('dark');
        if (themeColorMeta) themeColorMeta.setAttribute('content', '#111827'); // gray-900
    } else {
        document.documentElement.classList.remove('dark');
        if (themeColorMeta) themeColorMeta.setAttribute('content', '#ffffff'); // white
    }
    
    // 2. UI 업데이트
    if (systemThemeToggle && themeSwitchContainer && themeGlider && lightBtn && darkBtn) {
        // 시스템 토글 상태 업데이트
        systemThemeToggle.checked = isSystemMode;
        
        // 라이트/다크 스위치 비활성화/활성화
        themeSwitchContainer.classList.toggle('disabled', isSystemMode);

        // 글라이더 위치 이동
        const targetButton = effectiveTheme === 'dark' ? darkBtn : lightBtn;
        themeGlider.style.transform = `translateX(${targetButton.offsetLeft - lightBtn.offsetLeft}px)`;
        
        // 아이콘 색상 활성화
        lightBtn.classList.toggle('text-yellow-500', effectiveTheme === 'light');
        lightBtn.classList.toggle('text-gray-600', effectiveTheme !== 'light');
        darkBtn.classList.toggle('text-blue-400', effectiveTheme === 'dark');
        darkBtn.classList.toggle('text-gray-600', effectiveTheme !== 'dark');
    }

    // 3. 선택 사항 저장
    localStorage.setItem('theme', themePreference);
};

const initializeTheme = () => {
    const savedTheme = localStorage.getItem('theme') || 'system';
    applyTheme(savedTheme);
};

// 시스템 테마 변경 감지
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
    // 시스템 모드가 활성화 되어 있을 때만 테마를 자동으로 변경
    if (localStorage.getItem('theme') === 'system') {
        applyTheme('system');
    }
});
// ▲▲▲▲▲ [수정 끝] ▲▲▲▲▲


        const GEMINI_PROMPT = `Analyze the provided image containing one or more delivery invoices. Your task is to identify each distinct invoice block and extract its key information into a valid JSON array.

**CRITICAL INSTRUCTIONS:**

1.  **IDENTIFY EACH INVOICE:** Treat each logical invoice area as a separate item. An "no" is essential for each item.

2.  **EXTRACT KEY-VALUE PAIRS:** For each invoice, extract the following fields: "no", "hawbNo", "receiverAddress", "receiverPhone", "receiverCompanyName", and "receiverName".

3.  **SEPARATE COMPANY AND PERSONAL NAME:**
    *   **Scenario A (Separate Columns):** If the invoice has distinct columns like "Company Name of Receiver" and "Name of receiver", extract the text from each column into "receiverCompanyName" and "receiverName" respectively.
    *   **Scenario B (Combined Field):** If the recipient information is in a single combined field, intelligently separate the company/organization name and the personal name.
    *   **Handling Edge Cases:**
        *   If only a personal name is found, put it in "receiverName" and omit "receiverCompanyName".
        *   If only a company name is found (e.g., "ABC Mart", "(주)DEF"), put it in "receiverCompanyName" and repeat it in "receiverName".
        *   If you cannot separate them, put the entire text into both "receiverCompanyName" and "receiverName".

4.  **TRANSLATE AND SEPARATE ADDRESS:**
    *   Translate "receiverName" and "receiverCompanyName" to Korean if they are in English/Romanized Korean. Store them in "receiverNameKorean" and "receiverCompanyNameKorean". If already in Korean, just copy them.
    *   **STEP 1: Perform a STRICT, LITERAL TRANSLATION of the original "receiverAddress".**
        *   Translate every component EXACTLY as it appears.
        *   **English Word Joining Rule:** If a single English word is broken across lines (e.g., 'OLYMPI' and 'CRO'), you MUST join them (e.g., 'OLYMPICRO').
        *   **Korean Noun Joining Rule:** When processing Korean addresses, if two consecutive lines can form a natural compound noun (like an apartment name or a road name), you MUST join them without a space. However, do not merge numbers with units (like 동, 호) if they are on separate lines.
            *   Example 1: '래미' on line 1 and '안' on line 2 MUST become '래미안'.
            *   Example 2: '오금' on line 1 and '로' on line 2 MUST become '오금로'.
            *   Example 3: '106동' on line 1 and '1302호' on line 2 MUST remain separate as '106동 1302호'.
        *   **Default Rule:** If the lines do not form a natural single word, treat the line break as a space.
        *   DO NOT reorder, correct, or omit any other characters (e.g., 'GAGIL' MUST become '가길').
        *   If the original is already in Korean, just copy it.
        *   Let's call this result the "Translated Full Address".
    *   **STEP 2: From the "Translated Full Address", separate it into "baseAddressKorean" and "detailAddressKorean" using the following rules:**
        *   **Rule A (Primary): Find the Address Anchor.** First, search for a Korean road name anchor ('로', '길') or a legal address anchor ('동', '리'). Prioritize road name anchors.
        *   **Rule B (If Anchor Found): Extract the Base Address.** The base address consists of everything from the start of the address up to and including the number block that appears IMMEDIATELY BEFORE the anchor. This number is the building number or lot number.
            *   Example 1: For "서울 송파구 1218 양재대로 245-501", the anchor is '대로'. The number block immediately before it is '1218'. So, "baseAddressKorean" is "서울 송파구 양재대로 1218".
            *   Example 2: For "경기 성남시 분당구 판교역로 235", the anchor is '로'. The number block before it is '235'. So, "baseAddressKorean" is "경기 성남시 분당구 판교역로 235".
            *   **Example 3 (Precedence Rule):** For "서울 송파구 135, 올림픽로 235-1301", the anchor is '로'. The number block before the anchor (135) has higher priority than the number after it (235). So, "baseAddressKorean" MUST be "서울 송파구 올림픽로 135".
        *   **Rule C (If Anchor Found): Extract the Detail Address.** "detailAddressKorean" is everything that remains after the base address has been extracted.
            *   From Example 1, "detailAddressKorean" would be "245-501".
            *   From Example 3, "detailAddressKorean" would be "235-1301".
        *   **Rule D (If No Anchor Found): Use Best Judgment.** If no clear anchor ('로', '길', '동', '리') can be identified (due to OCR errors or unusual formatting), analyze the structure and make a best-effort guess to separate the base and detail addresses as you did before.
        *   **Address Hierarchy Rule:** If both a street address (e.g., '풍성로14길 19') and an administrative dong (e.g., '풍납2동') are present, the street address is the primary component for "baseAddressKorean". The administrative dong should be considered redundant information and **MUST be omitted** from the final output unless it is part of a building name.

5.  **OUTPUT A JSON ARRAY:** Your entire output MUST be a single, valid JSON array of objects.

**Example Output:**
[
  {
    "no": "40",
    "hawbNo": "SF028452891 8577",
    "receiverCompanyName": "Techfiber.Co.,-Ltd",
    "receiverCompanyNameKorean": "테크파이버",
    "receiverName": "Richard Kim",
    "receiverNameKorean": "김리차드",
    "receiverPhone": "24080670",
    "receiverAddress": "No.601, 422-dong, 1300, yangjae-daero",
    "baseAddressKorean": "서울 강동구 양재대로 1300",
    "detailAddressKorean": "601호 422동"
  },
  {
    "no": "1",
    "hawbNo": "SF319999130 4534",
    "receiverCompanyName": "Jiyoung Her",
    "receiverCompanyNameKorean": "허지영",
    "receiverName": "Jiyoung Her",
    "receiverNameKorean": "허지영",
    "receiverPhone": "01025190714",
    "receiverAddress": "Seoul Songpa-gu 135, Olympic-ro 235-1301",
    "baseAddressKorean": "서울 송파구 올림픽로 135",
    "detailAddressKorean": "235-1301"
  }
]
`;
        
        const KAKAO_API_KEY = '2342aad8b15d534cb60fb824f71a97f1';

        const dateTimeFormatOptions = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };

        // --- Helper functions ---

            const showLoadingMessage = (message) => {
    confirmationModalTitle.textContent = '처리 중...';
    confirmationModalBody.innerHTML = `
        <div class="flex flex-col items-center justify-center p-4">
            <div class="spinner mb-4"></div>
            <p class="text-base text-gray-700 dark:text-gray-300">${message}</p>
        </div>
    `;
    // 확인/취소 버튼 숨기기
    confirmationModalButtons.style.display = 'none';
    document.body.classList.add('modal-open');
    confirmationModal.style.display = 'flex';
};

const showToastMessage = (message, duration = 2000) => {
    const toast = document.createElement('div');
    toast.className = 'toast-message';
    toast.textContent = message;
    toastContainer.appendChild(toast);

    // Animate in
    setTimeout(() => {
        toast.classList.add('show');
    }, 10);

    // Animate out and remove
    setTimeout(() => {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, { once: true });
    }, duration);
};

const showMessage = (message, title = '알림') => {
    confirmationModalTitle.textContent = title;
    confirmationModalBody.innerHTML = `<p class="text-base text-gray-700 dark:text-gray-300 mb-6">${message}</p>`;
    confirmOkButton.textContent = '확인';
    // 취소 버튼은 숨깁니다.
    confirmCancelButton.style.display = 'none';
    confirmationModalButtons.style.display = 'flex';
    
    onConfirmCallback = null; // 확인 버튼 클릭 시 특별한 동작 없음
    document.body.classList.add('modal-open');
    confirmationModal.style.display = 'flex';
};

const sendCompletionNotification = (item) => {
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const fullAddress = item.baseAddress + (item.detailAddress ? `, ${item.detailAddress}` : '');
        const time = formatCompletionTime(item.deliveryCompletionTime);

        navigator.serviceWorker.controller.postMessage({
            type: 'SHOW_NOTIFICATION',
            payload: {
                no: item.no,
                location: item.completionDetail || item.completionType,
                receiverName: item.receiverNameKorean,
                companyName: item.companyNameKorean,
                address: fullAddress,
                time: time
            }
        });
    }
};

        const resizeAppContainer = () => {
            const appContainer = document.getElementById('app-container');
            if (appContainer) {
                appContainer.style.height = `${window.innerHeight}px`;
            }
        };
        const isValidPhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) {
                return true; // 번호가 없으면 유효한 것으로 간주 (수정 대상이 아님)
            }
            
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('82')) {
                cleaned = '0' + cleaned.substring(2);
            }

            if (cleaned.startsWith('010')) {
                return cleaned.length === 11;
            }
            
            if (cleaned.startsWith('02')) {
                return cleaned.length === 9 || cleaned.length === 10;
            }

            if (cleaned.startsWith('070')) {
                return cleaned.length === 11;
            }

            if (cleaned.startsWith('0')) {
                return cleaned.length === 10 || cleaned.length === 11;
            }

            return false;
        };

        const setVersionInfo = () => {
            const version = "v1.7.13";
            const changelog = "버그수정";
            if (versionText) versionText.textContent = version;
            if (versionChangelog) versionChangelog.textContent = changelog;
        };

                const setupDelegatedEventListeners = () => {
            let touchTarget = null;

            deliveryCardsContainer.addEventListener('touchstart', (event) => {
                const target = event.target.closest('button[data-action="front-door-delivery"]');
                if (!target) return;

                isLongPress = false;
                touchTarget = target;
                
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                
                    const itemNo = parseInt(target.dataset.no, 10);
                    openCompletionOptionsModal(itemNo);
                }, 300);
            }, { passive: true });

            deliveryCardsContainer.addEventListener('touchmove', () => {
                clearTimeout(longPressTimer);
                touchTarget = null;
            }, { passive: true });

            deliveryCardsContainer.addEventListener('touchend', (event) => {
                clearTimeout(longPressTimer);
                
                if (isLongPress) {
                    event.preventDefault();
                    isLongPress = false;
                }
            });

            deliveryCardsContainer.addEventListener('click', (event) => {
                if (isLongPress) {
                    isLongPress = false;
                    return;
                }
                
                const target = event.target.closest('button, input[type="checkbox"], p[data-action="open-smart-edit"], span[data-action="edit-phone"], span[data-action="copy-completion"], span[data-action="edit-completion-detail"], span[data-action="copy-hawb"], button[data-action="swap-name"], span[data-action="edit-completion-time"]');
                if (!target) return;

                const action = target.dataset.action;
                const itemNo = parseInt(target.dataset.no, 10);

                switch (action) {
                    case 'copy-completion':
                        {
                            const item = deliveryItems.find(i => i.no === itemNo);
                            if (item) {
                                const completionText = item.completionType === '본인전달'
                                    ? (item.receiverNameKorean || '')
                                    : (item.completionDetail || item.completionType || '');
                                const timeText = formatCompletionTime(item.deliveryCompletionTime);
                                const textToCopy = `${item.no} - ${completionText} [${timeText}]`;
                                
                                navigator.clipboard.writeText(textToCopy).then(() => {
                                    showToastMessage(`'${textToCopy}' 복사 완료`);
                                }).catch(err => {
                                    console.error('클립보드 복사 실패:', err);
                                    showMessage('클립보드 복사에 실패했습니다.');
                                });
                            }
                        }
                        break;
                    case 'edit-completion-detail':
                        {
                            const item = deliveryItems.find(i => i.no === itemNo);
                            if (item) {
                                const isEditableText = ['본인전달', '직접입력'].includes(item.completionType);
                                if (isEditableText) {
                                    openSignatureModal(item.no); 
                                } else {
                                    openDeliveryLocationModal(item.no);
                                }
                            }
                        }
                        break;

                    case 'toggle-hawb-confirm':
                        handleCheckboxToggleAndResetSearch(itemNo, target.checked);
                        break;
                    case 'open-map':
                        {
                            const item = deliveryItems.find(i => i.no === itemNo);
                            if (item) openMap(item);
                        }
                        break;
                    case 'swap-name':
                        {
                            const itemIndex = deliveryItems.findIndex(i => i.no === itemNo);
                            if (itemIndex > -1) {
                                const item = deliveryItems[itemIndex];
                                if (typeof item.receiverNameKoreanOriginal === 'undefined') {
                                    item.receiverNameKoreanOriginal = item.receiverNameKorean;
                                }
                                const currentName = item.receiverNameKorean;
                                const originalName = item.receiverNameKoreanOriginal;
                                if (currentName !== originalName) {
                                    deliveryItems[itemIndex].receiverNameKorean = originalName;
                                } else {
                                    const nameToSwap = currentName.trim().replace(/\s/g, '');
                                    if (nameToSwap.length > 1) {
                                        const lastChar = nameToSwap.slice(-1);
                                        const restOfString = nameToSwap.slice(0, -1);
                                        const newName = `${lastChar}${restOfString}`;
                                        deliveryItems[itemIndex].receiverNameKorean = newName;
                                    }
                                }
                                saveDeliveryItemsToLocalStorage();
                                renderDeliveryCards(activeFilter);
                            }
                        }
                        break;
                    case 'copy-hawb':
                        {
                            const hawbToCopy = target.dataset.hawbNo;
                            if (hawbToCopy) {
                                navigator.clipboard.writeText(hawbToCopy).catch(err => {
                                    console.error('송장번호 복사 실패:', err);
                                    showMessage('송장번호 복사에 실패했습니다.');
                                });
                            }
                        }
                        break;
                    case 'revert-delivery':
                        openConfirmationModal(`${itemNo}번 항목을 '배송중' 상태로 되돌리시겠습니까?`, () => {
                            handleStatusChange(itemNo, '배송중');
                            showToastMessage(`${itemNo}번 항목이 되돌려졌습니다.`);
                        });
                        break;
                    case 'identity-verification':
                        openConfirmationModal(`${itemNo}번 항목을 '본인전달'로 완료 처리하시겠습니까?`, () => {
                            const currentTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
                            handleStatusChange(itemNo, '완료', currentTime, '본인전달', '신분증');
                            sortItemsByDistanceSilent();
                        });
                        break;
                    case 'open-location-modal':
                        openDeliveryLocationModal(itemNo);
                        break;
                    case 'sign-delivery':
                        openSignatureModal(itemNo);
                        break;
                    case 'toggle-details':
                        {
                            const detailsContainer = document.querySelector(`div[data-details-container="${itemNo}"]`);
                            const iconButton = target.closest('button');
                            const iconSvg = iconButton.querySelector('svg');
                            if (detailsContainer && iconSvg) {
                                const isHidden = detailsContainer.style.display === 'none';
                                detailsContainer.style.display = isHidden ? 'block' : 'none';
                                if (isHidden) {
                                    iconSvg.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />`;
                                } else {
                                    iconSvg.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />`;
                                }
                            }
                        }
                        break;
                    case 'edit-phone':
                        openPhoneEditModal(itemNo);
                        break;
                    case 'open-smart-edit':
                        openSmartEditModal(itemNo);
                        break;
                    case 'edit-completion-time':
                        openTimeEditModal(itemNo);
                        break;
                }
            });

            completionOptionsCancelBtn.addEventListener('click', () => {
                completionOptionsModal.style.display = 'none';
            });
        };

        const resizeImage = (file) => {
            return new Promise((resolve, reject) => {
                const MAX_WIDTH = 1920;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;
                        if (width > MAX_WIDTH) {
                            height = (MAX_WIDTH / width) * height;
                            width = MAX_WIDTH;
                        }
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                        resolve({ file, data: dataUrl.split(',')[1] });
                    };
                    img.onerror = (error) => reject(error);
                };
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        };

        const getCurrentLocation = (timeout = 10000) => {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    return reject(new Error('Geolocation is not supported by this browser.'));
                }
                navigator.geolocation.getCurrentPosition(
                    (position) => resolve({ lat: position.coords.latitude, lng: position.coords.longitude }),
                    (error) => reject(error),
                    { enableHighAccuracy: true, timeout, maximumAge: 0 }
                );
            });
        };

        const getCoordsFromAddress = async (address) => {
            if (!address) throw new Error("Address is empty.");
            const response = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(address)}`, {
                headers: { 'Authorization': `KakaoAK ${KAKAO_API_KEY}` }
            });
            if (!response.ok) throw new Error('Kakao Geocoding API call failed');
            const data = await response.json();
            if (data.documents && data.documents.length > 0) {
                const location = data.documents[0];
                return { lat: parseFloat(location.y), lng: parseFloat(location.x) };
            }
            throw new Error("Could not find coordinates for the address.");
        };

        const calculateDistance = (pos1, pos2) => {
            if (!pos1 || !pos2) return Infinity;
            const R = 6371; // Radius of the Earth in km
            const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
            const dLon = (pos2.lng - pos1.lng) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance in km
        };

        const formatSinglePhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('+82010')) { cleaned = '010' + cleaned.substring(6); }
            else if (cleaned.startsWith('82010')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('+8210')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('8210')) { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('8201') && cleaned.length > 4 && cleaned[4] !== '0') { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('82') && cleaned.length > 2) { cleaned = '0' + cleaned.substring(2); }
            else if (cleaned.length >= 7 && cleaned.length <= 11 && !cleaned.startsWith('0')) { cleaned = '0' + cleaned; }
            
            if (cleaned.startsWith('010') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.startsWith('02')) {
                if (cleaned.length === 9) return cleaned.replace(/(\d{2})(\d{3})(\d{4})/, '$1-$2-$3');
                if (cleaned.length === 10) return cleaned.replace(/(\d{2})(\d{4})(\d{4})/, '$1-$2-$3');
            }
            if (cleaned.startsWith('031') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.startsWith('070') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 10) return cleaned.replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 9) return cleaned.replace(/(\d{2})(\d{3})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 8) return cleaned.replace(/(\d{4})(\d{4})/, '$1-$2');
            if (cleaned.length === 7) return cleaned.replace(/(\d{3})(\d{4})/, '$1-$2');

            return cleaned;
        };

        const formatPhoneNumberForDisplay = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            const rangeMatch = phoneNumber.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) {
                const baseNumber = rangeMatch[1];
                const suffix = rangeMatch[2];
                if (baseNumber.length >= suffix.length) {
                    const num1 = formatSinglePhoneNumber(baseNumber);
                    const num2Raw = baseNumber.substring(0, baseNumber.length - suffix.length) + suffix;
                    const num2 = formatSinglePhoneNumber(num2Raw);
                    return `${num1} / ${num2}`;
                }
            }
            return formatSinglePhoneNumber(phoneNumber.replace(/\D/g, ''));
        };

        const getCleanPhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            const rangeMatch = phoneNumber.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) phoneNumber = rangeMatch[1];
            
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('+82010')) { cleaned = '010' + cleaned.substring(6); }
            else if (cleaned.startsWith('82010')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('+8210')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('8210')) { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('8201') && cleaned.length > 4 && cleaned[4] !== '0') { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('82') && cleaned.length > 2) { cleaned = '0' + cleaned.substring(2); }
            else if (cleaned.length >= 7 && cleaned.length <= 11 && !cleaned.startsWith('0')) { cleaned = '0' + cleaned; }

            return cleaned;
        };

        const formatHawbNoForDisplay = (hawbNo) => {
            if (!hawbNo || hawbNo.length < 4) return hawbNo;
            const prefix = hawbNo.substring(0, hawbNo.length - 4);
            const suffix = hawbNo.substring(hawbNo.length - 4);
            return `${prefix} ${suffix}`;
        };

        const formatCompletionTime = (dateTimeString) => {
            if (!dateTimeString) return '';
            const parts = dateTimeString.split(' ');
            if (parts.length >= 4) {
                const [hour, minute] = parts[3].split(':');
                return `${hour}:${minute}`;
            }
            return '';
        };
        
        const extractClipboardAddressPart = (item) => {
            if (!item) return '';
            const { baseAddress, detailAddress } = item;

            if (detailAddress) {
                const hyphenMatch = detailAddress.match(/\b(\d{2,4}-\d{2,4})\b/);
                if (hyphenMatch) return hyphenMatch[1];
                const dongHoMatch = detailAddress.match(/(\d+)\s*동\s*(\d+)\s*호/);
                if (dongHoMatch) return `${dongHoMatch[1]}-${dongHoMatch[2]}`;
            }

            if (baseAddress) {
                const addressParts = baseAddress.split(' ');
                const adminNames = ['서울', '부산', '대구', '인천', '광주', '대전', '울산', '세종', '경기', '강원', '충북', '충남', '전북', '전남', '경북', '경남', '제주'];
                const adminSuffixes = ['도', '시', '구', '군', '읍', '면'];
                
                while (addressParts.length > 0) {
                    const firstPart = addressParts[0];
                    if (adminNames.includes(firstPart) || adminSuffixes.some(suffix => firstPart.endsWith(suffix))) {
                        addressParts.shift();
                    } else {
                        break;
                    }
                }
                
                const resultAddress = addressParts.join(' ');
                return resultAddress.length > 0 ? resultAddress : baseAddress;
            }

            return baseAddress || '';
        };

        const isValidAddressForMap = (address) => {
            return !!(address && address.trim().length > 0);
        };
        
        const validateAddressWithKakao = async (baseAddress, detailAddress) => {
            if (!baseAddress) {
                return { baseAddress: '', detailAddress: detailAddress || '', validated: false };
            }
            try {
                const response = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(baseAddress)}`, {
                    headers: { 'Authorization': `KakaoAK ${KAKAO_API_KEY}` }
                });
                if (!response.ok) throw new Error('Kakao API call failed');
                const data = await response.json();
                if (data.documents && data.documents.length > 0) {
                    const doc = data.documents[0];
                    const kakaoBaseAddress = doc.road_address ? doc.road_address.address_name : doc.address.address_name;
                    return { baseAddress: kakaoBaseAddress, detailAddress: detailAddress || '', validated: true };
                }
                return { baseAddress, detailAddress: detailAddress || '', validated: false };
            } catch (error) {
                console.error('Error validating address with Kakao API:', error);
                return { baseAddress, detailAddress: detailAddress || '', validated: false };
            }
        };

        // --- Global state and DOM elements ---
        let deliveryItems = [];
        let searchTerm = '';
        let activeFilter = '전체';
        const filterCategories = ['배송준비', '전체', '배송전', '배송중', '완료'];
        let filterScrollPositions = {};
        let currentFileToScan = null;
        let failedFileObjects = []; 
        let currentSignatureItemNo = null;
        let onConfirmCallback = null;
        let currentEditItemNo = null; 
        let currentSortOrder = 'no';
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let backButtonPressedOnce = false;
        let justReturnedFromExternalApp = false;
        let deliveryInProgressSortOrder = 'no';
        let completedSortOrder = 'no';
        let longPressTimer = null;
        let isLongPress = false;
        let isRefreshing = false;
        let pullStartY = 0;
        let refreshIndicator;
        let currentLocationEditItemNo = null;
        
        const searchBarContainer = document.getElementById('search-bar-container');
        const invoiceNumberInput = document.getElementById('invoiceNumber');
        const resetButton = document.getElementById('resetButton');
        const filterButtonsContainer = document.getElementById('filter-buttons-container');
        const deliveryCardsContainer = document.getElementById('delivery-cards-container');
        const deliverySheetImageInput = document.getElementById('deliverySheetImage');
        const scanAndGenerateButton = document.getElementById('scanAndGenerateButton');
        const scanLoadingIndicator = document.getElementById('scan-loading-indicator');
        const scanErrorMessage = document.getElementById('scan-error-message');
        const scanErrorText = document.getElementById('scan-error-text');
        const scanSectionContainer = document.getElementById('scan-section-container');
        const clearAllCardsButton = document.getElementById('clearAllCardsButton');
        const dataManagementContainer = document.getElementById('data-management-container');
        const exportDataButton = document.getElementById('exportDataButton');
        const importDataInput = document.getElementById('importDataInput');
        const scanProgressText = document.getElementById('scan-progress-text');
        const selectedFilesDisplay = document.getElementById('selected-files-display');
        const signatureModal = document.getElementById('signature-modal');
        const signatureTextInput = document.getElementById('signature-text-input');
        const clearSignatureBtn = document.getElementById('clearSignature');
        const cancelSignatureBtn = document.getElementById('cancelSignature');
        const saveSignatureBtn = document.getElementById('saveSignature');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationModalTitle = document.getElementById('confirmation-modal-title');
        const confirmationModalMessage = document.getElementById('confirmation-modal-message');
        const confirmationModalBody = document.getElementById('confirmation-modal-body');
        const confirmationModalButtons = document.getElementById('confirmation-modal-buttons');
        const confirmOkButton = document.getElementById('confirmOkButton');
        const confirmCancelButton = document.getElementById('confirmCancelButton');
        const versionInfoContainer = document.getElementById('version-info-container');
        const versionText = document.getElementById('version-text');
        const versionChangelog = document.getElementById('version-changelog');
        const smartEditModal = document.getElementById('smart-edit-modal');
        const originalAddressDisplay = document.getElementById('original-address-display');
        const piecesAddressInput = document.getElementById('pieces-address-input');
        const directAddressInput = document.getElementById('direct-address-input');
        const applyPiecesBtn = document.getElementById('apply-pieces-btn');
        const resetPiecesBtn = document.getElementById('reset-pieces-btn');
        const applyDirectBtn = document.getElementById('apply-direct-btn');
        const revertDirectBtn = document.getElementById('revert-direct-btn');
        const smartEditExitBtn = document.getElementById('smart-edit-exit');
        const toastContainer = document.getElementById('toast-container');
        const numberJumpModal = document.getElementById('number-jump-modal');
        const numberJumpList = document.getElementById('number-jump-list');
        const numberJumpClose = document.getElementById('number-jump-close');
        const actionBarContainer = document.getElementById('action-bar-container');
        const completionOptionsModal = document.getElementById('completion-options-modal');
        const completionOptionsTitle = document.getElementById('completion-options-title');
        const completionOptionsList = document.getElementById('completion-options-list');
        const completionOptionsCancelBtn = document.getElementById('completion-options-cancel');
        const deliveryLocationModal = document.getElementById('delivery-location-modal');
        const deliveryLocationTitle = document.getElementById('delivery-location-title');
        const deliveryLocationOptions = document.getElementById('delivery-location-options');
        const locationModalConfirm = document.getElementById('location-modal-confirm');
        const locationModalCancel = document.getElementById('location-modal-cancel');

        // --- Modal & Core Logic Functions ---

        function autoResizeTextarea(event) {
            const textarea = event.target;
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
        }

        const openDeliveryLocationModal = (itemNo) => {
            currentLocationEditItemNo = itemNo;
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item) return;

            deliveryLocationTitle.textContent = `${item.no}번 배송 위치 선택`;

            const deliveryLocationCardInfo = document.getElementById('delivery-location-card-info');
            deliveryLocationCardInfo.innerHTML = `
                <div class="p-2.5 bg-gray-100 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-md space-y-1">
                    <p class="text-xs text-gray-600 dark:text-gray-300 truncate"><span class="font-semibold w-11 inline-block flex-shrink-0">주소:</span> ${item.baseAddress}${item.detailAddress ? ', ' + item.detailAddress : ''}</p>
                    <p class="text-xs text-gray-600 dark:text-gray-300 truncate"><span class="font-semibold w-11 inline-block flex-shrink-0">받는분:</span> ${item.receiverNameKorean || item.receiverNameOriginal}</p>
                </div>
            `;

            const locations = ['문앞', '택배보관소', '택배함', '문서수발실', '경비실', '안내데스크'];
            let radioOptionsHtml = locations.map((location, index) => `
                <label for="loc-${index}" class="flex items-center p-2.5 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer">
                    <input type="radio" id="loc-${index}" name="delivery-location" value="${location}" class="h-5 w-5 text-blue-600 border-gray-300 focus:ring-blue-500" ${index === 0 ? 'checked' : ''}>
                    <span class="ml-3 text-sm font-medium text-gray-800 dark:text-gray-200">${location}</span>
                </label>
            `).join('');

            radioOptionsHtml += `
                <div class="flex items-center p-2.5 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600">
                    <input type="radio" id="loc-other" name="delivery-location" value="기타" class="h-5 w-5 text-blue-600 border-gray-300 focus:ring-blue-500">
                    <label for="loc-other" class="ml-3 text-sm font-medium text-gray-800 dark:text-gray-200 mr-2 cursor-pointer">기타:</label>
                    <input type="text" id="other-location-input" class="flex-1 bg-transparent border-b border-gray-400 focus:border-blue-500 focus:outline-none text-sm p-1 hidden" placeholder="직접 입력...">
                </div>
            `;
            
            deliveryLocationOptions.innerHTML = radioOptionsHtml;

            const radioButtons = document.querySelectorAll('input[name="delivery-location"]');
            const otherInput = document.getElementById('other-location-input');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', () => {
                    otherInput.classList.toggle('hidden', radio.value !== '기타');
                    if (radio.value === '기타') {
                        otherInput.focus();
                    }
                });
            });

            document.body.classList.add('modal-open');
            deliveryLocationModal.style.display = 'flex';
        };

        const closeDeliveryLocationModal = () => {
            document.body.classList.remove('modal-open');
            deliveryLocationModal.style.display = 'none';
            currentLocationEditItemNo = null;
        };

        const openPhoneEditModal = (itemNo) => {
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item) return;

            confirmationModalTitle.textContent = `${item.no}번 전화번호 수정`;
            
            confirmationModalBody.innerHTML = `
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-2">숫자만 입력하세요. 자동으로 하이픈(-)이 추가됩니다.</p>
                <input type="tel" id="phone-edit-input" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg bg-white dark:bg-gray-700" value="" inputmode="numeric" pattern="[0-9]*" maxlength="13">
            `;
            
            confirmOkButton.textContent = '수정 완료';
            confirmCancelButton.textContent = '취소';
            confirmCancelButton.style.display = '';
            confirmationModalButtons.style.display = 'flex';

            const phoneInput = document.getElementById('phone-edit-input');
            
            const autoHyphenOnInput = (target) => {
                target.value = target.value
                    .replace(/[^0-9]/g, '')
                    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, "$1-$2-$3")
                    .replace(/(\-{1,2})$/g, "");
            }
            phoneInput.addEventListener('input', (e) => autoHyphenOnInput(e.target));
            
            onConfirmCallback = () => {
                const newPhoneNumber = phoneInput.value;
                const itemIndex = deliveryItems.findIndex(i => i.no === itemNo);
                if (itemIndex > -1) {
                    deliveryItems[itemIndex].receiverTelephoneNo = newPhoneNumber;
                    saveDeliveryItemsToLocalStorage();
                    renderDeliveryCards(activeFilter);
                    showToastMessage(`${item.no}번 전화번호가 수정되었습니다.`);
                }
            };

            document.body.classList.add('modal-open');
            confirmationModal.style.display = 'flex';
            phoneInput.focus();
        };

        const openTimeEditModal = (itemNo) => {
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item || !item.deliveryCompletionTime) return;

            const currentTime = item.deliveryCompletionTime.split(' ')[3].substring(0, 5);

            confirmationModalTitle.textContent = `${item.no}번 완료 시간 수정`;
            
            confirmationModalBody.innerHTML = `
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-2">변경할 완료 시간을 선택하세요.</p>
                <input type="time" id="time-edit-input" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg bg-white dark:bg-gray-700" value="${currentTime}">
            `;
            
            confirmOkButton.textContent = '수정 완료';
            confirmCancelButton.textContent = '취소';
            confirmCancelButton.style.display = '';
            confirmationModalButtons.style.display = 'flex';
            
            onConfirmCallback = () => {
                const timeInput = document.getElementById('time-edit-input');
                const newTime = timeInput.value;

                if (newTime) {
                    const itemIndex = deliveryItems.findIndex(i => i.no === itemNo);
                    if (itemIndex > -1) {
                        const originalDateTime = deliveryItems[itemIndex].deliveryCompletionTime;
                        const datePart = originalDateTime.split(' ').slice(0, 3).join(' ');
                        const newCompletionTime = `${datePart} ${newTime}:00`;

                        deliveryItems[itemIndex].deliveryCompletionTime = newCompletionTime;
                        saveDeliveryItemsToLocalStorage();
                        renderDeliveryCards(activeFilter);
                        showToastMessage(`${item.no}번 완료 시간이 수정되었습니다.`);
                    }
                }
            };

            document.body.classList.add('modal-open');
            confirmationModal.style.display = 'flex';
        };

        const openSignatureModal = (itemNo) => { 
            currentSignatureItemNo = itemNo; 
            document.body.classList.add('modal-open');
            signatureModal.style.display = 'flex'; 
            signatureTextInput.value = ''; 
            signatureTextInput.focus(); 
        };

        const closeSignatureModal = () => { 
            document.body.classList.remove('modal-open');
            signatureModal.style.display = 'none'; 
            currentSignatureItemNo = null; 
        };

        const saveSignature = () => {
            const signatureText = signatureTextInput.value.trim();
            if (!signatureText) {
                showMessage('서명 내용을 입력해주세요.');
                return;
            }

            if (currentSignatureItemNo !== null) {
                const item = deliveryItems.find(i => i.no === currentSignatureItemNo);
                if (item) {
                    let completionTime = null;
                    let completionType = item.completionType;

                    if (item.status !== '완료') {
                        completionTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
                        completionType = '직접입력'; 
                    }
                    
                    if (item.completionType === '본인전달') {
                        deliveryItems = deliveryItems.map(i => i.no === currentSignatureItemNo ? { ...i, receiverNameKorean: signatureText } : i);
                    }

                    handleStatusChange(currentSignatureItemNo, '완료', completionTime, completionType, signatureText);
                }
                sortItemsByDistanceSilent();
                closeSignatureModal();
            }
        };

        const openCompletionOptionsModal = (itemNo) => {
            completionOptionsTitle.textContent = `${itemNo}번 완료 옵션 선택`;
            completionOptionsList.innerHTML = '';

            const options = [
                { text: '경비실', type: '경비실', detail: '경비실 전달' },
                { text: '택배함', type: '택배함', detail: '택배함 보관' },
                { text: '택배보관소', type: '택배보관소', detail: '택배보관소 보관' },
                { text: '문서수발실', type: '문서수발실', detail: '문서수발실 전달' }
            ];

            options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'w-full px-4 py-3 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-base font-semibold';
                button.textContent = option.text;
                button.onclick = () => {
                    const currentTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
                    handleStatusChange(itemNo, '완료', currentTime, option.type, option.detail);
                    sortItemsByDistanceSilent();
                    document.body.classList.remove('modal-open');
                    completionOptionsModal.style.display = 'none';
                };
                completionOptionsList.appendChild(button);
            });

            document.body.classList.add('modal-open');
            completionOptionsModal.style.display = 'flex';
        };

        const openConfirmationModal = (message, onOk, okText = '확인', cancelText = '취소') => {
            confirmationModalTitle.textContent = '확인';
            confirmationModalBody.innerHTML = `<p class="text-base text-gray-700 dark:text-gray-300 mb-6" id="confirmation-modal-message">${message}</p>`;
            confirmOkButton.textContent = okText;
            confirmCancelButton.textContent = cancelText;
            confirmCancelButton.style.display = '';
            confirmationModalButtons.style.display = 'flex';
            onConfirmCallback = onOk;
            document.body.classList.add('modal-open');
            confirmationModal.style.display = 'flex';
        };

        const closeConfirmationModal = () => { 
            document.body.classList.remove('modal-open');
            confirmationModal.style.display = 'none'; 
            onConfirmCallback = null; 
        };

        const openSmartEditModal = (itemNo) => {
            currentEditItemNo = itemNo;
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item) { showMessage('카드 정보를 찾을 수 없습니다.'); return; }
            
            const originalFullAddress = item.baseAddress + (item.detailAddress ? `, ${item.detailAddress}` : '');
            
            originalAddressDisplay.textContent = item.receiverAddressOriginal || '원본 주소 없음';
            piecesAddressInput.value = '';
            directAddressInput.value = originalFullAddress;
            setTimeout(() => {
                autoResizeTextarea({target: piecesAddressInput});
                autoResizeTextarea({target: directAddressInput});
            }, 0);

            const addressPiecesContainer = document.getElementById('address-pieces-container');
            const numberKeypad = document.getElementById('number-keypad');
            const unitKeypad = document.getElementById('unit-keypad');
            [addressPiecesContainer, numberKeypad, unitKeypad].forEach(c => c.innerHTML = '');
            
            const createKeyButton = (text, colorClass, value, action = 'add') => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = `key-button flex-shrink-0 font-semibold m-1 text-sm rounded-md py-1.5 flex items-center justify-center ${colorClass}`;
                button.dataset.value = value !== undefined ? value : text;
                button.dataset.action = action;
                
                const buttonText = document.createElement('span');
                buttonText.textContent = text;
                button.appendChild(buttonText);

                const keyPop = document.createElement('span');
                keyPop.className = 'key-pop';
                keyPop.textContent = text;
                button.appendChild(keyPop);

                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const input = piecesAddressInput;
                    let currentValue = input ? input.value : '';
                    const act = button.dataset.action;
                    const val = button.dataset.value;

                    switch (act) {
                        case 'add': input.value = currentValue + val; break;
                        case 'add-space': input.value = currentValue + (currentValue.length > 0 && !/[-\s]$/.test(currentValue) ? ' ' : '') + val; break;
                        case 'add-unit': input.value = currentValue + val + ' '; break;
                        case 'add-comma': input.value = currentValue + (currentValue.length > 0 && !/\s$/.test(currentValue) ? '' : '') + ', '; break;
                        case 'add-hyphen': input.value = currentValue + '-'; break;
                        case 'backspace-char': input.value = currentValue.slice(0, -1); break;
                        case 'backspace-word':
                            const lastSpaceIndex = currentValue.trimEnd().lastIndexOf(' ');
                            input.value = lastSpaceIndex > -1 ? currentValue.substring(0, lastSpaceIndex).trimEnd() : '';
                            break;
                        default: input.value = currentValue + (val !== undefined ? val : act); break;
                    }
                    try { autoResizeTextarea({ target: input }); } catch (err) {}
                });
                return button;
            };

            const basePieces = (item.baseAddress_AI || item.baseAddress || '').split(/[\s,]+/).filter(Boolean);
            basePieces.forEach(piece => addressPiecesContainer.appendChild(createKeyButton(piece, 'bg-blue-100 text-blue-800 hover:bg-blue-200 dark:bg-blue-900/50 dark:text-blue-300 dark:hover:bg-blue-900 px-3 !py-1.5 rounded-full', undefined, 'add-space')));

            const detailAddressSource = typeof item.detailAddress_AI !== 'undefined' ? item.detailAddress_AI : item.detailAddress;
            if (detailAddressSource) {
                addressPiecesContainer.appendChild(createKeyButton(',', 'bg-gray-200 text-gray-800 hover:bg-gray-300 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500 px-3 !py-1.5 rounded-full', undefined, 'add-comma'));
                const detailPieces = (detailAddressSource || '').split(/[\s,]+/).filter(Boolean);
                detailPieces.forEach(piece => addressPiecesContainer.appendChild(createKeyButton(piece, 'bg-green-100 text-green-800 hover:bg-green-200 dark:bg-green-900/50 dark:text-green-300 dark:hover:bg-green-900 px-3 !py-1.5 rounded-full', undefined, 'add-space')));
            }

            ['1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '0', '-'].forEach(key => {
                let action = 'add';
                let colorClass = 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500';
                if (['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'].includes(key)) {
                    colorClass = 'bg-green-100 text-green-800 hover:bg-green-200 dark:bg-green-900/50 dark:text-green-300 dark:hover:bg-green-900';
                }
                if (key === ',') action = 'add-comma';
                if (key === '-') action = 'add-hyphen';
                numberKeypad.appendChild(createKeyButton(key, colorClass, key, action));
            });

            ['길', '번길', '동', '리'].forEach(unit => {
                unitKeypad.appendChild(createKeyButton(unit, 'bg-blue-100 hover:bg-blue-200 dark:bg-blue-900/50 dark:hover:bg-blue-900', unit, 'add-unit'));
            });
            unitKeypad.appendChild(createKeyButton('\u00A0', 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500', ' ', 'add'));
            unitKeypad.appendChild(createKeyButton('<', 'bg-gray-400 hover:bg-gray-500 text-white', '<', 'backspace-char'));
            const backspaceWordBtn = createKeyButton('<<', 'bg-red-500 hover:bg-red-600 text-white', '<<', 'backspace-word');
            backspaceWordBtn.classList.add('col-span-2');
            unitKeypad.appendChild(backspaceWordBtn);

            document.body.classList.add('modal-open');
            smartEditModal.style.display = 'flex';
            history.pushState({ smartEditModalOpen: true }, "");
        };

        const closeSmartEditModal = () => {
            if (history.state && history.state.smartEditModalOpen) {
                history.back();
            } else {
                document.body.classList.remove('modal-open');
                smartEditModal.style.display = 'none';
                currentEditItemNo = null;
            }
        };
        
        const applyAddressEdit = async (fullAddress) => {
            if (currentEditItemNo === null) return;
            
            showLoadingMessage('주소 검증 중...');

            const itemIndex = deliveryItems.findIndex(item => item.no === currentEditItemNo);
            if (itemIndex === -1) {
                closeConfirmationModal();
                showMessage('오류: 수정할 카드를 찾을 수 없습니다.');
                return;
            }

            const commaIndex = fullAddress.indexOf(',');
            let tempBaseAddress, tempDetailAddress;

            if (commaIndex > -1) {
                tempBaseAddress = fullAddress.substring(0, commaIndex).trim();
                tempDetailAddress = fullAddress.substring(commaIndex + 1).trim();
            } else {
                tempBaseAddress = fullAddress;
                tempDetailAddress = '';
            }

            const validationResult = await validateAddressWithKakao(tempBaseAddress, tempDetailAddress);
            closeConfirmationModal();

            const saveAddress = (base, detail, isValidated) => {
                deliveryItems[itemIndex].baseAddress = base;
                deliveryItems[itemIndex].detailAddress = detail;
                deliveryItems[itemIndex].addressLocation = null;
                deliveryItems[itemIndex].isAddressValidated = isValidated;
                saveDeliveryItemsToLocalStorage();
                renderDeliveryCards(activeFilter);
                closeSmartEditModal();
            };

            if (validationResult.validated) {
                saveAddress(validationResult.baseAddress, validationResult.detailAddress, true);
                showToastMessage('주소가 검증 및 저장되었습니다.');
            } else {
                const message = `카카오맵에서 주소를 찾을 수 없습니다. 입력하신 '${fullAddress}' 주소 그대로 저장하시겠습니까?`;
                openConfirmationModal(message, () => {
                    saveAddress(tempBaseAddress, tempDetailAddress, false);
                    showToastMessage('입력한 주소 그대로 저장되었습니다.');
                });
            }
        };
        
        applyPiecesBtn.addEventListener('click', async () => await applyAddressEdit(piecesAddressInput.value.trim()));
        applyDirectBtn.addEventListener('click', async () => await applyAddressEdit(directAddressInput.value.trim()));
        
        resetPiecesBtn.addEventListener('click', () => {
            piecesAddressInput.value = '';
            autoResizeTextarea({target: piecesAddressInput});
        });
        
        revertDirectBtn.addEventListener('click', () => {
            const item = deliveryItems.find(i => i.no === currentEditItemNo);
            if(item) {
                const originalBase = typeof item.baseAddress_AI !== 'undefined' ? item.baseAddress_AI : item.baseAddress;
                const originalDetail = typeof item.detailAddress_AI !== 'undefined' ? item.detailAddress_AI : item.detailAddress;
                directAddressInput.value = originalBase + (originalDetail ? `, ${originalDetail}` : '');
                autoResizeTextarea({target: directAddressInput});
            }
        });

        const resetDirectBtn = document.getElementById('reset-direct-btn');
        resetDirectBtn.addEventListener('click', () => {
            directAddressInput.value = '';
            autoResizeTextarea({target: directAddressInput});
        });
        
        smartEditExitBtn.addEventListener('click', closeSmartEditModal);
        piecesAddressInput.addEventListener('input', autoResizeTextarea);
        directAddressInput.addEventListener('input', autoResizeTextarea);
        confirmOkButton.addEventListener('click', () => { if (onConfirmCallback) onConfirmCallback(); closeConfirmationModal(); });
        confirmCancelButton.addEventListener('click', closeConfirmationModal);
        clearSignatureBtn.addEventListener('click', () => signatureTextInput.value = '');
        cancelSignatureBtn.addEventListener('click', closeSignatureModal);
        saveSignatureBtn.addEventListener('click', saveSignature);

        const saveDeliveryItemsToLocalStorage = () => {
            localStorage.setItem('deliveryItems', JSON.stringify(deliveryItems));
            localStorage.setItem('filterScrollPositions', JSON.stringify(filterScrollPositions));
        };

        const handleStatusChange = (itemNo, newStatus, completionTime = null, completionType = null, completionDetail = null) => {
            deliveryItems = deliveryItems.map(item => {
                if (item.no === itemNo) {
                    const updatedItem = { ...item, status: newStatus, isHawbConfirmed: newStatus !== '배송전' };
                    if (completionTime !== null) updatedItem.deliveryCompletionTime = completionTime;
                    if (completionType !== null) updatedItem.completionType = completionType;
                    if (completionDetail !== null) updatedItem.completionDetail = completionDetail;
                    return updatedItem;
                }
                return item;
            });
            saveDeliveryItemsToLocalStorage();
            renderDeliveryCards(activeFilter);
            updateFilterCounts();
        };

        const handleCheckboxToggleAndResetSearch = async (itemNo, newCheckboxState) => {
            const checkbox = document.querySelector(`input[data-action="toggle-hawb-confirm"][data-no="${itemNo}"]`);
            if (!checkbox) return;

            const itemIndex = deliveryItems.findIndex(item => item.no === itemNo);
            if (itemIndex === -1) return;

            if (newCheckboxState) {
                deliveryItems[itemIndex].isHawbConfirmed = true;
                deliveryItems[itemIndex].status = '배송중';
                
                saveDeliveryItemsToLocalStorage();
                searchTerm = '';
                invoiceNumberInput.value = '';
                renderDeliveryCards(activeFilter);
                updateFilterCounts();
                collapseSearch();

                if (!deliveryItems[itemIndex].addressLocation) {
                    try {
                        const coords = await getCoordsFromAddress(deliveryItems[itemIndex].baseAddress);
                        deliveryItems[itemIndex].addressLocation = coords;
                        saveDeliveryItemsToLocalStorage();
                        showToastMessage(`${itemNo}번 체크인 완료 (좌표 저장 성공)`);
                    } catch (error) {
                        console.error(`좌표 획득 실패 (항목 ${itemNo}):`, error.message);
                        showToastMessage(`${itemNo}번 체크인 완료 (좌표 저장 실패)`, 2500);
                    }
                } else {
                    showToastMessage(`${itemNo}번 체크인 완료 (좌표 이미 존재)`);
                }

            } else {
                deliveryItems[itemIndex].isHawbConfirmed = false;
                deliveryItems[itemIndex].status = '배송전';
                deliveryItems[itemIndex].addressLocation = null;
                delete deliveryItems[itemIndex].distanceFromMe;
                
                saveDeliveryItemsToLocalStorage();
                searchTerm = '';
                invoiceNumberInput.value = '';
                renderDeliveryCards(activeFilter);
                updateFilterCounts();
                showToastMessage('체크인이 취소되었습니다.');
            }
        };
        
        const openMap = (item) => {
            const selectedMap = localStorage.getItem('selectedMap') || 'naver';
            const addressForMapSearch = item.baseAddress || '';
            const textToCopy = `${item.no}. ${extractClipboardAddressPart(item)}`;

            navigator.clipboard.writeText(textToCopy).catch(err => {
                console.error('클립보드 복사 실패:', err);
                showMessage('클립보드 복사에 실패했습니다.', '복사 실패');
            });

            let mapUrl = selectedMap === 'naver'
                ? `nmap://search?query=${encodeURIComponent(addressForMapSearch)}&appname=DeliveryApp`
                : `kakaomap://search?q=${encodeURIComponent(addressForMapSearch)}`;
            window.location.href = mapUrl;
        };

        const highlightHawbNo = (hawbNo, term) => {
            if (!hawbNo) return '';
            const formattedHawbNo = formatHawbNoForDisplay(hawbNo);
            if (!term || !formattedHawbNo.toLowerCase().includes(term.toLowerCase())) return formattedHawbNo;
            const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(${escapedTerm})`, 'gi');
            // ▼▼▼ [수정] 다크모드용 하이라이트 배경색(dark:bg-yellow-500/50) 추가 ▼▼▼
            return formattedHawbNo.replace(regex, `<span class="bg-yellow-200 dark:bg-yellow-500/50 rounded px-0.5">$1</span>`);
        };
        
        const renderDeliveryCards = (currentFilter, animationClass = '') => {
            if (currentFilter === '배송준비') { deliveryCardsContainer.innerHTML = ''; return; }

            let baseData = currentFilter !== '전체'
                ? deliveryItems.filter(item => item.status === currentFilter)
                : [...deliveryItems];

            let dataToRender = searchTerm
                ? baseData.filter(item => {
                    const cleanedSearchTerm = searchTerm.trim().replace(/[\s-]/g, '').toLowerCase();
                    const hawbMatch = item.hawbNo?.replace(/[\s-]/g, '').toLowerCase().includes(cleanedSearchTerm);
                    const phoneMatch = item.receiverTelephoneNo?.includes(cleanedSearchTerm);
                    return hawbMatch || phoneMatch;
                })
                : baseData;
            
            if (dataToRender.length === 0) {
                // ▼▼▼ [수정] 다크모드용 텍스트 색상(dark:text-gray-400) 추가 ▼▼▼
                deliveryCardsContainer.innerHTML = '<p class="text-center text-gray-600 dark:text-gray-400 px-4">해당하는 항목이 없습니다.</p>';
                return;
            }

            deliveryCardsContainer.innerHTML = dataToRender.map(data => {
                const selectedMap = localStorage.getItem('selectedMap') || 'naver';
                const mapButtonClass = selectedMap === 'naver' ? 'naver' : 'kakao';
                const isPhoneNumberInvalid = !isValidPhoneNumber(data.receiverTelephoneNo);
                const fullAddress = data.baseAddress + (data.detailAddress ? `, ${data.detailAddress}` : '');
                const isMapButtonActive = isValidAddressForMap(data.baseAddress) && ['전체', '배송전', '배송중'].includes(currentFilter);
                const distanceInfo = (currentSortOrder === 'distance' && data.distanceFromMe !== undefined && data.status === '배송중')
                    // ▼▼▼ [수정] 다크모드용 텍스트 색상(dark:text-purple-400) 추가 ▼▼▼
                    ? `<span class="block text-sm font-medium text-purple-600 dark:text-purple-400 -mt-1">(${data.distanceFromMe.toFixed(2)} km)</span>`
                    : '';
                
                let cardClasses = '';
                // ▼▼▼ [수정] 다크모드용 테두리 색상(dark:border-...) 추가 ▼▼▼
                let headerBorder = 'border-gray-200 dark:border-gray-600';
                let actionBorder = 'border-gray-200 dark:border-gray-600';

                if (data.status === '배송전') {
                    // ▼▼▼ [수정] 다크모드용 배경/테두리 색상 추가 ▼▼▼
                    cardClasses = 'bg-white dark:bg-gray-800 rounded-t-3xl rounded-bl-3xl border-2 border-gray-600 dark:border-gray-500';
                } else if (data.status === '배송중') {
                    // ▼▼▼ [수정] 다크모드용 배경/테두리 색상 추가 ▼▼▼
                    cardClasses = 'bg-blue-50 dark:bg-blue-900/30 rounded-t-3xl rounded-bl-3xl border-2 border-blue-600 dark:border-blue-500';
                    headerBorder = 'border-blue-200 dark:border-blue-700';
                    actionBorder = 'border-blue-200 dark:border-blue-700';
                } else if (data.status === '완료') {
                    // ▼▼▼ [수정] 다크모드용 배경/테두리 색상 추가 ▼▼▼
                    cardClasses = 'bg-gray-200 dark:bg-gray-700 rounded-t-3xl rounded-bl-3xl border-2 border-gray-300 dark:border-gray-600';
                }

                const showCompletedCard = !['전체', '배송전', '배송중'].includes(currentFilter) && data.status === '완료';
                const showInProgressButtons = !['전체', '배송전', '완료'].includes(currentFilter) && data.status === '배송중';

                const detailsHtml = `
                    <div class="flex items-start space-x-2.5">
                        <button data-action="open-map" data-no="${data.no}" class="map-icon-button rounded-full flex items-center justify-center ${mapButtonClass} ${isMapButtonActive ? '' : 'opacity-50 cursor-not-allowed'}" ${isMapButtonActive ? '' : 'disabled'}>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 22a1 1 0 0 1-1-1v-4a1 1 0 0 1 .445-.832l3-2a1 1 0 0 1 1.11 0l3 2A1 1 0 0 1 22 17v4a1 1 0 0 1-1 1z"/><path d="M18 10a8 8 0 0 0-16 0c0 4.993 5.539 10.193 7.399 11.799a1 1 0 0 0 .601.2"/><path d="M18 22v-3"/><circle cx="10" cy="10" r="3"/></svg>
                        </button>
                        <div class="pt-0.5">
                            <p class="text-base font-semibold ${currentFilter !== '배송중' ? 'cursor-pointer' : ''} ${data.isAddressValidated === false ? 'text-red-500 dark:text-red-400' : 'text-blue-600 dark:text-blue-400'}"
                               ${currentFilter !== '배송중' ? `data-action="open-smart-edit" data-no="${data.no}"` : ''}>
                                ${fullAddress.trim() ? fullAddress : '<span class="text-red-500 dark:text-red-400 cursor-pointer underline font-medium">[주소 없음 (터치하여 입력)]</span>'}
                            </p>
                            ${data.receiverAddressOriginal ? `<p class="text-xs text-gray-500 dark:text-gray-400">(${data.receiverAddressOriginal})</p>` : ''}
                        </div>
                    </div>
                    <div class="flex items-start space-x-2.5">
                        <div class="flex-shrink-0 pt-1 text-gray-500 dark:text-gray-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z"/><path d="M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2"/><path d="M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2"/><path d="M10 6h4"/><path d="M10 10h4"/><path d="M10 14h4"/><path d="M10 18h4"/></svg>
                        </div>
                        <div>
                            <p class="text-base text-blue-600 dark:text-blue-400 font-semibold">${data.companyNameKorean || 'N/A'}</p>
                            ${data.companyNameOriginal && data.companyNameOriginal !== data.companyNameKorean ? `<p class="text-xs text-gray-500 dark:text-gray-400">(${data.companyNameOriginal})</p>` : ''}
                        </div>
                    </div>
                    <div class="flex items-start space-x-2.5">
                        <div class="flex-shrink-0 pt-1 text-gray-500 dark:text-gray-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><path d="M16 3.128a4 4 0 0 1 0 7.744"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><circle cx="9" cy="7" r="4"/></svg>
                        </div>
                        <div>
                            <div class="flex items-center space-x-2">
                                <p class="text-base text-blue-600 dark:text-blue-400 font-semibold">${data.receiverNameKorean || 'N/A'}</p>
                                <button data-action="swap-name" data-no="${data.no}" class="p-1 text-gray-400 dark:text-gray-500 rounded-full">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>
                                </button>
                            </div>
                            ${data.receiverNameOriginal && data.receiverNameOriginal !== data.receiverNameKorean ? `<p class="text-xs text-gray-500 dark:text-gray-400">(${data.receiverNameOriginal})</p>` : ''}
                        </div>
                    </div>
                    <div class="flex items-start space-x-2.5">
                        <div class="flex-shrink-0 pt-1 text-gray-500 dark:text-gray-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="20" x="5" y="2" rx="2" ry="2"/><path d="M12 18h.01"/></svg>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-base font-semibold cursor-pointer ${isPhoneNumberInvalid || !data.receiverTelephoneNo ? 'text-red-500 dark:text-red-400 underline' : 'text-blue-600 dark:text-blue-400'}"
                                  data-action="edit-phone" data-no="${data.no}">
                                ${data.receiverTelephoneNo ? formatPhoneNumberForDisplay(data.receiverTelephoneNo) : '[번호 없음 (터치하여 입력)]'}
                            </span>
                            <a href="tel:${getCleanPhoneNumber(data.receiverTelephoneNo)}" class="px-3 py-1.5 rounded-full bg-transparent text-orange-500 border border-orange-500 hover:bg-orange-100 dark:text-orange-400 dark:border-orange-400 dark:hover:bg-orange-900/30 ${!data.receiverTelephoneNo ? 'hidden' : ''}">전화</a>
                            <a href="sms:${getCleanPhoneNumber(data.receiverTelephoneNo)}" class="px-3 py-1.5 rounded-full bg-transparent text-blue-500 border border-blue-500 hover:bg-blue-100 dark:text-blue-400 dark:border-blue-400 dark:hover:bg-blue-900/30 ${!data.receiverTelephoneNo ? 'hidden' : ''}">문자</a>
                        </div>
                    </div>
                    ${data.status === '완료' ? `<div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-600 flex justify-center"><button data-action="revert-delivery" data-no="${data.no}" class="px-4 py-2 rounded-md bg-red-500 text-white text-sm font-medium">되돌리기</button></div>` : ''}
                `;

                if (showCompletedCard) {
                    const isEditableText = ['본인전달', '직접입력'].includes(data.completionType);
                    const isSelectableLocation = !isEditableText && data.completionType !== '서명';

                    const completionDisplayHtml = data.completionType === '서명' && data.completionDetail 
                        ? `<span class="text-lg font-semibold text-gray-800 dark:text-gray-200 p-1 border border-dashed border-gray-400 dark:border-gray-500 rounded-md bg-gray-50 dark:bg-gray-600 inline-block">${data.completionDetail}</span>`
                        : (isEditableText || isSelectableLocation)
                            ? `<span data-action="edit-completion-detail" data-no="${data.no}" class="text-lg font-semibold text-gray-800 dark:text-gray-200 cursor-pointer">${data.completionType === '본인전달' ? (data.receiverNameKorean || '') : data.completionDetail}</span>`
                            : `<span class="text-lg font-semibold text-gray-800 dark:text-gray-200">${data.completionDetail || data.completionType}</span>`;

                    return `
                        <div class="${cardClasses} p-4 mb-4" data-no="${data.no}">
                            <div class="flex justify-between items-center">
                                <div class="text-xl font-semibold text-gray-700 dark:text-gray-300 text-left flex items-center ${data.isStruckThrough ? 'completed-strikethrough' : ''}">
                                    <span data-action="copy-completion" data-no="${data.no}" class="text-red-500 dark:text-red-400 text-2xl mr-4 cursor-pointer">${data.no}</span>
                                    ${completionDisplayHtml}
                                    <span data-action="edit-completion-time" data-no="${data.no}" class="ml-2 cursor-pointer">${formatCompletionTime(data.deliveryCompletionTime)}</span>
                                </div>
                                <button data-action="toggle-details" data-no="${data.no}" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-600 flex-shrink-0">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-600 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                                    </svg>
                                </button>
                            </div>
                            <div class="space-y-3 mt-4 pt-4 border-t border-gray-300 dark:border-gray-500" data-details-container="${data.no}" style="display:none;">
                                ${detailsHtml}
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="${cardClasses} p-6 mb-4" data-no="${data.no}">
                            <div class="flex justify-between items-start mb-4 pb-2 border-b ${headerBorder}">
                                <div class="flex justify-between items-start w-full">
                                    <div class="flex items-start space-x-4">
                                        <div>
                                            <h3 class="text-3xl font-semibold text-red-500 dark:text-red-400">${data.no}</h3>
                                            ${distanceInfo}
                                        </div>
                                        <div class="pt-1.5">
                                            <span data-action="copy-hawb" data-hawb-no="${data.hawbNo}" data-no="${data.no}" class="text-base font-bold text-gray-600 dark:text-gray-300 whitespace-nowrap">${highlightHawbNo(data.hawbNo, searchTerm)}</span>
                                        </div>
                                    </div>
                                    <div class="pt-1.5">
                                        <input type="checkbox" data-action="toggle-hawb-confirm" data-no="${data.no}" ${data.isHawbConfirmed ? 'checked' : ''} class="form-checkbox h-4 w-4 text-blue-600 border-gray-300 dark:border-gray-500 rounded ml-2"/>
                                    </div>
                                </div>
                            </div>
                            <div class="space-y-3" data-details-container="${data.no}">
                                ${detailsHtml}
                            </div>
                            ${showInProgressButtons ? `
                                <div class="mt-4 pt-4 border-t ${actionBorder} flex justify-between space-x-2 w-full">
                                    <button data-action="identity-verification" data-no="${data.no}" class="flex-1 px-3 py-2 rounded-lg bg-green-500 text-white text-sm font-semibold hover:bg-green-600 transition-colors">본인전달</button>
                                    <button data-action="open-location-modal" data-no="${data.no}" class="flex-1 px-3 py-2 rounded-lg bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition-colors">배송위치</button>
                                    <button data-action="sign-delivery" data-no="${data.no}" class="flex-1 px-3 py-2 rounded-lg bg-indigo-500 text-white text-sm font-semibold hover:bg-indigo-600 transition-colors">직접입력</button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            }).join('');
        
            if (animationClass) {
                deliveryCardsContainer.classList.remove('animate-slide-in-left', 'animate-slide-in-right');
                void deliveryCardsContainer.offsetWidth;
                deliveryCardsContainer.classList.add(animationClass);
            }
        };

    const updateFilterCounts = () => {
        const counts = {
            '전체': deliveryItems.length,
            '배송전': deliveryItems.filter(item => item.status === '배송전').length,
            '배송중': deliveryItems.filter(item => item.status === '배송중').length,
            '완료': deliveryItems.filter(item => item.status === '완료').length
        };

        for (const filter in counts) {
            const countElement = document.getElementById(`count-${filter}`);
            if (countElement) {
                const count = counts[filter];
                countElement.textContent = count > 99 ? '99+' : count;
                countElement.classList.toggle('hidden', count === 0);
            }
        }
    };
    
    const updateStickyHeaderPositions = () => {
        requestAnimationFrame(() => {
            const isScanVisible = activeFilter === '배송준비';
            scanSectionContainer.classList.toggle('hidden', !isScanVisible);
            dataManagementContainer.classList.toggle('hidden', !isScanVisible);
            versionInfoContainer.classList.toggle('hidden', !isScanVisible); 

            if (['전체', '배송전'].includes(activeFilter)) {
                searchBarContainer.style.display = 'block';
                actionBarContainer.style.display = 'none';
            } else if (['배송중', '완료'].includes(activeFilter)) {
                searchBarContainer.style.display = 'none';
                actionBarContainer.style.display = 'block';
                setupFab();
            } else {
                searchBarContainer.style.display = 'none';
                actionBarContainer.style.display = 'none';
            }
        });
    };
    
    const setupFab = () => {
        if (activeFilter !== '배송중' && activeFilter !== '완료') return;

        const fabMainButton = document.getElementById('fab-main-button');
        const fabOptions = document.getElementById('fab-options');

        // 1. 기존 아이콘들을 확실하게 제거하여 겹침 현상을 원천 방지합니다.
        while (fabOptions.firstChild) {
            fabOptions.removeChild(fabOptions.firstChild);
        }
        while (fabMainButton.firstChild) {
            fabMainButton.removeChild(fabMainButton.firstChild);
        }

        let allMenuItems = [];
        let currentSortType = '';
        let activeColorClass = '';

        // ▼▼▼ [수정] 보내주신 새 아이콘 SVG 코드로 교체 ▼▼▼
        // 배송중 필터 아이콘
        const iconJump = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5h10"/><path d="M11 12h10"/><path d="M11 19h10"/><path d="M4 4h1v5"/><path d="M4 9h2"/><path d="M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02"/></svg>`;
        const iconSortDistance = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="2" x2="5" y1="12" y2="12"/><line x1="19" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="5"/><line x1="12" x2="12" y1="19" y2="22"/><circle cx="12" cy="12" r="7"/></svg>`;
        const iconSortNo = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 16 4 4 4-4"/><path d="M7 20V4"/><rect x="15" y="4" width="4" height="6" ry="2"/><path d="M17 20v-6h-2"/><path d="M15 20h4"/></svg>`;
        
        // 완료 필터 아이콘
        const iconSortTime = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 6v6l4 2"/><circle cx="12" cy="12" r="10"/></svg>`;

        if (activeFilter === '배송중') {
            allMenuItems = [
                // '카드선택(순번선택)'은 정렬 상태가 아니므로 'action' 타입으로 지정
                { icon: iconJump, action: 'jump-no', type: 'action' }, 
                // '순번순정렬'은 정렬 상태이므로 'sort' 타입으로 지정
                { icon: iconSortNo, action: 'sort-no', sortType: 'no', type: 'sort' },
                // '거리순정렬'은 정렬 상태이므로 'sort' 타입으로 지정
                { icon: iconSortDistance, action: 'sort-distance', sortType: 'distance', type: 'sort' }
            ];
            currentSortType = deliveryInProgressSortOrder;
            activeColorClass = 'bg-blue-600 text-white';
        } else if (activeFilter === '완료') {
            allMenuItems = [
                // '순번순정렬'은 정렬 상태이므로 'sort' 타입으로 지정
                { icon: iconSortNo, action: 'sort-no-completed', sortType: 'no', type: 'sort' },
                // '완료시간순 정렬'은 정렬 상태이므로 'sort' 타입으로 지정
                { icon: iconSortTime, action: 'sort-time', sortType: 'time', type: 'sort' }
            ];
            currentSortType = completedSortOrder;
            activeColorClass = 'bg-gray-800 text-white dark:bg-gray-200 dark:text-gray-800';
        }

        // 2. 메인 버튼에 표시할 '정렬 아이콘'을 명확하게 찾습니다.
        // 'sort' 타입 중에서 현재 정렬 상태와 일치하는 것을 찾고, 없으면 첫 번째 'sort' 타입을 기본값으로 합니다.
        const sortItems = allMenuItems.filter(item => item.type === 'sort');
        let activeSortItem = sortItems.find(item => item.sortType === currentSortType) || sortItems[0];

        // 3. 메인 FAB 버튼에는 위에서 찾은 '정렬 아이콘' 하나만 표시합니다.
        if (activeSortItem) {
            fabMainButton.innerHTML = activeSortItem.icon;
        }
        fabMainButton.className = `w-10 h-10 flex-shrink-0 flex items-center justify-center rounded-full transition-colors duration-200 ${activeColorClass}`;
        fabMainButton.dataset.action = 'toggle-fab';

        // 4. 옵션 버튼 목록에는 메인 버튼에 표시된 것을 제외한 나머지 모든 아이템을 포함합니다.
        const optionItems = allMenuItems.filter(item => item !== activeSortItem);

        optionItems.forEach(item => {
            const button = document.createElement('button');
            button.className = 'w-10 h-10 flex-shrink-0 flex items-center justify-center rounded-full bg-white dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-600 shadow-md';
            button.innerHTML = item.icon;
            button.dataset.action = item.action;
            fabOptions.appendChild(button);
        });
    };
    const sortItemsByNumber = () => {
        deliveryInProgressSortOrder = 'no';
        currentSortOrder = 'no';
        deliveryItems.sort((a, b) => a.no - b.no);
        renderDeliveryCards(activeFilter);
        setupFab();
    };

    const sortItemsByDistanceSilent = async () => {
        if (activeFilter !== '배송중' || deliveryInProgressSortOrder !== 'distance') return;
        try {
            const myLocation = await getCurrentLocation(5000);
            const inProgressItems = deliveryItems.filter(item => item.status === '배송중');
            const otherItems = deliveryItems.filter(item => item.status !== '배송중');
            const itemsWithCoords = inProgressItems.filter(item => item.addressLocation);
            const itemsWithoutCoords = inProgressItems.filter(item => !item.addressLocation);
            
            itemsWithCoords.forEach(item => { item.distanceFromMe = calculateDistance(myLocation, item.addressLocation); });
            itemsWithCoords.sort((a, b) => a.distanceFromMe - b.distanceFromMe);
            
            deliveryItems = [...itemsWithCoords, ...itemsWithoutCoords, ...otherItems];
            renderDeliveryCards(activeFilter);
            console.log('자동 거리순 정렬 완료.');
        } catch (error) {
            console.log('자동 정렬 실패 (GPS 신호 없음):', error.message);
        }
    };

    const sortItemsByDistance = async (silent = false) => {
        // ... (이전 함수 내용)
    };

    /*
      ▼▼▼ [추가] Tailwind JIT 컴파일러를 위한 주석 ▼▼▼
      이 주석은 JavaScript 변수 안에 있는 클래스 이름을
      Tailwind가 빌드 시 인식하여 최종 CSS에 포함시키도록 하는 역할을 합니다.
      
      필터 버튼 활성 클래스:
      bg-blue-100 dark:bg-blue-900/50 text-blue-600 dark:text-blue-400

      필터 버튼 비활성 클래스:
      bg-transparent text-gray-500 dark:text-gray-400
    */
    const changeFilter = (newFilter, animationClass = '', isInitialLoad = false) => {
        if (newFilter === activeFilter && !isInitialLoad) return;

        collapseSearch();
        const fabOptions = document.getElementById('fab-options');
        if (fabOptions) fabOptions.classList.remove('expanded');
        if (!isInitialLoad) {
            searchTerm = '';
            invoiceNumberInput.value = '';
        }

        const mainContentWrapper = document.getElementById('main-content-wrapper');
        filterScrollPositions[activeFilter] = mainContentWrapper.scrollTop;
        activeFilter = newFilter;

        if (newFilter === '배송중') {
            currentSortOrder = deliveryInProgressSortOrder;
            if (deliveryInProgressSortOrder === 'distance') {
                const itemsWithDistance = deliveryItems.filter(item => item.distanceFromMe !== undefined);
                const itemsWithoutDistance = deliveryItems.filter(item => item.distanceFromMe === undefined);
                itemsWithDistance.sort((a, b) => a.distanceFromMe - b.distanceFromMe);
                deliveryItems = [...itemsWithDistance, ...itemsWithoutDistance];
            } else { 
                deliveryItems.sort((a, b) => a.no - b.no);
            }
        } else if (newFilter === '완료') {
            currentSortOrder = completedSortOrder;
            if (completedSortOrder === 'time') {
                const completedItems = deliveryItems.filter(item => item.status === '완료');
                const otherItems = deliveryItems.filter(item => item.status !== '완료');
                completedItems.sort((a, b) => {
                    if (!a.deliveryCompletionTime) return 1;
                    if (!b.deliveryCompletionTime) return -1;
                    return a.deliveryCompletionTime.localeCompare(b.deliveryCompletionTime);
                });
                deliveryItems = [...completedItems, ...otherItems];
            } else { 
                deliveryItems.sort((a, b) => a.no - b.no);
            }
        } else { 
            currentSortOrder = 'no';
            deliveryItems.sort((a, b) => a.no - b.no);
        }

        filterButtonsContainer.querySelectorAll('button[data-filter]').forEach(btn => {
            const svg = btn.querySelector('svg');
            const isActive = btn.dataset.filter === newFilter;
            
            const baseClasses = 'relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors';
            const activeClasses = 'bg-blue-100 dark:bg-blue-900/50 text-blue-600 dark:text-blue-400';
            const inactiveClasses = 'bg-transparent text-gray-500 dark:text-gray-400';

            btn.className = `${baseClasses} ${isActive ? activeClasses : inactiveClasses}`;
        });
        
        renderDeliveryCards(newFilter, animationClass);
        updateStickyHeaderPositions();

        const button = filterButtonsContainer.querySelector(`button[data-filter="${newFilter}"]`);
        if (button) button.scrollIntoView({ behavior: 'smooth', inline: 'center' });
        
        setTimeout(() => {
            mainContentWrapper.scrollTo({ top: filterScrollPositions[newFilter] || 0, behavior: 'auto' });
        }, 0);
    };

    filterButtonsContainer.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-filter]');
        if (!button) return;
        const newFilter = button.dataset.filter;
        
        const oldIndex = filterCategories.indexOf(activeFilter);
        const newIndex = filterCategories.indexOf(newFilter);
        const animation = newIndex > oldIndex ? 'animate-slide-in-right' : 'animate-slide-in-left';

        changeFilter(newFilter, animation);
    });

    invoiceNumberInput.addEventListener('input', (event) => {
        searchTerm = event.target.value.trim();
        renderDeliveryCards(activeFilter);
        document.getElementById('main-content-wrapper').scrollTo({ top: 0, behavior: 'auto' });
        filterScrollPositions[activeFilter] = 0;
    });

    resetButton.addEventListener('click', () => {
        searchTerm = '';
        invoiceNumberInput.value = '';
        renderDeliveryCards(activeFilter);
    });

    const collapseSearch = () => {
        searchTerm = '';
        invoiceNumberInput.value = '';
    };

    document.addEventListener('click', (event) => {
        const clickedElement = event.target;
        const fabPanel = document.getElementById('fab-panel');
        if (!fabPanel.contains(clickedElement)) {
            document.getElementById('fab-options').classList.remove('expanded');
        }
    });

    deliverySheetImageInput.addEventListener('change', (event) => {
        currentFileToScan = event.target.files;
        selectedFilesDisplay.textContent = currentFileToScan.length > 0 ? `선택된 파일: ${Array.from(currentFileToScan).map(f => f.name).join(', ')}` : '선택된 파일 없음';
    });

    async function performScan(filesToScan) {
        const CONCURRENT_LIMIT = 4;
        const totalFiles = filesToScan.length;
        let completedCount = 0;

        scanProgressText.textContent = `이미지 리사이징 중 (0/${totalFiles})...`;
        const resizePromises = filesToScan.map((file, index) => 
            resizeImage(file).then(resizedObject => {
                scanProgressText.textContent = `이미지 리사이징 중 (${index + 1}/${totalFiles})...`;
                return resizedObject;
            })
        );
        const resizedImageObjects = await Promise.all(resizePromises);
        scanProgressText.textContent = `리사이징 완료, API 요청 시작...`;
        
        const tempMergedResults = new Map();
        const failedFileObjectsForRetry = [];
        const requestQueue = [...resizedImageObjects]; 

        const updateApiProgress = () => {
            completedCount++;
            scanProgressText.textContent = `API 처리 중 (${completedCount}/${totalFiles})...`;
        };

        const processApiRequest = async (resizedObject) => {
            const { file, data: base64ImageData } = resizedObject;
            let lastError = null;

            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: GEMINI_PROMPT }, { inlineData: { mimeType: 'image/jpeg', data: base64ImageData } }] }],
                        generationConfig: { temperature: 0, responseMimeType: "application/json" }
                    };
                    const tempApiKeyForLocalTest = "AIzaSyD8ZGE4WyIGatmPzRkJijnOt8PqtnLFyds";
                    const directApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${tempApiKeyForLocalTest}`;

                    const response = await fetch(directApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) { throw new Error(`API 요청 실패 (상태: ${response.status})`); }
                    
                    const result = await response.json();

                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        const parsedData = JSON.parse(result.candidates[0].content.parts[0].text);
                        if (Array.isArray(parsedData) && parsedData.length > 0) {
                             return parsedData;
                        }
                    }
                    throw new Error("AI가 유효한 배열 형식으로 응답하지 않았습니다.");
                } catch (error) {
                    lastError = error;
                    console.warn(`파일(${file.name}) 처리 시도 ${attempt} 실패:`, error);
                    if (attempt < 3) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
            }
            throw lastError;
        };
        
        const worker = async () => {
            while (requestQueue.length > 0) {
                const requestObject = requestQueue.shift(); 
                if (requestObject) {
                    try {
                        const apiResultArray = await processApiRequest(requestObject);
                        for (const geminiItem of apiResultArray) {
                            const no = parseInt(geminiItem.no || '0', 10);
                            if (no === 0) continue;
                            
                            if (geminiItem.baseAddressKorean && geminiItem.detailAddressKorean) {
                                geminiItem.detailAddressKorean = geminiItem.detailAddressKorean.replace(/,/g, ' ');
                            }

                            const validationResult = await validateAddressWithKakao(geminiItem.baseAddressKorean, geminiItem.detailAddressKorean);
                            geminiItem.baseAddressKorean = validationResult.baseAddress;
                            geminiItem.detailAddressKorean = validationResult.detailAddress;
                            geminiItem.isAddressValidated = validationResult.validated;

                            tempMergedResults.set(no, geminiItem);
                        }
                    } catch (error) {
                        console.error(`파일 스캔 오류 (${requestObject.file.name}):`, error);
                        failedFileObjectsForRetry.push(requestObject.file);
                    } finally {
                        updateApiProgress();
                    }
                }
            }
        };

        const workerPromises = Array.from({ length: CONCURRENT_LIMIT }, () => worker());
        await Promise.all(workerPromises);

        let newCount = 0;
        let updateCount = 0;
        const allNewItems = Array.from(tempMergedResults.values()); 

        if (allNewItems.length > 0) {
            const finalItems = allNewItems.map(item => ({
                no: parseInt(item.no, 10),
                hawbNo: item.hawbNo || '',
                baseAddress: item.baseAddressKorean || '',
                detailAddress: item.detailAddressKorean || '',
                baseAddress_AI: item.baseAddressKorean || '',
                detailAddress_AI: item.detailAddressKorean || '',
                receiverAddressOriginal: item.receiverAddress || '',
                companyNameOriginal: item.receiverCompanyName || '',
                receiverNameOriginal: item.receiverName || '',
                companyNameKorean: item.receiverCompanyNameKorean || item.receiverCompanyName || '',
                receiverNameKorean: item.receiverNameKorean || item.receiverName || '',
                receiverNameKoreanOriginal: item.receiverNameKorean || item.receiverName || '',
                receiverTelephoneNo: item.receiverPhone ? getCleanPhoneNumber(item.receiverPhone) : '',
                status: '배송전', isHawbConfirmed: false,
                deliveryCompletionTime: null, completionType: null, completionDetail: null,
                addressLocation: null,
                isStruckThrough: false,
                isAddressValidated: item.isAddressValidated
            }));
            
            finalItems.forEach(newItem => {
                const existingItemIndex = deliveryItems.findIndex(item => item.no === newItem.no);
                if (existingItemIndex > -1) {
                    deliveryItems[existingItemIndex] = { ...deliveryItems[existingItemIndex], ...newItem };
                    updateCount++;
                } else {
                    deliveryItems.push(newItem);
                    newCount++;
                }
            });
            deliveryItems.sort((a, b) => a.no - b.no);
            saveDeliveryItemsToLocalStorage();
        }
        return { newCount, updateCount, failedFiles: failedFileObjectsForRetry };
    }
    
    scanAndGenerateButton.addEventListener('click', async () => {
        if (!currentFileToScan || currentFileToScan.length === 0) { showMessage('스캔할 이미지를 선택해주세요.'); return; }
        
        const startTime = Date.now();
        scanLoadingIndicator.style.display = 'block';
        scanErrorMessage.style.display = 'none';
        failedFileObjects = []; 

        try {
            const initialFiles = Array.from(currentFileToScan);
            const result = await performScan(initialFiles);
            const endTime = Date.now();
            const elapsedTime = Math.round((endTime - startTime) / 1000);
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;
            const timeString = `(소요 시간: ${minutes}분 ${seconds}초)`;

            if (result.failedFiles.length === 0) {
                showMessage(`${result.updateCount}개의 카드가 업데이트되고 ${result.newCount}개의 카드가 새로 생성되었습니다. ${timeString}`);
            } else {
                failedFileObjects = result.failedFiles;
                const successCount = initialFiles.length - failedFileObjects.length;
                const failedFileNames = failedFileObjects.map(f => f.name);
                
                const message = `총 ${initialFiles.length}개 중 ${successCount}개 파일 스캔 성공. ${timeString}\n\n실패한 ${failedFileObjects.length}개 파일을 다시 스캔하시겠습니까?\n- ${failedFileNames.join('\n- ')}`;

                const onRetry = async () => {
                    scanLoadingIndicator.style.display = 'block';
                    const retryResult = await performScan(failedFileObjects);
                    scanLoadingIndicator.style.display = 'none';

                    if (retryResult.failedFiles.length === 0) {
                        showMessage(`재시도 성공: ${retryResult.updateCount + retryResult.newCount}개의 카드가 추가/업데이트되었습니다.`);
                    } else {
                        const stillFailingNames = retryResult.failedFiles.map(f => f.name);
                        showMessage(`재시도 후에도 아래 ${stillFailingNames.length}개 파일이 실패했습니다.\n- ${stillFailingNames.join('\n- ')}`, '재시도 일부 실패');
                    }
                    renderDeliveryCards(activeFilter);
                    updateFilterCounts();
                };
                openConfirmationModal(message, onRetry, '실패 파일 재시도', '나중에');
            }
        } catch (error) {
            console.error("전체 스캔 프로세스 오류:", error);
            scanErrorText.textContent = error.message;
            scanErrorMessage.style.display = 'block';
        } finally {
            scanLoadingIndicator.style.display = 'none';
            deliverySheetImageInput.value = '';
            currentFileToScan = null;
            selectedFilesDisplay.textContent = '선택된 파일 없음';
            renderDeliveryCards(activeFilter);
            updateFilterCounts();
            updateStickyHeaderPositions();
        }
    });
    
    exportDataButton.addEventListener('click', () => {
        if (deliveryItems.length === 0) { showMessage("저장할 데이터가 없습니다."); return; }
        try {
            const today = new Date();
            const formattedDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            const fileName = `SF-${formattedDate}.json`;
            const dataStr = JSON.stringify(deliveryItems, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToastMessage(`데이터가 '${fileName}' 파일로 저장되었습니다.`);
        } catch (error) {
            showMessage(`데이터 저장 중 오류가 발생했습니다: ${error.message}`, "오류");
        }
    });

    importDataInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        openConfirmationModal( `'${file.name}' 파일의 데이터로 현재 목록을 모두 덮어씁니다. 계속하시겠습니까?`, () => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (!Array.isArray(importedData)) throw new Error("파일 형식이 올바르지 않습니다 (배열이 아님).");
                        
                        const firstItem = importedData[0];
                        if (importedData.length > 0 && typeof firstItem.no === 'undefined' && typeof firstItem.baseAddress === 'undefined') {
                           throw new Error("파일 내용이 올바른 배송 데이터 형식이 아닙니다.");
                        }
                        
                        deliveryItems = importedData;

                        saveDeliveryItemsToLocalStorage();
                        updateFilterCounts();
                        updateStickyHeaderPositions();
                        renderDeliveryCards(activeFilter);
                        showMessage(`'${file.name}' 파일에서 ${deliveryItems.length}개의 항목을 불러왔습니다.`);
                    } catch (error) {
                        showMessage(`파일을 불러오는 중 오류가 발생했습니다: ${error.message}`, "오류");
                    } finally {
                        importDataInput.value = '';
                    }
                };
                reader.onerror = () => { showMessage("파일을 읽는 데 실패했습니다.", "오류"); importDataInput.value = ''; };
                reader.readAsText(file);
            }
        );
    });

        document.addEventListener('DOMContentLoaded', () => {
            initializeTheme(); // <-- 테마 초기화 함수 호출

            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./service-worker.js').then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    }).catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
                });
            }
            
            if ('Notification' in window && Notification.permission === 'default') {
                setTimeout(() => { Notification.requestPermission(); }, 3000);
            }

            resizeAppContainer();
            window.addEventListener('resize', resizeAppContainer);
            setVersionInfo();
            setupDelegatedEventListeners();

            const mapSelectionContainer = document.getElementById('map-selection-container');
            const mapSelectButtons = mapSelectionContainer.querySelectorAll('.map-select-btn');

            const updateMapSelectionUI = () => {
                const selectedMap = localStorage.getItem('selectedMap') || 'naver';
                mapSelectButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.map === selectedMap);
                });
                if (['전체', '배송전', '배송중', '완료'].includes(activeFilter)) {
                    renderDeliveryCards(activeFilter);
                }
            };

            mapSelectionContainer.addEventListener('click', (event) => {
                const selectedButton = event.target.closest('.map-select-btn');
                if (selectedButton) {
                    const mapType = selectedButton.dataset.map;
                    localStorage.setItem('selectedMap', mapType);
                    updateMapSelectionUI();
                }
            });
            updateMapSelectionUI();

            // ▼▼▼ [수정] 새로운 테마 UI를 위한 이벤트 리스너 설정 ▼▼▼
    const lightBtn = document.getElementById('light-theme-btn');
    const darkBtn = document.getElementById('dark-theme-btn');
    const systemThemeToggle = document.getElementById('system-theme-toggle');

    if (lightBtn) {
        lightBtn.addEventListener('click', () => applyTheme('light'));
    }
    if (darkBtn) {
        darkBtn.addEventListener('click', () => applyTheme('dark'));
    }
    if (systemThemeToggle) {
        systemThemeToggle.addEventListener('change', (event) => {
            if (event.target.checked) {
                applyTheme('system');
            } else {
                // 시스템 모드를 끌 때, 현재 보이는 테마를 수동 선택한 것으로 간주
                const currentEffectiveTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
                applyTheme(currentEffectiveTheme);
            }
        });
    }
    // ▲▲▲ [수정 끝] ▲▲▲

            const barcodeScanButton = document.getElementById('barcode-scan-button');
            if (barcodeScanButton) {
                barcodeScanButton.addEventListener('click', () => {
                    const returnUrlFormat = `https://shoo2668.github.io/sf/?hawb={CODE}&filter=전체`;
                    const encodedReturnUrl = encodeURIComponent(returnUrlFormat);
                    const scannerUrl = `zxing://scan/?ret=${encodedReturnUrl}`;
                    showToastMessage('스캐너 앱을 실행합니다...', 1000);
                    window.location.href = scannerUrl;
                });
            }

            clearAllCardsButton.addEventListener('click', () => {
                openConfirmationModal("모든 카드를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.", () => {
                    deliveryItems = [];
                    saveDeliveryItemsToLocalStorage();
                    renderDeliveryCards(activeFilter);
                    updateFilterCounts();
                    showToastMessage("모든 카드가 삭제되었습니다.");
                });
            });

            locationModalCancel.addEventListener('click', closeDeliveryLocationModal);
            locationModalConfirm.addEventListener('click', () => {
                const selectedOption = document.querySelector('input[name="delivery-location"]:checked');
                if (!selectedOption) { showMessage('배송 위치를 선택해주세요.'); return; }

                let location = selectedOption.value;
                if (location === '기타') {
                    const otherInput = document.getElementById('other-location-input');
                    location = otherInput.value.trim();
                    if (!location) { showMessage('기타 배송 위치를 입력해주세요.'); return; }
                }

                const itemNo = currentLocationEditItemNo;
                const item = deliveryItems.find(i => i.no === itemNo);
                if (!item) return;

                let completionTime = null;
                const isNewCompletion = item.status !== '완료';
                if (isNewCompletion) completionTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
                
                handleStatusChange(itemNo, '완료', completionTime, location, location);
                sortItemsByDistanceSilent();
                closeDeliveryLocationModal();
                showToastMessage(`${itemNo}번: ${location} 완료`);

                if (isNewCompletion) {
                    const updatedItem = deliveryItems.find(i => i.no === itemNo);
                    if (updatedItem) sendCompletionNotification(updatedItem);

                    const cleanPhoneNumber = getCleanPhoneNumber(item.receiverTelephoneNo);
                    if (cleanPhoneNumber && cleanPhoneNumber.startsWith('010')) {
                        setTimeout(() => {
                            const messageBody = `SF택배 퀵배송 왔습니다. (${location})`;
                            window.location.href = `sms:${cleanPhoneNumber}?body=${encodeURIComponent(messageBody)}`;
                        }, 500);
                    }
                }
            });

            invoiceNumberInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') { event.preventDefault(); invoiceNumberInput.blur(); }
            });

            setTimeout(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const hawbFromUrl = urlParams.get('hawb');
                const filterFromUrl = urlParams.get('filter');

                if (hawbFromUrl) {
                    changeFilter('전체', '', true);
                    searchTerm = hawbFromUrl;
                    invoiceNumberInput.value = hawbFromUrl;
                    renderDeliveryCards('전체');
                } else {
                    if (filterFromUrl && filterCategories.includes(filterFromUrl)) {
                        changeFilter(filterFromUrl, '', true);
                    } else {
                        changeFilter('배송준비', '', true);
                    }
                }
            }, 0);

            const mainContent = document.getElementById('main-content-wrapper');
            refreshIndicator = document.getElementById('refresh-indicator');

            mainContent.addEventListener('touchstart', (e) => {
                if (mainContent.scrollTop === 0 && !isRefreshing && activeFilter === '배송중' && deliveryInProgressSortOrder === 'distance') {
                    pullStartY = e.touches[0].pageY;
                } else {
                    pullStartY = 0;
                }
            }, { passive: true });

            mainContent.addEventListener('touchmove', (e) => {
                if (pullStartY === 0 || isRefreshing) return;
                const pullDistance = e.touches[0].pageY - pullStartY;
                if (pullDistance > 0) {
                    const opacity = Math.min(pullDistance / 100, 1);
                    refreshIndicator.style.opacity = opacity;
                    refreshIndicator.style.transform = `translateY(${Math.min(pullDistance, 100) - 48}px)`;
                }
            }, { passive: true });

            mainContent.addEventListener('touchend', (e) => {
                if (pullStartY === 0 || isRefreshing) return;
                const pullDistance = e.changedTouches[0].pageY - pullStartY;
                
                const resetIndicator = () => {
                    refreshIndicator.classList.remove('visible');
                    refreshIndicator.style.opacity = 0;
                    refreshIndicator.style.transform = 'translateY(-100%)';
                };

                if (pullDistance > 100 && activeFilter === '배송중' && deliveryInProgressSortOrder === 'distance') {
                    isRefreshing = true;
                    refreshIndicator.classList.add('visible');
                    sortItemsByDistance(true).finally(() => {
                        isRefreshing = false;
                        pullStartY = 0;
                        resetIndicator();
                    });
                } else {
                    resetIndicator();
                }
            });

            let pullDownStartY = 0;
            document.body.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) pullDownStartY = e.touches[0].clientY;
            }, { passive: true });

            window.addEventListener('touchmove', (event) => {
                const touchY = event.touches[0].clientY;
                const isPullingDown = touchY > pullDownStartY;
                if (!isPullingDown) return;

                const mainContent = document.getElementById('main-content-wrapper');
                const smartEditScroll = document.getElementById('smart-edit-scroll-area');
                const numberJumpList = document.getElementById('number-jump-list');

                let scrollableElement = null;
                if (mainContent && mainContent.contains(event.target)) scrollableElement = mainContent;
                else if (smartEditScroll && smartEditScroll.contains(event.target)) scrollableElement = smartEditScroll;
                else if (numberJumpList && numberJumpList.contains(event.target)) scrollableElement = numberJumpList;

                // ▼▼▼ [수정] 이벤트가 취소 가능한 경우에만 preventDefault()를 호출하도록 변경 ▼▼▼
                if ((scrollableElement && scrollableElement.scrollTop === 0) || !scrollableElement) {
                    if (event.cancelable) {
                        event.preventDefault();
                    }
                }
            }, { passive: false });

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    justReturnedFromExternalApp = true;
                    setTimeout(() => { justReturnedFromExternalApp = false; }, 500);
                }
            });

            history.pushState(null, '', location.href);
            window.addEventListener('popstate', (event) => {
                if (smartEditModal.style.display === 'flex') {
                    document.body.classList.remove('modal-open');
                    smartEditModal.style.display = 'none';
                    currentEditItemNo = null;
                    return;
                }
                if (justReturnedFromExternalApp) {
                    justReturnedFromExternalApp = false;
                    history.pushState(null, '', location.href);
                    return;
                }
                if (backButtonPressedOnce) {
                    history.back(); 
                    return;
                }
                backButtonPressedOnce = true;
                showToastMessage('한 번 더 누르면 종료됩니다.', 2000);
                setTimeout(() => { backButtonPressedOnce = false; }, 2000);
                history.pushState(null, '', location.href);
            });

            document.body.addEventListener('touchstart', (event) => {
                const touch = event.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartTime = Date.now();
            }, { passive: true });

            let isSwiping = false;
            document.body.addEventListener('touchmove', () => {
                if (!isSwiping) {
                    filterButtonsContainer.querySelectorAll('button').forEach(btn => btn.style.pointerEvents = 'none');
                }
                isSwiping = true;
            }, { passive: true });

            document.body.addEventListener('touchend', (event) => {
                if (isSwiping) {
                    setTimeout(() => {
                        filterButtonsContainer.querySelectorAll('button').forEach(btn => btn.style.pointerEvents = 'auto');
                        isSwiping = false;
                    }, 100);
                }
                if (signatureModal.style.display === 'flex' || confirmationModal.style.display === 'flex' || smartEditModal.style.display === 'flex' || numberJumpModal.style.display === 'flex') {
                    return;
                }
                const touch = event.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                const duration = Date.now() - touchStartTime;
                if (duration > 500 || Math.abs(diffX) < 75 || Math.abs(diffX) < Math.abs(diffY) * 2) {
                    return;
                }
                const currentFilterIndex = filterCategories.indexOf(activeFilter);
                if (diffX > 0) {
                    if (currentFilterIndex > 0) {
                        const prevFilter = filterCategories[currentFilterIndex - 1];
                        changeFilter(prevFilter, 'animate-slide-in-left');
                    }
                } else {
                    if (currentFilterIndex < filterCategories.length - 1) {
                        const nextFilter = filterCategories[currentFilterIndex + 1];
                        changeFilter(nextFilter, 'animate-slide-in-right');
                    }
                }
            });

            actionBarContainer.addEventListener('click', async (event) => {
                const button = event.target.closest('button');
                if (!button) return;
                const action = button.dataset.action;
                if (!action) return;
                const fabOptions = document.getElementById('fab-options');
                if (action === 'toggle-fab') {
                    fabOptions.classList.toggle('expanded');
                    return;
                }
                if (button.parentNode.id === 'fab-options') {
                    fabOptions.classList.remove('expanded');
                    if (action === 'sort-distance') deliveryInProgressSortOrder = 'distance';
                    else if (action === 'sort-no') deliveryInProgressSortOrder = 'no';
                    else if (action === 'sort-time') completedSortOrder = 'time';
                    else if (action === 'sort-no-completed') completedSortOrder = 'no';
                }
                switch (action) {
                    case 'sort-distance': sortItemsByDistance(); break;
                    case 'sort-no': sortItemsByNumber(); showToastMessage('순번순으로 정렬되었습니다.'); break;
                    case 'sort-no-completed':
                        completedSortOrder = 'no';
                        currentSortOrder = 'no';
                        deliveryItems.sort((a, b) => a.no - b.no);
                        renderDeliveryCards(activeFilter);
                        showToastMessage('순번순으로 정렬되었습니다.');
                        break;
                    case 'jump-no':
                        numberJumpList.innerHTML = '';
                        if (deliveryItems.length === 0) {
                            numberJumpList.innerHTML = '<p class="text-gray-500 dark:text-gray-400 col-span-5 text-center">카드가 없습니다.</p>';
                        } else {
                            const maxNo = Math.max(0, ...deliveryItems.map(item => item.no));
                            const itemsMap = new Map(deliveryItems.map(item => [item.no, item.status]));
                            for (let i = 1; i <= maxNo; i++) {
                                const status = itemsMap.get(i);
                                const btn = document.createElement('div');
                                btn.textContent = i;
                                if (status === '배송중') {
                                    btn.className = 'number-jump-item active';
                                    btn.dataset.no = i;
                                    btn.onclick = () => {
                                        const targetCard = document.querySelector(`[data-no="${i}"]`);
                                        if (targetCard) targetCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                        numberJumpModal.style.display = 'none';
                                    };
                                } else if (status) {
                                    btn.className = 'number-jump-item inactive';
                                } else {
                                    btn.className = 'number-jump-item placeholder';
                                    btn.innerHTML = ' ';
                                }
                                numberJumpList.appendChild(btn);
                            }
                        }
                        numberJumpModal.style.display = 'flex';
                        break;
                    case 'sort-time':
                        completedSortOrder = 'time';
                        currentSortOrder = 'time';
                        const completedItems = deliveryItems.filter(item => item.status === '완료');
                        const otherItems = deliveryItems.filter(item => item.status !== '완료');
                        completedItems.sort((a, b) => {
                            if (!a.deliveryCompletionTime) return 1;
                            if (!b.deliveryCompletionTime) return -1;
                            return a.deliveryCompletionTime.localeCompare(b.deliveryCompletionTime);
                        });
                        deliveryItems = [...completedItems, ...otherItems];
                        renderDeliveryCards(activeFilter);
                        showToastMessage('빠른 완료시간순으로 정렬되었습니다.');
                        break;
                }
                if (button.parentNode.id === 'fab-options') {
                    setTimeout(setupFab, 50);
                }
            });

            numberJumpClose.addEventListener('click', () => numberJumpModal.style.display = 'none');
            numberJumpModal.addEventListener('click', (event) => { if (event.target === numberJumpModal) numberJumpModal.style.display = 'none'; });
            smartEditExitBtn.addEventListener('click', closeSmartEditModal);
            smartEditModal.addEventListener('click', (event) => { if (event.target === smartEditModal) closeSmartEditModal(); });
            cancelSignatureBtn.addEventListener('click', closeSignatureModal);
            signatureModal.addEventListener('click', (event) => { if (event.target === signatureModal) closeSignatureModal(); });

            const storedItems = localStorage.getItem('deliveryItems');
            if (storedItems) {
                let parsedItems = JSON.parse(storedItems);
                deliveryItems = parsedItems.map(item => {
                    if (typeof item.addressLocation === 'undefined') item.addressLocation = null;
                    if (typeof item.isStruckThrough === 'undefined') item.isStruckThrough = false;
                    if (typeof item.isAddressValidated === 'undefined') item.isAddressValidated = true;
                    return item;
                }).sort((a, b) => a.no - b.no);
            }
            const storedScroll = localStorage.getItem('filterScrollPositions');
            if (storedScroll) filterScrollPositions = JSON.parse(storedScroll);
            updateFilterCounts();
            
            const urlParamsForCheck = new URLSearchParams(window.location.search);
            if (!urlParamsForCheck.has('hawb') && !urlParamsForCheck.has('filter')) {
                changeFilter('배송준비', '', true);
            }

            const handleUrlParams = (url) => {
                const urlParams = new URLSearchParams(url.search);
                const hawbFromUrl = urlParams.get('hawb');
                if (hawbFromUrl) {
                    changeFilter('전체', '', true);
                    searchTerm = hawbFromUrl;
                    invoiceNumberInput.value = hawbFromUrl;
                    renderDeliveryCards('전체');
                    const cleanUrl = `${window.location.origin}${window.location.pathname}`;
                    window.history.replaceState({}, '', cleanUrl);
                }
            };

            if ('launchQueue' in window) {
                window.launchQueue.setConsumer(launchParams => {
                    if (launchParams.targetURL) {
                        const url = new URL(launchParams.targetURL);
                        handleUrlParams(url);
                    }
                });
            } else {
                const url = new URL(window.location.href);
                handleUrlParams(url);
            }
        });
    </script>
</body>
</html>