<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>배송 시트</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html {
            scroll-behavior: auto !important; /* JS로 부드러운 스크롤을 제어하기 위해 기본 스크롤 동작을 즉시로 변경 */
        }
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding-bottom: 80px;
            overscroll-behavior-y: contain;
        }
        .signature-modal, .confirmation-modal, .suggestion-modal, .address-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 1rem;
        }
        .signature-modal-content, .confirmation-modal-content, .suggestion-modal-content, .address-selection-modal-content {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            padding: 1.5rem;
            width: 100%;
            max-width: 28rem;
            max-height: 90vh; /* 모달 높이 제한 */
            overflow-y: auto; /* 내용 길어지면 스크롤 */
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #2563eb;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .animate-slide-in-left { animation: slideInLeft 0.3s ease-out forwards; }
        .animate-slide-in-right { animation: slideInRight 0.3s ease-out forwards; }
        #delivery-cards-container {
            transition: transform 0.1s ease-out;
            will-change: transform;
        }
        #filter-buttons-container, #search-bar-container {
            position: fixed;
            left: 0;
            width: 100vw;
            will-change: transform, top;
        }
        /* ✨ 퀵-스크롤 핸들 스타일 시작 ✨ */
        #quick-scroll-container {
            position: fixed;
            top: 0;
            right: 0;
            height: 100%;
            width: 40px; /* 핸들 터치 영역 확장 */
            display: none; /* '배송중' 탭에서만 보이도록 JS로 제어 */
            z-index: 40;
            user-select: none;
            -webkit-user-select: none;
        }
        #quick-scroll-handle {
            position: absolute;
            right: 8px; /* 오른쪽 여백 확보 */
            top: 50%;
            width: 24px; /* 핸들 두께 */
            height: 50px; /* 핸들 길이 */
            background-color: rgba(0, 0, 0, 0.25);
            border-radius: 12px;
            cursor: grab;
            transition: background-color 0.2s; /* 드래그 중이 아닐때만 top 전환 효과 적용 */
        }
        #quick-scroll-handle:not(.active) {
            transition: background-color 0.2s, top 0.15s ease-out;
        }
        #quick-scroll-handle.active {
            background-color: rgba(37, 99, 235, 0.7); /* 활성화 시 파란색으로 변경 */
            cursor: grabbing;
        }
        #quick-scroll-bubble {
            position: absolute;
            right: 50px; /* 핸들 왼쪽으로 충분히 이동 */
            top: 50%;
            transform: translateY(-50%);
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            font-size: 1.5rem; /* 글자 크기 증가 */
            font-weight: 700;  /* 폰트 굵게 */
            border-radius: 16px;
            display: none;
            pointer-events: none; /* 버블이 터치를 방해하지 않도록 */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #quick-scroll-handle.active ~ #quick-scroll-bubble {
             transition: none; /* 드래그 중에는 부드러운 효과 제거 */
        }
        /* ✨ 퀵-스크롤 핸들 스타일 끝 ✨ */
    </style>
</head>
<body class="min-h-screen bg-gray-100 p-4 sm:p-6 lg:p-8 font-sans">
    <div id="search-bar-container" class="z-30">
        <div class="max-w-md mx-auto bg-white rounded-lg shadow-lg w-full min-w-[320px] p-4">
            <label for="invoiceNumber" class="block text-sm font-medium text-gray-700 sr-only">송장번호 검색</label>
            <div class="flex space-x-2 flex-nowrap">
                <input type="tel" id="invoiceNumber" name="invoiceNumber" placeholder="송장번호 검색" class="w-2/5 p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" inputmode="numeric" pattern="[0-9]*"/>
                <button id="searchButton" class="w-3/10 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">검색</button>
                <button id="resetButton" class="w-3/10 px-4 py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50">초기화</button>
            </div>
        </div>
    </div>

    <div id="filter-buttons-container" class="z-20">
        <div class="max-w-md mx-auto bg-white rounded-lg shadow-lg w-full min-w-[320px] p-4">
            <div class="flex justify-around space-x-2 overflow-x-auto" style="-webkit-overflow-scrolling: touch;">
                <button data-filter="배송준비" class="flex-shrink-0 px-3 py-1.5 rounded-full text-sm font-medium transition-colors duration-200 flex items-center justify-center space-x-1 whitespace-nowrap"><span>배송준비</span></button>
                <button data-filter="전체" class="flex-shrink-0 px-3 py-1.5 rounded-full text-sm font-medium transition-colors duration-200 flex items-center justify-center space-x-1 bg-transparent text-gray-700 border border-gray-300 hover:bg-gray-100 whitespace-nowrap"><span>전체</span><span class="text-xs font-semibold px-1.5 py-0.5 rounded-full bg-gray-200 text-gray-700" id="count-전체">0</span></button>
                <button data-filter="배송전" class="flex-shrink-0 px-3 py-1.5 rounded-full text-sm font-medium transition-colors duration-200 flex items-center justify-center space-x-1 bg-transparent text-gray-700 border border-gray-300 hover:bg-gray-100 whitespace-nowrap"><span>배송전</span><span class="text-xs font-semibold px-1.5 py-0.5 rounded-full bg-gray-200 text-gray-700" id="count-배송전">0</span></button>
                <button data-filter="배송중" class="flex-shrink-0 px-3 py-1.5 rounded-full text-sm font-medium transition-colors duration-200 flex items-center justify-center space-x-1 bg-transparent text-gray-700 border border-gray-300 hover:bg-gray-100 whitespace-nowrap"><span>배송중</span><span class="text-xs font-semibold px-1.5 py-0.5 rounded-full bg-gray-200 text-gray-700" id="count-배송중">0</span></button>
                <button data-filter="완료" class="flex-shrink-0 px-3 py-1.5 rounded-full text-sm font-medium transition-colors duration-200 flex items-center justify-center space-x-1 bg-transparent text-gray-700 border border-gray-300 hover:bg-gray-100 whitespace-nowrap"><span>완료</span><span class="text-xs font-semibold px-1.5 py-0.5 rounded-full bg-gray-200 text-gray-700" id="count-완료">0</span></button>
            </div>
        </div>
    </div>

    <div id="data-management-container" class="max-w-md mx-auto mb-6 p-4 bg-white rounded-lg shadow-lg w-full min-w-[320px] space-y-4 hidden">
        <div>
            <h3 class="text-lg font-semibold text-gray-800 mb-2">데이터 내보내기/가져오기</h3>
            <div class="flex space-x-2">
                <button id="exportDataButton" class="w-1/2 px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500">데이터 파일로 저장</button>
                <label for="importDataInput" class="w-1/2 px-4 py-2 bg-sky-600 text-white rounded-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 text-center cursor-pointer">파일에서 불러오기</label>
                <input type="file" id="importDataInput" class="hidden" accept=".json"/>
            </div>
        </div>
        <div>
            <h3 class="text-lg font-semibold text-gray-800 mb-2">카드 초기화</h3>
            <button id="clearAllCardsButton" class="w-full px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">모든 카드 삭제</button>
        </div>
    </div>
    
    <div id="version-info-container" class="max-w-md mx-auto mb-6 text-center hidden">
        <p id="version-text" class="text-xs text-gray-600 font-mono"></p>
        <p id="version-changelog" class="text-xs text-gray-500"></p>
    </div>

    <div id="scan-section-container" class="max-w-md mx-auto mb-6 p-4 bg-white rounded-lg shadow-lg w-full min-w-[320px] hidden">
        <h3 class="text-lg font-semibold text-gray-800 mb-3">송장 스캔하여 카드 생성</h3>
        <div class="flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 sm:space-x-3">
            <input type="file" id="deliverySheetImage" accept="image/*" multiple class="hidden"/>
            <label for="deliverySheetImage" class="flex-1 w-full text-sm text-blue-700 py-2 px-4 rounded-md border border-blue-300 bg-blue-50 font-semibold cursor-pointer hover:bg-blue-100 text-center whitespace-nowrap">사진 선택</label>
            <button id="scanAndGenerateButton" class="w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">스캔하여 카드 생성</button>
        </div>
        <div id="selected-files-display" class="mt-2 text-sm text-gray-600 text-center">선택된 파일 없음</div>
        <div id="scan-loading-indicator" class="hidden mt-3 text-center text-sm text-blue-600">
            <div class="spinner mx-auto mb-2"></div>
            <p id="scan-progress-text">송장 스캔 중...</p>
        </div>
        <div id="scan-error-message" class="hidden mt-3 text-center text-sm text-red-600">스캔 실패: <span id="scan-error-text"></span></div>
    </div>

    <div id="delivery-cards-container" class="max-w-md mx-auto"></div>
    
    <div id="quick-scroll-container">
        <div id="quick-scroll-handle"></div>
        <div id="quick-scroll-bubble">1</div>
    </div>

    <div id="signature-modal" class="signature-modal" style="display: none;">
        <div class="signature-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800">서명 입력</h2>
            <div class="signature-input-container">
                <textarea id="signature-text-input" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" rows="3" placeholder="여기에 서명 내용을 입력하세요."></textarea>
            </div>
            <div class="flex justify-end space-x-2 mt-4">
                <button id="clearSignature" class="px-4 py-2 rounded-md bg-gray-300 text-gray-800 text-sm font-medium hover:bg-gray-400">지우기</button>
                <button id="cancelSignature" class="px-4 py-2 rounded-md bg-red-500 text-white text-sm font-medium hover:bg-red-600">취소</button>
                <button id="saveSignature" class="px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">저장</button>
            </div>
        </div>
    </div>

    <div id="confirmation-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800" id="confirmation-modal-title">확인</h2>
            <p class="text-base text-gray-700 mb-6" id="confirmation-modal-message"></p>
            <div class="flex justify-between space-x-2 mt-4">
                <button id="confirmCancelButton" class="w-1/2 px-4 py-2 rounded-md bg-gray-300 text-gray-800 text-sm font-medium hover:bg-gray-400">취소</button>
                <button id="confirmOkButton" class="w-1/2 px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">확인</button>
            </div>
        </div>
    </div>

    <!-- ✨ 수정된 주소 선택/편집 모달 ✨ -->
    <div id="address-selection-modal" class="address-selection-modal" style="display: none;">
        <div class="address-selection-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800">주소 편집</h2>
            
            <div class="mb-4">
                <h3 class="text-sm font-semibold text-gray-600 mb-1">원본 주소 (참조용)</h3>
                <p id="original-address-display" class="p-2 bg-gray-100 rounded-md text-gray-800 text-sm font-mono break-all"></p>
            </div>

            <hr class="my-4 border-gray-300"/>

            <div id="address-smart-edit-area" class="mb-6">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">스마트 편집 (조각 조합)</h3>
                <div id="address-chips-container" class="flex flex-wrap gap-2 p-3 border border-gray-300 rounded-md bg-gray-50 mb-3 min-h-[50px]">
                    <span class="text-gray-500 text-sm">주소 조각이 없습니다.</span>
                </div>
                <div class="flex space-x-2 mb-2">
                    <button id="insert-space-btn" class="px-3 py-1.5 rounded-md bg-blue-200 text-blue-800 text-sm font-medium hover:bg-blue-300">띄어쓰기</button>
                    <button id="insert-comma-btn" class="px-3 py-1.5 rounded-md bg-blue-200 text-blue-800 text-sm font-medium hover:bg-blue-300">쉼표</button>
                    <button id="insert-hyphen-btn" class="px-3 py-1.5 rounded-md bg-blue-200 text-blue-800 text-sm font-medium hover:bg-blue-300">하이픈</button>
                    <button id="clear-smart-edit-btn" class="px-3 py-1.5 rounded-md bg-red-200 text-red-800 text-sm font-medium hover:bg-red-300">초기화</button>
                </div>
                <div id="smart-edit-preview-output" class="p-2 border bg-white rounded-md min-h-[40px] text-gray-700 text-base"></div>
                <button id="apply-smart-edit-btn" class="w-full mt-2 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-sm font-medium">스마트 편집 내용으로 적용</button>
            </div>

            <hr class="my-4 border-gray-300"/>

            <div class="mt-4">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">주소 직접 편집</h3>
                <textarea id="address-direct-edit-input" 
                          class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" 
                          rows="4" 
                          placeholder="여기에 주소를 직접 입력하세요."
                          inputmode="text"
                          autocomplete="address-line1"
                          autocorrect="off"
                          autocapitalize="off"
                          spellcheck="false"></textarea>
                <button id="apply-direct-edit-btn" class="w-full mt-2 px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 text-sm font-medium">직접 편집 내용으로 적용</button>
            </div>

            <div class="flex justify-end space-x-2 mt-6 border-t pt-4 border-gray-200">
                <button id="select-address-cancel" class="px-4 py-2 rounded-md bg-gray-400 text-gray-800 text-sm font-medium hover:bg-gray-500">취소</button>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        const GEMINI_PROMPT = `Your task is to extract delivery information from an invoice and convert the address into a standard Korean "Road Name Address" (도로명주소). Your primary goal is to parse and reconstruct addresses from invoice images with the highest possible accuracy, following specific structural rules.

**Crucially, in addition to the full Korean address string in "receiverAddressKorean", you MUST also provide the parsed address components as a JSON array of strings in a new field called "receiverAddressComponents". Each element in this array should be a distinct, meaningful component of the address (e.g., city, district, road name, building number, specific apartment complex name, building/unit number, etc.). Do not split a single building number (like 123-45) or a compound dong/ri name (like Dongtan) into smaller pieces. Ensure all parts of the address are present in this array, maintaining their original order.**

**Primary Duty: Correctly identify the Building Number (건물번호) and the Detailed Address (상세주소) based on their characteristics and position relative to the Road Name or District Name.**

**Follow these steps for address construction:**
1.  **Identify the Road Name:** Look for address parts ending in \`-ro\`, \`-gil\`, or \`-daero\`.
2.  **Apply Structural Rules based on Road Name presence:**

    *   **IF a Road Name is found (e.g., 'Olympic-ro', 'Cheonho-daero', 'yangjaedaero'):**
        *   **Step 2.1: Candidate Identification:** Identify all numeric or alphanumeric blocks (e.g., '435', '206-1602', '989', '421', 'No.601', '422-dong') that appear around the Road Name.
        *   **Step 2.2: Filter out "Detailed Address" blocks (NOT Building Numbers):**
            *   Any block containing **non-numeric characters or specific labels** (e.g., 'No.', '-dong', '-ho', 'B-', 'A-') is considered a **Detailed Address**.
            *   Any **hyphenated number** where **both parts are 3 or more digits** (e.g., '206-1602', '319-307') indicates an **apartment building/unit number**, and is a **Detailed Address**, not a Building Number. This is distinct from building sub-numbers like '1300-1' or '56-7'.
        *   **Step 2.3: Identify the "True" Building Number:**
            *   From the remaining unfiltered numeric blocks (those that are *not* Detailed Addresses by Rule 2.1), the one that logically represents the primary building number for the identified Road Name is the "True Building Number". **Prioritize numbers found *before* the Road Name.** If multiple logical candidates remain, use the one physically closest to the Road Name.
        *   **Step 2.4: Assemble:** Form the core as "[시/도] [시/군/구] [Road Name] [True Building Number]". Append all other identified "Detailed Address" blocks (from Rule 2.1), separated by commas. Ensure correct Korean postpositions (e.g., '동', '호').

    *   **IF NO Road Name is found:**
        *   **Step 2.5: Jibun Address:** Look for a district name ending in \`-dong\` or \`-ri\`. If it is immediately followed by a number that resembles a Jibun number (e.g., '123-4', '139-1'), that is the **Jibun Address**. **If multiple hyphenated numbers are present, prioritize the one that appears after the -dong/-ri and looks like a typical main jibun number (e.g., 139-1). The others are detailed addresses.**
        *   **Step 2.6: District Name Only:** If the \`-dong\` or \`-ri\` is NOT followed by a Jibun number, then the district name is the main address component. All other remaining parts are the **Detailed Address**, separated by a comma.

**CRITICAL Formatting Mandates:**
*   **Never split hyphenated numbers identified as apartment unit numbers** (e.g., '206-1602').
*   **Safe Inference:** If a district (e.g., '강남구') is present without a city, you must prepend the corresponding city (e.g., '서울'). Do not invent any other information not explicitly seen in the image.
*   **Correct Korean Translation of specific names:** For 'Tteokjeongol-ro', always translate to '떡전골로'. For 'Baran-ri', always translate to '발안리'.

**Examples illustrating your refined logic:**

*   **Example 1: Complex Road Name Address (Building Number First, Mixed Details)**
    *   **Source Text:** \`No.601, 422-dong, yangjae-daero 1300\`
    *   **Correct \`receiverAddressKorean\`:** "서울 강동구 양재대로 1300, 422동 601호"
    *   **Correct \`receiverAddressComponents\`:** \`["서울", "강동구", "양재대로", "1300", "422동", "601호"]\`
    *   **Reasoning:** \`yangjae-daero\` is the road. \`No.601\` and \`422-dong\` are **Detailed Addresses** (contain non-numeric characters/labels). \`1300\` is the only remaining numeric candidate for the building number. Assemble as [Road Name] [Building Number], [Detailed Addresses].

*   **Example 2: Common Road Name Address (Building Number First, Hyphenated Unit)**
    *   **Source Text:** \`435, Olympic-ro 206-1602\`
    *   **Correct \`receiverAddressKorean\`:** "서울 송파구 올림픽로 435, 206-1602"
    *   **Correct \`receiverAddressComponents\`:** \`["서울", "송파구", "올림픽로", "435", "206-1602"]\`
    *   **Reasoning:** \`Olympic-ro\` is the road. \`206-1602\` is a hyphenated apartment unit pattern (large numbers), making it a **Detailed Address**. \`435\` is the remaining numeric candidate for the building number, appearing before the road name.

*   **Example 3: Road Name Address (Building Number First, Single Detail)**
    *   **Source Text:** \`989, Cheonho-daero 421\`
    *   **Correct \`receiverAddressKorean\`:** "서울 강동구 천호대로 989, 421"
    *   **Correct \`receiverAddressComponents\`:** \`["서울", "강동구", "천호대로", "989", "421"]\`
    *   **Reasoning:** \`Cheonho-daero\` is the road. \`421\` is a number after the road name, making it a **Detailed Address**. \`989\` is the leading numeric candidate for the building number, appearing before the road name.

*   **Example 4: Road Name Address (Building Number Missing, Only Detailed After Road Name)**
    *   **Source Text:** \`Olympic-ro 102-408\`
    *   **Correct \`receiverAddressKorean\`:** "서울 송파구 올림픽로, 102-408"
    *   **Correct \`receiverAddressComponents\`:** \`["서울", "송파구", "올림픽로", "102-408"]\`
    *   **Reasoning:** No number appears before \`Olympic-ro\` for the building number. Therefore, \`102-408\` is the **Detailed Address**, separated by a comma because the building number is implied missing from the input text.

*   **Example 5: Jibun Address (District Name Only, followed by detailed)**
    *   **Source Text:** \`Shinchundong Jamsil the sharp starpark 101-2503\`
    *   **Correct \`receiverAddressKorean\`:** "서울 송파구 신천동, 잠실 더샵 스타파크 101-2503"
    *   **Correct \`receiverAddressComponents\`:** \`["서울", "송파구", "신천동", "잠실 더샵 스타파크", "101-2503"]\`
    *   **Reasoning:** \`Shinchundong\` is a district name not followed by a Jibun number. The rest of the text is **Detailed Address**, separated by a comma.

*   **Example 6: Road Name, Building Number on right (Complex detailed)**
    *   **Source Text:** \`yangjaedaero 1300 olympic park foreon 319dong 307ho\`
    *   **Correct \`receiverAddressKorean\`:** "서울 강동구 양재대로 1300, 올림픽파크 포레온 319동 307호"
    *   **Correct \`receiverAddressComponents\`:** \`["서울", "강동구", "양재대로", "1300", "올림픽파크 포레온", "319동", "307호"]\`
    *   **Reasoning:** \`yangjaedaero\` is the road name. \`319dong\` and \`307ho\` are **Detailed Addresses** (contain non-numeric characters/labels). \`1300\` is the logical numeric candidate for the building number.

*   **Example 7: Road Name Address (Scattered, Building Sub-number, Detail)**
    *   **Source Text:** \`202, 56-7, Cheonho-daero 168na-gil\`
    *   **Correct \`receiverAddressKorean\`:** "서울 강동구 천호대로168나길 56-7, 202"
    *   **Correct \`receiverAddressComponents\`:** \`["서울", "강동구", "천호대로168나길", "56-7", "202"]\`
    *   **Reasoning:** \`Cheonho-daero 168na-gil\` is the road. \`56-7\` is a building sub-number pattern (not a large apartment unit pattern), making it the **True Building Number**. \`202\` is a short number and is treated as a **Detailed Address**.

*   **Example 8: Direct Road/Sub-road translation (Specific)**
    *   **Source Text:** \`10-2, Baran-ri\`
    *   **Correct \`receiverAddressKorean\`:** "경기 화성시 발안리 10-2"
    *   **Correct \`receiverAddressComponents\`:** \`["경기", "화성시", "발안리", "10-2"]\`
    *   **Reasoning:** This is a Jibun address. \`Baran-ri\` should be translated to '발안리'. \`10-2\` is the Jibun number. City/Province inferred.

*   **Example 9: Direct Road Name Correction (Specific)**
    *   **Source Text:** \`202, 104-7, Tteokjeongol-ro\`
    *   **Correct \`receiverAddressKorean\`:** "경기 화성시 떡전골로 104-7, 202"
    *   **Correct \`receiverAddressComponents\`:** \`["경기", "화성시", "떡전골로", "104-7", "202"]\`
    *   **Reasoning:** \`Tteokjeongol-ro\` is the road. It should be translated to '떡전골로'. \`104-7\` is a building sub-number, making it the **True Building Number**. \`202\` is treated as a **Detailed Address**.

*   **Example 10: Jibun Address with multiple hyphenated numbers (Complex)**
    *   **Source Text:** \`Gyeonggi-do Hwaseong-si 105-106, #139-1, DONGHWA-RI, BONGDAM-EUP\`
    *   **Correct \`receiverAddressKorean\`:** "경기 화성시 봉담읍 동화리 139-1, 105-106"
    *   **Correct \`receiverAddressComponents\`:** \`["경기", "화성시", "봉담읍", "동화리", "139-1", "105-106"]\`
    *   **Reasoning:** \`DONGHWA-RI\` is the district. Among \`105-106\` and \`#139-1\`, \`139-1\` is identified as the primary jibun number (due to '#' and typical jibun format). \`105-106\` becomes the detailed address.

**Output JSON Format:**
Return a JSON array of objects. Each object must contain: \`no\`, \`hawbNo\`, \`receiverAddressKorean\`, \`receiverAddressOriginal\`, \`companyNameKorean\`, \`companyNameOriginal\`, \`receiverNameKorean\`, \`receiverNameOriginal\`, \`receiverTelephoneNo\`, \`receiverAddressComponents\`.
`;
        
        const KAKAO_API_KEY = '2342aad8b15d534cb60fb824f71a97f1';

        const dateTimeFormatOptions = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };

        // --- Helper functions ---
        const cleanStringForDisplay = (str) => {
            if (typeof str !== 'string' || !str) return '';
            return str.replace(/[\n\\]/g, '').trim();
        };

        const formatSinglePhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('+82010')) { cleaned = '010' + cleaned.substring(6); }
            else if (cleaned.startsWith('82010')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('+8210')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('8210')) { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('8201') && cleaned.length > 4 && cleaned[4] !== '0') { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('82') && cleaned.length > 2) { cleaned = '0' + cleaned.substring(2); }
            else if (cleaned.length >= 7 && cleaned.length <= 11 && !cleaned.startsWith('0')) { cleaned = '0' + cleaned; }
            
            if (cleaned.startsWith('010') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.startsWith('02')) {
                if (cleaned.length === 9) return cleaned.replace(/(\d{2})(\d{3})(\d{4})/, '$1-$2-$3');
                if (cleaned.length === 10) return cleaned.replace(/(\d{2})(\d{4})(\d{4})/, '$1-$2-$3');
            }
            if (cleaned.startsWith('031') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.startsWith('070') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 10) return cleaned.replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 9) return cleaned.replace(/(\d{2})(\d{3})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 8) return cleaned.replace(/(\d{4})(\d{4})/, '$1-$2');
            if (cleaned.length === 7) return cleaned.replace(/(\d{3})(\d{4})/, '$1-$2');

            return cleaned;
        };

        const formatPhoneNumberForDisplay = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            const rangeMatch = phoneNumber.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) {
                const baseNumber = rangeMatch[1];
                const suffix = rangeMatch[2];
                if (baseNumber.length >= suffix.length) {
                    const num1 = formatSinglePhoneNumber(baseNumber);
                    const num2Raw = baseNumber.substring(0, baseNumber.length - suffix.length) + suffix;
                    const num2 = formatSinglePhoneNumber(num2Raw);
                    return `${num1} / ${num2}`;
                }
            }
            return formatSinglePhoneNumber(phoneNumber.replace(/\D/g, ''));
        };

        const getCleanPhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            const rangeMatch = phoneNumber.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) phoneNumber = rangeMatch[1];
            
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('+82010')) { cleaned = '010' + cleaned.substring(6); }
            else if (cleaned.startsWith('82010')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('+8210')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('8210')) { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('8201') && cleaned.length > 4 && cleaned[4] !== '0') { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('82') && cleaned.length > 2) { cleaned = '0' + cleaned.substring(2); }
            else if (cleaned.length >= 7 && cleaned.length <= 11 && !cleaned.startsWith('0')) { cleaned = '0' + cleaned; }

            return cleaned;
        };

        const formatHawbNoForDisplay = (hawbNo) => {
            if (!hawbNo || hawbNo.length < 4) return hawbNo;
            const prefix = hawbNo.substring(0, hawbNo.length - 4);
            const suffix = hawbNo.substring(hawbNo.length - 4);
            return `${prefix} ${suffix}`;
        };

        const formatCompletionTime = (dateTimeString) => {
            if (!dateTimeString) return '';
            const parts = dateTimeString.split(' ');
            if (parts.length >= 4) {
                const [hour, minute] = parts[3].split(':');
                return `${hour}:${minute}`;
            }
            return '';
        };
        
        const extractClipboardAddressPart = (fullAddress) => {
            if (!fullAddress || typeof fullAddress !== 'string') return '';
            let cleanAddress = fullAddress.trim();

            const dongHoMatch = cleanAddress.match(/(\d+)\s*동\s*(\d+)\s*호/);
            if (dongHoMatch) {
                return `${dongHoMatch[1]}-${dongHoMatch[2]}`;
            }
            const hyphenUnitMatch = cleanAddress.match(/\b(\d{2,4}-\d{2,4})\b/);
            if (hyphenUnitMatch) {
                return hyphenUnitMatch[1];
            }

            const roadAddrMatch = cleanAddress.match(/([가-힣\d\-]+(?:로|길|대로|번길))\s*([\d\-]+)/);
            if (roadAddrMatch) {
                return `${roadAddrMatch[1]} ${roadAddrMatch[2]}`.trim();
            }

            const jibunAddrMatch = cleanAddress.match(/([가-힣\d\-]+(?:동|리))\s*([\d\-]+)/);
            if (jibunAddrMatch) {
                return `${jibunAddrMatch[1]} ${jibunAddrMatch[2]}`.trim();
            }
            
            const dongRiMatch = cleanAddress.match(/([가-힣\d\s]+(?:동|리))/);
            if (dongRiMatch) {
                return dongRiMatch[1].trim();
            }

            return cleanAddress.replace(/\s+[\d\-동호,]+$/, '').trim();
        };

        const isValidAddressForMap = (address) => {
            return !!(address && address.trim().length > 0);
        };

        const extractMapSearchQuery = (address) => {
            if (!address) return '';
            let cleanAddress = address.trim();

            const roadAddrMatch = cleanAddress.match(/([가-힣\d\s]+(?:로|길|대로|번길))\s*([\d\-]+)/);
            if (roadAddrMatch) {
                return `${roadAddrMatch[1]} ${roadAddrMatch[2]}`.trim();
            }

            const jibunAddrMatch = cleanAddress.match(/([가-힣\d\s]+(?:동|리))\s*([\d\-]+)/);
            if (jibunAddrMatch) {
                return `${jibunAddrMatch[1]} ${jibunAddrMatch[2]}`.trim();
            }
            
            const dongRiMatch = cleanAddress.match(/([가-힣\d\s]+(?:동|리))/);
            if (dongRiMatch) {
                return dongRiMatch[1].trim();
            }

            return cleanAddress;
        };

        // --- Global state and DOM elements ---
        let deliveryItems = [];
        let searchTerm = '';
        let activeFilter = '전체';
        const filterCategories = ['배송준비', '전체', '배송전', '배송중', '완료'];
        let filterScrollPositions = {};
        let currentFileToScan = null;
        let failedFileObjects = []; 
        let currentSignatureItemNo = null;
        let onConfirmCallback = null;
        let currentAddressSelectionItemNo = null; 

        const searchBarContainer = document.getElementById('search-bar-container');
        const invoiceNumberInput = document.getElementById('invoiceNumber');
        const searchButton = document.getElementById('searchButton');
        const resetButton = document.getElementById('resetButton');
        const filterButtonsContainer = document.getElementById('filter-buttons-container');
        const deliveryCardsContainer = document.getElementById('delivery-cards-container');
        const deliverySheetImageInput = document.getElementById('deliverySheetImage');
        const scanAndGenerateButton = document.getElementById('scanAndGenerateButton');
        const scanLoadingIndicator = document.getElementById('scan-loading-indicator');
        const scanErrorMessage = document.getElementById('scan-error-message');
        const scanErrorText = document.getElementById('scan-error-text');
        const scanSectionContainer = document.getElementById('scan-section-container');
        const clearAllCardsButton = document.getElementById('clearAllCardsButton');
        const dataManagementContainer = document.getElementById('data-management-container');
        const exportDataButton = document.getElementById('exportDataButton');
        const importDataInput = document.getElementById('importDataInput');
        const scanProgressText = document.getElementById('scan-progress-text');
        const selectedFilesDisplay = document.getElementById('selected-files-display');
        const signatureModal = document.getElementById('signature-modal');
        const signatureTextInput = document.getElementById('signature-text-input');
        const clearSignatureBtn = document.getElementById('clearSignature');
        const cancelSignatureBtn = document.getElementById('cancelSignature');
        const saveSignatureBtn = document.getElementById('saveSignature');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationModalTitle = document.getElementById('confirmation-modal-title');
        const confirmationModalMessage = document.getElementById('confirmation-modal-message');
        const confirmOkButton = document.getElementById('confirmOkButton');
        const confirmCancelButton = document.getElementById('confirmCancelButton');
        const versionInfoContainer = document.getElementById('version-info-container');
        const versionText = document.getElementById('version-text');
        const versionChangelog = document.getElementById('version-changelog');
        
        // Address Modal Elements
        const addressSelectionModal = document.getElementById('address-selection-modal');
        const originalAddressDisplay = document.getElementById('original-address-display');
        const addressChipsContainer = document.getElementById('address-chips-container'); 
        const smartEditPreviewOutput = document.getElementById('smart-edit-preview-output'); 
        const addressDirectEditInput = document.getElementById('address-direct-edit-input'); 
        const insertSpaceBtn = document.getElementById('insert-space-btn'); 
        const insertCommaBtn = document.getElementById('insert-comma-btn'); 
        const insertHyphenBtn = document.getElementById('insert-hyphen-btn'); 
        const clearSmartEditBtn = document.getElementById('clear-smart-edit-btn'); 
        const applySmartEditBtn = document.getElementById('apply-smart-edit-btn');
        const applyDirectEditBtn = document.getElementById('apply-direct-edit-btn');
        const selectAddressCancelBtn = document.getElementById('select-address-cancel');

        // --- Modal & Core Logic Functions ---
        const openSignatureModal = (itemNo) => { currentSignatureItemNo = itemNo; signatureModal.style.display = 'flex'; signatureTextInput.value = ''; signatureTextInput.focus(); };
        const closeSignatureModal = () => { signatureModal.style.display = 'none'; currentSignatureItemNo = null; };
        const saveSignature = () => {
            if (currentSignatureItemNo === null) return;
            const signatureText = signatureTextInput.value.trim();
            if (signatureText === '') { showMessage('서명 내용을 입력해주세요.'); return; }
            const currentTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
            handleStatusChange(currentSignatureItemNo, '완료', currentTime, '서명', signatureText);
            closeSignatureModal();
            showMessage('서명이 성공적으로 저장되었습니다.', '성공');
        };
        
        const openConfirmationModal = (message, onOk, okText = '확인', cancelText = '취소') => {
            confirmationModalTitle.textContent = '확인';
            confirmationModalMessage.textContent = message;
            confirmOkButton.textContent = okText;
            confirmCancelButton.textContent = cancelText;
            confirmCancelButton.style.display = '';
            onConfirmCallback = onOk;
            confirmationModal.style.display = 'flex';
        };

        const closeConfirmationModal = () => { 
            confirmationModal.style.display = 'none'; 
            onConfirmCallback = null; 
            confirmCancelButton.style.display = ''; 
            confirmOkButton.textContent = '확인';
            confirmCancelButton.textContent = '취소';
        };

        const showMessage = (message, title = '알림') => {
            confirmationModalTitle.textContent = title;
            confirmationModalMessage.textContent = message;
            confirmCancelButton.style.display = 'none';
            confirmOkButton.textContent = '확인';
            onConfirmCallback = closeConfirmationModal;
            confirmationModal.style.display = 'flex';
        };
        
        // ✨ 주소 편집 모달 로직 (수정됨) ✨
        const openAddressSelectionModal = (itemNo) => {
            currentAddressSelectionItemNo = itemNo;
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item) { showMessage('카드 정보를 찾을 수 없습니다.'); return; }

            // 1. 원본(영문) 주소 표시
            originalAddressDisplay.textContent = item.receiverAddressOriginal || '원본 주소 없음';
            
            // 2. 직접 편집 영역에 현재 한글 주소 채우기
            addressDirectEditInput.value = item.receiverAddressKorean || '';
            
            // 3. 스마트 편집 영역 초기화
            smartEditPreviewOutput.textContent = ''; 
            addressChipsContainer.innerHTML = '';
            if (item.receiverAddressComponents && item.receiverAddressComponents.length > 0) {
                item.receiverAddressComponents.forEach(component => {
                    if (component) { 
                        const chip = document.createElement('span');
                        chip.className = 'inline-block bg-blue-100 text-blue-800 text-sm font-medium px-2.5 py-0.5 rounded-full cursor-pointer hover:bg-blue-200';
                        chip.textContent = component;
                        chip.addEventListener('click', () => {
                            let currentText = smartEditPreviewOutput.textContent;
                            const newText = component;
                            const lastChar = currentText.length > 0 ? currentText.slice(-1) : '';
                            const isPunctuationOrSpace = (char) => [',', '-', ' '].includes(char); 
                            
                            if (currentText.length > 0 && !isPunctuationOrSpace(lastChar) && !isPunctuationOrSpace(newText.charAt(0))) {
                                currentText += ' ';
                            }
                            smartEditPreviewOutput.textContent = currentText + newText;
                        });
                        addressChipsContainer.appendChild(chip);
                    }
                });
            } else {
                addressChipsContainer.innerHTML = '<span class="text-gray-500 text-sm">주소 조각을 찾을 수 없습니다.</span>';
            }

            addressSelectionModal.style.display = 'flex';
        };

        const closeAddressSelectionModal = () => {
            addressSelectionModal.style.display = 'none';
            currentAddressSelectionItemNo = null;
            addressDirectEditInput.value = ''; 
            addressChipsContainer.innerHTML = ''; 
            smartEditPreviewOutput.textContent = ''; 
            originalAddressDisplay.textContent = '';
        };

        const applyNewAddress = (newAddress) => {
            if (!newAddress) {
                showMessage('적용할 주소 내용이 없습니다.', '알림');
                return;
            }
            if (currentAddressSelectionItemNo !== null) {
                const itemIndex = deliveryItems.findIndex(item => item.no === currentAddressSelectionItemNo);
                if (itemIndex > -1) {
                    deliveryItems[itemIndex].receiverAddressKorean = newAddress;
                    saveDeliveryItemsToLocalStorage();
                    renderDeliveryCards(); 
                    showMessage('주소가 성공적으로 변경되었습니다.', '변경 완료');
                }
            }
            closeAddressSelectionModal();
        };
        
        // 스마트 편집 특수 문자 삽입 버튼 이벤트
        insertSpaceBtn.addEventListener('click', () => { smartEditPreviewOutput.textContent += ' '; });
        insertCommaBtn.addEventListener('click', () => { smartEditPreviewOutput.textContent += ', '; });
        insertHyphenBtn.addEventListener('click', () => { smartEditPreviewOutput.textContent += '-'; });
        clearSmartEditBtn.addEventListener('click', () => { smartEditPreviewOutput.textContent = ''; });

        // 각 편집 영역의 '적용' 버튼 이벤트
        applySmartEditBtn.addEventListener('click', () => {
            applyNewAddress(smartEditPreviewOutput.textContent.trim());
        });
        applyDirectEditBtn.addEventListener('click', () => {
            applyNewAddress(addressDirectEditInput.value.trim());
        });
        selectAddressCancelBtn.addEventListener('click', closeAddressSelectionModal);
        
        confirmOkButton.addEventListener('click', () => { if (onConfirmCallback) onConfirmCallback(); closeConfirmationModal(); });
        confirmCancelButton.addEventListener('click', closeConfirmationModal);
        clearSignatureBtn.addEventListener('click', () => signatureTextInput.value = '');
        cancelSignatureBtn.addEventListener('click', closeSignatureModal);
        saveSignatureBtn.addEventListener('click', saveSignature);

        const saveDeliveryItemsToLocalStorage = () => {
            localStorage.setItem('deliveryItems', JSON.stringify(deliveryItems));
            localStorage.setItem('filterScrollPositions', JSON.stringify(filterScrollPositions));
        };
        const handleStatusChange = (itemNo, newStatus, completionTime = null, completionType = null, completionDetail = null) => {
            deliveryItems = deliveryItems.map(item => item.no === itemNo ? { ...item, status: newStatus, deliveryCompletionTime: completionTime, completionType, completionDetail, isHawbConfirmed: newStatus !== '배송전' } : item);
            saveDeliveryItemsToLocalStorage();
            renderDeliveryCards();
            updateFilterCounts();
        };
        const handleCheckboxToggleAndResetSearch = (itemNo, newCheckboxState) => {
            deliveryItems = deliveryItems.map(item => item.no === itemNo ? { ...item, isHawbConfirmed: newCheckboxState, status: newCheckboxState ? '배송중' : '배송전', deliveryCompletionTime: newCheckboxState ? item.deliveryCompletionTime : null, completionType: newCheckboxState ? item.completionType : null, completionDetail: newCheckboxState ? item.completionDetail : null } : item);
            saveDeliveryItemsToLocalStorage();
            searchTerm = '';
            invoiceNumberInput.value = '';
            renderDeliveryCards();
            updateFilterCounts();
        };
        
        const openNaverMap = (address, no) => {
            const addressForMapSearch = extractMapSearchQuery(address);
            const textToCopy = `${no}. ${extractClipboardAddressPart(address)}`;
            const textarea = document.createElement('textarea');
            textarea.value = textToCopy;
            textarea.style.position = 'fixed';
            textarea.style.opacity = 0;
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try { document.execCommand('copy'); }
            catch (err) { console.error('클립보드 복사 실패:', err); showMessage('클립보드 복사에 실패했습니다.', '복사 실패'); }
            document.body.removeChild(textarea);
            window.location.href = `nmap://search?query=${encodeURIComponent(addressForMapSearch)}&appname=DeliveryApp`;
        };

        const highlightHawbNo = (hawbNo, term) => {
            if (!hawbNo) return '';
            const formattedHawbNo = formatHawbNoForDisplay(hawbNo);
            if (!term || !formattedHawbNo.includes(term)) return formattedHawbNo;
            const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            return formattedHawbNo.split(new RegExp(`(${escapedTerm})`, 'gi')).map(part => part.toLowerCase() === term.toLowerCase() ? `<span class="bg-yellow-200 rounded px-0.5">${part}</span>` : part).join('');
        };
        
        // --- Render function ---
        const renderDeliveryCards = (animationClass = '') => {
            let currentFilteredData = deliveryItems;
            if (activeFilter === '배송준비') { deliveryCardsContainer.innerHTML = ''; return; }

            if (searchTerm) {
                const cleanedSearchTerm = searchTerm.replace(/\D/g, '');
                currentFilteredData = currentFilteredData.filter(item => item.hawbNo?.replace(/\D/g, '').includes(cleanedSearchTerm));
            }
            if (activeFilter !== '전체') {
                currentFilteredData = currentFilteredData.filter(item => item.status === activeFilter);
            }

            deliveryCardsContainer.classList.remove('animate-slide-in-left', 'animate-slide-in-right');
            deliveryCardsContainer.style.animation = '';

            if (currentFilteredData.length === 0) {
                deliveryCardsContainer.innerHTML = '<p class="text-center text-gray-600 px-4">해당하는 항목이 없습니다.</p>';
                return;
            }

            deliveryCardsContainer.innerHTML = currentFilteredData.map(data => {
                const isMapButtonActive = isValidAddressForMap(data.receiverAddressKorean);
                return `
                    <div class="${data.status === '배송중' ? 'bg-blue-100' : (data.status === '완료' ? 'bg-gray-200' : 'bg-white')} rounded-lg shadow-lg p-6 mb-4 border border-gray-200" data-no="${data.no}">
                        <div class="flex justify-between items-center mb-4 pb-2 border-b border-gray-200">
                            ${data.status !== '완료' ? `
                                <div class="flex items-center space-x-2 w-full justify-between">
                                    <h3 class="text-3xl font-semibold text-red-500">${data.no}</h3>
                                    <span class="text-base font-bold text-gray-600 whitespace-nowrap">${highlightHawbNo(data.hawbNo, searchTerm)}</span>
                                    <input type="checkbox" data-action="toggle-hawb-confirm" data-no="${data.no}" ${data.isHawbConfirmed ? 'checked' : ''} class="form-checkbox h-4 w-4 text-blue-600 border-gray-300 rounded"/>
                                </div>
                            ` : `
                                <div class="text-xl font-semibold text-gray-700 text-left w-full">
                                    <span class="text-red-500 text-2xl mr-8">${data.no}</span>
                                    ${data.completionType === '서명' && data.completionDetail ? `<span class="text-lg font-semibold text-gray-800 p-1 border border-dashed border-gray-400 rounded-md bg-gray-50 inline-block">${data.completionDetail}</span>` : data.completionType === '본인확인' ? `${data.completionType} (${data.completionDetail})` : `${data.completionType || ''}`}
                                    <span class="ml-4">${formatCompletionTime(data.deliveryCompletionTime)}</span>
                                </div>
                            `}
                        </div>
                        <div class="space-y-3" data-details-container="${data.no}" ${data.status === '완료' ? 'style="display:none;"' : ''}>
                            <div><p class="text-sm font-medium text-gray-700">주소:</p><div class="flex items-center justify-between">
                                <p class="text-base text-blue-600 font-semibold cursor-pointer" data-action="open-address-selection" data-no="${data.no}">${data.receiverAddressKorean}</p>
                                <button data-action="open-naver-map" data-address="${data.receiverAddressKorean}" data-no="${data.no}" class="${isMapButtonActive ? 'ml-2 px-3 py-1.5 rounded-full bg-green-500 text-white text-sm font-medium hover:bg-green-600' : 'ml-2 px-3 py-1.5 rounded-full bg-gray-300 text-gray-500 text-sm font-medium cursor-not-allowed opacity-50'}" ${isMapButtonActive ? '' : 'disabled'}>지도보기</button>
                            </div>${data.receiverAddressOriginal ? `<p class="text-xs text-gray-500 ml-1">(${data.receiverAddressOriginal})</p>` : ''}</div>
                            <div><p class="text-sm font-medium text-gray-700">회사명:</p><p class="text-base text-blue-600 font-semibold">${data.companyNameKorean || 'N/A'}</p>${data.companyNameOriginal && data.companyNameOriginal !== data.companyNameKorean ? `<p class="text-xs text-gray-500 ml-1">(${data.companyNameOriginal})</p>` : ''}</div>
                            <div><p class="text-sm font-medium text-gray-700">이름:</p><p class="text-base text-blue-600 font-semibold">${data.receiverNameKorean || 'N/A'}</p>${data.receiverNameOriginal && data.receiverNameOriginal !== data.receiverNameKorean ? `<p class="text-xs text-gray-500 ml-1">(${data.receiverNameOriginal})</p>` : ''}</div>
                            <div><p class="text-sm font-medium text-gray-700">전화번호:</p><div class="flex items-center space-x-2"><span class="text-base text-blue-600 font-semibold">${formatPhoneNumberForDisplay(data.receiverTelephoneNo)}</span><a href="tel:${getCleanPhoneNumber(data.receiverTelephoneNo)}" class="px-3 py-1.5 rounded-full bg-transparent text-orange-500 border border-orange-500 text-sm font-medium hover:bg-orange-100">전화</a><a href="sms:${getCleanPhoneNumber(data.receiverTelephoneNo)}" class="px-3 py-1.5 rounded-full bg-transparent text-blue-500 border border-blue-500 text-sm font-medium hover:bg-blue-100">문자</a></div></div>
                            ${data.status === '완료' ? `<div class="mt-4 pt-4 border-t border-gray-200 flex justify-center"><button data-action="revert-delivery" data-no="${data.no}" class="px-4 py-2 rounded-md bg-red-500 text-white text-sm font-medium">되돌리기</button></div>` : ''}
                        </div>
                        ${data.status === '배송중' ? `<div class="mt-4 pt-4 border-t border-gray-200 flex justify-between space-x-2"><button data-action="identity-verification" data-no="${data.no}" class="w-2/5 px-3 py-1.5 rounded-md bg-green-600 text-white text-sm font-medium">본인확인</button><button data-action="front-door-delivery" data-no="${data.no}" class="w-2/5 px-3 py-1.5 rounded-md bg-purple-600 text-white text-sm font-medium">문앞배송</button><button data-action="sign-delivery" data-no="${data.no}" class="w-1/5 px-3 py-1.5 rounded-md bg-indigo-600 text-white text-sm font-medium">서명</button></div>` : ''}
                        ${data.status === '완료' ? `<div class="pt-4 flex flex-col items-center"><button data-action="toggle-details" data-no="${data.no}" class="px-4 py-2 rounded-md bg-gray-300 text-gray-800 text-sm font-medium">상세보기</button></div>` : ''}
                </div>
            `;
        }).join('');
        
        if (animationClass) {
            deliveryCardsContainer.style.transform = 'translateX(0px)';
            deliveryCardsContainer.classList.add(animationClass);
            setTimeout(() => { deliveryCardsContainer.classList.remove(animationClass); animation = ''; }, 300);
        }
    };

    // --- UI Update & Event Listener Setup ---
    const updateFilterCounts = () => {
        document.getElementById('count-전체').textContent = deliveryItems.length;
        document.getElementById('count-배송전').textContent = deliveryItems.filter(item => item.status === '배송전').length;
        document.getElementById('count-배송중').textContent = deliveryItems.filter(item => item.status === '배송중').length;
        document.getElementById('count-완료').textContent = deliveryItems.filter(item => item.status === '완료').length;
    };
    
    const quickScrollContainer = document.getElementById('quick-scroll-container');
    const quickScrollHandle = document.getElementById('quick-scroll-handle');
    const quickScrollBubble = document.getElementById('quick-scroll-bubble');
    
    const updateStickyHeaderPositions = () => {
        requestAnimationFrame(() => {
            let topOffset = 0;
            const isSearchVisible = ['전체', '배송전'].includes(activeFilter);
            
            searchBarContainer.classList.toggle('hidden', !isSearchVisible);
            if (isSearchVisible) {
                searchBarContainer.style.top = `${topOffset}px`; 
                topOffset += searchBarContainer.offsetHeight;
            }
            
            filterButtonsContainer.style.top = `${topOffset}px`;
            topOffset += filterButtonsContainer.offsetHeight;
            document.body.style.paddingTop = `${topOffset}px`;

            const isScanVisible = activeFilter === '배송준비';
            scanSectionContainer.classList.toggle('hidden', !isScanVisible);
            dataManagementContainer.classList.toggle('hidden', !isScanVisible);
            versionInfoContainer.classList.toggle('hidden', !isScanVisible);

            const deliveryInProgressCount = deliveryItems.filter(item => item.status === '배송중').length;
            quickScrollContainer.style.display = (activeFilter === '배송중' && deliveryInProgressCount > 0) ? 'block' : 'none';
        });
    };
    
    filterButtonsContainer.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-filter]');
        if (!button || button.dataset.filter === activeFilter) return;

        filterScrollPositions[activeFilter] = window.scrollY;
        activeFilter = button.dataset.filter;

        filterButtonsContainer.querySelectorAll('button').forEach(btn => {
            const isActive = btn.dataset.filter === activeFilter;
            btn.classList.remove('bg-blue-500', 'text-white', 'shadow', 'bg-transparent', 'text-gray-700', 'border', 'border-gray-300', 'hover:bg-gray-100');
            if (isActive) {
                btn.classList.add('bg-blue-500', 'text-white', 'shadow');
            } else {
                btn.classList.add('bg-transparent', 'text-gray-700', 'border', 'border-gray-300', 'hover:bg-gray-100');
            }
        });

        renderDeliveryCards();
        updateStickyHeaderPositions();
        button.scrollIntoView({ behavior: 'smooth', inline: 'center' });
        setTimeout(() => window.scrollTo({ top: filterScrollPositions[activeFilter] || 0, behavior: 'auto' }), 0);
    });

    searchButton.addEventListener('click', () => { searchTerm = invoiceNumberInput.value.replace(/\D/g, ''); renderDeliveryCards(); window.scrollTo({ top: 0, behavior: 'auto' }); filterScrollPositions[activeFilter] = 0; });
    resetButton.addEventListener('click', () => { filterScrollPositions[activeFilter] = window.scrollY; searchTerm = ''; invoiceNumberInput.value = ''; renderDeliveryCards(); setTimeout(() => window.scrollTo({ top: filterScrollPositions[activeFilter] || 0, behavior: 'auto' }), 0); });
    invoiceNumberInput.addEventListener('input', (event) => { searchTerm = event.target.value.replace(/\D/g, ''); renderDeliveryCards(); window.scrollTo({ top: 0, behavior: 'auto' }); filterScrollPositions[activeFilter] = 0; });

    deliverySheetImageInput.addEventListener('change', (event) => {
        currentFileToScan = event.target.files;
        selectedFilesDisplay.textContent = currentFileToScan.length > 0 ? `선택된 파일: ${Array.from(currentFileToScan).map(f => f.name).join(', ')}` : '선택된 파일 없음';
    });
    
    clearAllCardsButton.addEventListener('click', () => {
        openConfirmationModal("모든 카드를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.", () => {
            deliveryItems = [];
            saveDeliveryItemsToLocalStorage();
            renderDeliveryCards();
            updateFilterCounts();
            showMessage("모든 카드가 삭제되었습니다.");
        });
    });

    // --- Scan, Import, Export Logic ---
    async function validateAddressWithKakao(geminiAddress) {
        if (!KAKAO_API_KEY || !geminiAddress) return geminiAddress;

        let queryAddress = geminiAddress;
        let detailedPart = '';

        const addressComponents = geminiAddress.split(',');
        if (addressComponents.length > 1) {
            queryAddress = addressComponents[0].trim();
            detailedPart = addressComponents.slice(1).join(', ').trim();
        }
        
        queryAddress = queryAddress.replace(/^(서울|부산|대구|인천|광주|대전|울산|세종|경기|강원|충청북도|충청남도|전라북도|전라남도|경상북도|경상남도|제주특별자치도|충북|충남|전북|전남|경북|경남|제주)(특별시|광역시|특별자치시|도)?\s*/, '').trim();
        queryAddress = queryAddress.replace(/^([가-힣]+(?:시|군|구))\s*/, '').trim();
        queryAddress = queryAddress.replace(/^([가-힣]+(?:읍|면))\s*/, '').trim();
        queryAddress = queryAddress.replace(/떡정골로/g, "떡전골로");
        queryAddress = queryAddress.replace(/바란리/g, "발안리");

        try {
            const response = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(queryAddress)}`, {
                headers: { 'Authorization': `KakaoAK ${KAKAO_API_KEY}` }
            });
            
            if (!response.ok) {
                console.error("카카오 API 응답 오류:", response.status, await response.text());
                return geminiAddress; 
            }

            const data = await response.json();
            if (data.documents && data.documents.length > 0) {
                const firstResult = data.documents[0];
                const roadAddress = firstResult.road_address;
                const jibunAddress = firstResult.address;

                let correctedBaseAddress = '';
                if (roadAddress && roadAddress.address_name) {
                    correctedBaseAddress = roadAddress.address_name;
                } else if (jibunAddress && jibunAddress.address_name) {
                    correctedBaseAddress = jibunAddress.address_name;
                }

                if (correctedBaseAddress) {
                    if (detailedPart && !correctedBaseAddress.includes(detailedPart)) {
                        return `${correctedBaseAddress}, ${detailedPart}`;
                    }
                    return correctedBaseAddress;
                }
            }
            return geminiAddress; 
        } catch (error) {
            console.error("카카오 주소 검증 API 오류:", error);
            return geminiAddress; 
        }
    }

    async function performScan(filesToScan) {
        const tempMergedResults = new Map(); 
        const failedFileObjectsForRetry = [];
        
        for (let i = 0; i < filesToScan.length; i++) {
            const file = filesToScan[i];
            scanProgressText.textContent = `이미지 분석 중 (${i + 1}/${filesToScan.length})...`;
            
            try {
                const base64ImageData = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });

                const payload = {
                    contents: [{ role: "user", parts: [{ text: GEMINI_PROMPT }, { inlineData: { mimeType: file.type, data: base64ImageData } }] }],
                    generationConfig: { 
                        temperature: 0,
                        responseMimeType: "application/json",
                        responseSchema: { type: "ARRAY", items: { type: "OBJECT", properties: { "no": { "type": "STRING" }, "hawbNo": { "type": "STRING" }, "receiverAddressKorean": { "type": "STRING" }, "receiverAddressOriginal": { "type": "STRING" }, "companyNameKorean": { "type": "STRING" }, "companyNameOriginal": { "type": "STRING" }, "receiverNameKorean": { "type": "STRING" }, "receiverNameOriginal": { "type": "STRING" }, "receiverTelephoneNo": { "type": "STRING" }, "receiverAddressComponents": { "type": "ARRAY", "items": { "type": "STRING" } } } } }
                    } 
                };
                
                const tempApiKeyForLocalTest = "AIzaSyCNYPhrVzBC-wQoZU3ftYEznfUZv3vZEFs";
                const directApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${tempApiKeyForLocalTest}`;

                const response = await fetch(directApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { throw new Error(`API 요청 실패 (상태: ${response.status})`); }
                const result = await response.json();

                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    try {
                        const parsedData = JSON.parse(result.candidates[0].content.parts[0].text);
                        if (Array.isArray(parsedData) && parsedData.length > 0) {
                            for (const geminiItem of parsedData) { 
                                const no = parseInt(geminiItem.no || '0', 10);
                                if (no === 0 || !geminiItem.hawbNo || geminiItem.hawbNo.trim() === '') {
                                    console.warn(`유효하지 않은 송장 정보 발견 (No: ${geminiItem.no}, HAWB: ${geminiItem.hawbNo}) - 파일 ${file.name}`);
                                    continue; 
                                }

                                scanProgressText.textContent = `송장 ${no}번 주소 검증 중 (${file.name})...`;
                                const validatedAddress = await validateAddressWithKakao(geminiItem.receiverAddressKorean);
                                
                                tempMergedResults.set(no, { 
                                    ...geminiItem, 
                                    receiverAddressKorean: validatedAddress || geminiItem.receiverAddressKorean, 
                                    receiverAddressComponents: geminiItem.receiverAddressComponents || [] 
                                });
                            }
                        } else { throw new Error("이미지에서 유효한 데이터를 찾지 못했습니다."); }
                    } catch (parseError) {
                        console.warn(`Gemini JSON 파싱 실패 (파일 ${file.name}):`, parseError);
                    }
                } else { throw new Error("API가 분석 가능한 텍스트를 반환하지 않았습니다."); }
            } catch (error) {
                console.error(`파일 스캔 오류 (${file.name}):`, error);
                failedFileObjectsForRetry.push(file);
                continue;
            }
        }

        let newCount = 0;
        let updateCount = 0;
        const allNewItems = Array.from(tempMergedResults.values()); 

        if (allNewItems.length > 0) {
            const finalItems = allNewItems.map(item => ({
                no: parseInt(item.no, 10),
                hawbNo: item.hawbNo || '',
                receiverAddressKorean: item.receiverAddressKorean || '',
                receiverAddressOriginal: cleanStringForDisplay(item.receiverAddressOriginal),
                companyNameKorean: item.companyNameKorean || '',
                companyNameOriginal: cleanStringForDisplay(item.companyNameOriginal),
                receiverNameKorean: item.receiverNameKorean || '',
                receiverNameOriginal: cleanStringForDisplay(item.receiverNameOriginal),
                receiverTelephoneNo: item.receiverTelephoneNo ? getCleanPhoneNumber(item.receiverTelephoneNo) : '',
                status: '배송전', isHawbConfirmed: false,
                deliveryCompletionTime: null, completionType: null, completionDetail: null,
                receiverAddressComponents: item.receiverAddressComponents || [] 
            }));
            
            finalItems.forEach(newItem => {
                const existingItemIndex = deliveryItems.findIndex(item => item.no === newItem.no);
                if (existingItemIndex > -1) {
                    deliveryItems[existingItemIndex] = newItem;
                    updateCount++;
                } else {
                    deliveryItems.push(newItem);
                    newCount++;
                }
            });
            deliveryItems.sort((a, b) => a.no - b.no);
            saveDeliveryItemsToLocalStorage();
        }
        return { newCount, updateCount, failedFiles: failedFileObjectsForRetry };
    }

    scanAndGenerateButton.addEventListener('click', async () => {
        if (!currentFileToScan || currentFileToScan.length === 0) { showMessage('스캔할 이미지를 선택해주세요.'); return; }
        
        scanLoadingIndicator.style.display = 'block';
        scanErrorMessage.style.display = 'none';
        failedFileObjects = []; 

        try {
            const initialFiles = Array.from(currentFileToScan);
            const result = await performScan(initialFiles);

            if (result.failedFiles.length === 0) {
                showMessage(`${result.updateCount}개의 카드가 업데이트되고 ${result.newCount}개의 카드가 새로 생성되었습니다.`);
            } else {
                failedFileObjects = result.failedFiles;
                const successCount = initialFiles.length - failedFileObjects.length;
                const failedFileNames = failedFileObjects.map(f => f.name);
                
                const message = `총 ${initialFiles.length}개 중 ${successCount}개 파일 스캔 성공.\n\n실패한 ${failedFileObjects.length}개 파일을 다시 스캔하시겠습니까?\n- ${failedFileNames.join('\n- ')}`;

                const onRetry = async () => {
                    scanLoadingIndicator.style.display = 'block';
                    scanProgressText.textContent = '실패한 파일 재시도 중...';
                    
                    const retryResult = await performScan(failedFileObjects);

                    scanLoadingIndicator.style.display = 'none';

                    if (retryResult.failedFiles.length === 0) {
                        showMessage(`재시도 성공: ${retryResult.updateCount + retryResult.newCount}개의 카드가 추가/업데이트되었습니다.`);
                    } else {
                        const stillFailingNames = retryResult.failedFiles.map(f => f.name);
                        showMessage(`재시도 후에도 아래 ${stillFailingNames.length}개 파일이 실패했습니다.\n- ${stillFailingNames.join('\n- ')}`, '재시도 일부 실패');
                    }
                    renderDeliveryCards();
                    updateFilterCounts();
                };
                openConfirmationModal(message, onRetry, '실패 파일 재시도', '나중에');
            }
        } catch (error) {
            console.error("전체 스캔 프로세스 오류:", error);
            scanErrorText.textContent = error.message;
            scanErrorMessage.style.display = 'block';
        } finally {
            scanLoadingIndicator.style.display = 'none';
            deliverySheetImageInput.value = '';
            currentFileToScan = null;
            selectedFilesDisplay.textContent = '선택된 파일 없음';
            renderDeliveryCards();
            updateFilterCounts();
            updateStickyHeaderPositions();
        }
    });
    
    exportDataButton.addEventListener('click', () => {
        if (deliveryItems.length === 0) { showMessage("저장할 데이터가 없습니다."); return; }
        try {
            const today = new Date();
            const formattedDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            const fileName = `SF-${formattedDate}.json`;
            const dataStr = JSON.stringify(deliveryItems, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage(`데이터가 '${fileName}' 파일로 저장되었습니다.`);
        } catch (error) {
            showMessage(`데이터 저장 중 오류가 발생했습니다: ${error.message}`, "오류");
        }
    });

    importDataInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        openConfirmationModal( `'${file.name}' 파일의 데이터로 현재 목록을 모두 덮어씁니다. 계속하시겠습니까?`, () => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (!Array.isArray(importedData)) throw new Error("파일 형식이 올바르지 않습니다 (배열이 아님).");
                        if (importedData.length > 0 && typeof importedData[0].no === 'undefined') throw new Error("파일 내용이 올바른 배송 데이터 형식이 아닙니다.");
                        deliveryItems = importedData;
                        saveDeliveryItemsToLocalStorage();
                        updateFilterCounts();
                        updateStickyHeaderPositions();
                        renderDeliveryCards();
                        showMessage(`'${file.name}' 파일에서 ${deliveryItems.length}개의 항목을 불러왔습니다.`);
                    } catch (error) {
                        showMessage(`파일을 불러오는 중 오류가 발생했습니다: ${error.message}`, "오류");
                    } finally {
                        importDataInput.value = '';
                    }
                };
                reader.onerror = () => { showMessage("파일을 읽는 데 실패했습니다.", "오류"); importDataInput.value = ''; };
                reader.readAsText(file);
            }
        );
    });

    // --- Swipe & Initial Load ---
    let touchStartX = 0, touchStartY = 0;
    document.body.addEventListener('touchstart', e => { touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; }, { passive: true });
    document.body.addEventListener('touchmove', e => { if (Math.abs(e.touches[0].clientX - touchStartX) > 10 && Math.abs(e.touches[0].clientX - touchStartX) > Math.abs(e.touches[0].clientY - touchStartY)) e.preventDefault(); }, { passive: false });
    document.body.addEventListener('touchend', e => {
        const swipeDistanceX = e.changedTouches[0].clientX - touchStartX;
        if (Math.abs(swipeDistanceX) > 50 && Math.abs(swipeDistanceX) > Math.abs(e.changedTouches[0].clientY - touchStartY)) {
            const currentIndex = filterCategories.indexOf(activeFilter);
            const direction = swipeDistanceX > 0 ? -1 : 1;
            const newIndex = Math.max(0, Math.min(filterCategories.length - 1, currentIndex + direction));
            if (newIndex !== currentIndex) filterButtonsContainer.querySelector(`[data-filter="${filterCategories[newIndex]}"]`)?.click();
        }
    });
    
    // ✨ 퀵-스크롤 핸들 로직 ("디지털 다이얼" 최종 버전) ✨
    const setupQuickScroll = () => {
        let isDragging = false;
        let cardElementsCache = [];
        let cardPositionsCache = [];
        let lastScrolledIndex = -1;
        let headerHeight = 0;

        const onDragStart = (e) => {
            e.preventDefault();
            isDragging = true;
            quickScrollHandle.classList.add('active');
            quickScrollBubble.style.display = 'block';
            
            cardElementsCache = Array.from(deliveryCardsContainer.querySelectorAll('[data-no]'));
            if (cardElementsCache.length === 0) { onDragEnd(); return; }
            
            headerHeight = filterButtonsContainer.offsetTop + filterButtonsContainer.offsetHeight;
            cardPositionsCache = cardElementsCache.map(card => card.offsetTop - headerHeight);
            
            onDrag(e);
        };
        
        const onDragEnd = () => {
            if (!isDragging) return;
            isDragging = false;
            quickScrollHandle.classList.remove('active');
            quickScrollBubble.style.display = 'none';
            lastScrolledIndex = -1;
        };

        const onDrag = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            
            const clientY = e.clientY || e.touches[0].clientY;
            
            const usableScreenHeight = window.innerHeight / 2;
            const usableScreenTop = window.innerHeight / 2;
            let percentage = (clientY - usableScreenTop) / usableScreenHeight;
            percentage = Math.max(0, Math.min(1, percentage));

            const targetIndex = Math.floor(percentage * (cardElementsCache.length - 1) + 0.5);

            const handleHeight = quickScrollHandle.offsetHeight;
            let handleTop = clientY - (handleHeight / 2);
            handleTop = Math.max(0, Math.min(window.innerHeight - handleHeight, handleTop));
            quickScrollHandle.style.top = `${handleTop}px`;
            quickScrollBubble.style.top = `${handleTop + (handleHeight / 2)}px`;

            if (targetIndex !== -1 && cardElementsCache[targetIndex]) {
                quickScrollBubble.textContent = cardElementsCache[targetIndex].dataset.no;

                if (targetIndex !== lastScrolledIndex) {
                    const targetPosition = cardPositionsCache[targetIndex];
                    window.scrollTo({ top: targetPosition, behavior: 'auto' });
                    
                    if (navigator.vibrate) navigator.vibrate(20); 
                    lastScrolledIndex = targetIndex;
                }
            }
        };

        const updateHandleOnScroll = () => {
            if (isDragging) return; 

            headerHeight = filterButtonsContainer.offsetTop + filterButtonsContainer.offsetHeight;
            const currentScroll = window.scrollY;
            
            cardPositionsCache = Array.from(deliveryCardsContainer.querySelectorAll('[data-no]')).map(card => card.offsetTop - headerHeight);
            if(cardPositionsCache.length === 0) return;

            let closestIndex = 0;
            for(let i=0; i<cardPositionsCache.length; i++) {
                if (cardPositionsCache[i] <= currentScroll + 1) {
                    closestIndex = i;
                } else {
                    break;
                }
            }
            
            const percentage = cardPositionsCache.length > 1 ? closestIndex / (cardElementsCache.length - 1) : 0; 
            
            const usableScreenHeight = window.innerHeight / 2;
            const usableScreenTop = window.innerHeight / 2;
            const handleHeight = quickScrollHandle.offsetHeight;

            let handleTop = usableScreenTop + (percentage * usableScreenHeight);
            handleTop = handleTop - (handleHeight / 2);
            handleTop = Math.max(0, Math.min(window.innerHeight - handleHeight, handleTop));
            
            quickScrollHandle.style.top = `${handleTop}px`;
        };

        quickScrollContainer.addEventListener('mousedown', onDragStart);
        quickScrollContainer.addEventListener('touchstart', onDragStart, { passive: false });

        window.addEventListener('mousemove', onDrag);
        window.addEventListener('touchmove', onDrag, { passive: false });
        
        window.addEventListener('mouseup', onDragEnd);
        window.addEventListener('touchend', onDragEnd);
        
        let scrollTimeout;
        window.addEventListener('scroll', () => {
             clearTimeout(scrollTimeout);
             scrollTimeout = setTimeout(updateHandleOnScroll, 100);
        });
    };
    
    const setVersionInfo = () => {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        const HH = String(now.getHours()).padStart(2, '0');
        const MM = String(now.getMinutes()).padStart(2, '0');
        
        versionText.textContent = `v0.${yyyy}${mm}${dd}.${HH}${MM}`;
        versionChangelog.textContent = `주소 편집 모달 UI/UX 개선`;
    };

    const setupDelegatedEventListeners = () => {
        deliveryCardsContainer.addEventListener('click', (event) => {
            const targetElement = event.target;
            const action = targetElement.dataset.action;
            const itemNo = parseInt(targetElement.dataset.no);
            const item = deliveryItems.find(i => i.no === itemNo);
            
            if (!item) return; 

            if (action === 'open-address-selection') {
                openAddressSelectionModal(itemNo);
                return; 
            }

            const button = event.target.closest('[data-action]');
            if (!button) return; 

            switch (action) {
                case 'open-naver-map': 
                    if (!button.disabled) {
                        openNaverMap(item.receiverAddressKorean, item.no); 
                    } else {
                        showMessage('유효하지 않은 주소입니다.');
                    }
                    break;
                case 'identity-verification': 
                    openConfirmationModal(`HAWB ${item.hawbNo} 본인확인 처리하시겠습니까?`, () => handleStatusChange(itemNo, '완료', new Date().toLocaleString('ko-KR', dateTimeFormatOptions), '본인확인', item.receiverNameKorean)); 
                    break;
                case 'front-door-delivery': 
                    openConfirmationModal(`HAWB ${item.hawbNo} 문앞배송 처리하시겠습니까?`, () => handleStatusChange(itemNo, '완료', new Date().toLocaleString('ko-KR', dateTimeFormatOptions), '문앞배송')); 
                    break;
                case 'sign-delivery': openSignatureModal(itemNo); break;
                case 'revert-delivery': openConfirmationModal(`HAWB ${item.hawbNo} 상태를 되돌리시겠습니까?`, () => handleStatusChange(itemNo, '배송중')); break;
                case 'toggle-details': const details = document.querySelector(`[data-details-container="${itemNo}"]`); if (details) { details.style.display = details.style.display === 'none' ? '' : 'none'; button.textContent = details.style.display === 'none' ? '상세보기' : '접기'; } break;
            }
        });
        deliveryCardsContainer.addEventListener('change', (event) => {
            const checkbox = event.target.closest('[data-action="toggle-hawb-confirm"]');
            if (checkbox) handleCheckboxToggleAndResetSearch(parseInt(checkbox.dataset.no), checkbox.checked);
        });
    };

    document.addEventListener('DOMContentLoaded', () => {
        try {
            setVersionInfo();
            setupDelegatedEventListeners();
            setupQuickScroll();
            const storedItems = localStorage.getItem('deliveryItems');
            if (storedItems) deliveryItems = JSON.parse(storedItems).sort((a, b) => a.no - b.no);
            const storedScroll = localStorage.getItem('filterScrollPositions');
            if (storedScroll) filterScrollPositions = JSON.parse(storedScroll);
            updateFilterCounts();

            const initialBtn = filterButtonsContainer.querySelector(`[data-filter="배송준비"]`);
            if (initialBtn) {
                initialBtn.click();
            }

        } catch (error) {
            console.error("초기화 오류:", error);
            document.body.innerHTML = `<div class="p-4 text-red-500">앱 로딩 중 오류가 발생했습니다. 오류: ${error.message}</div>`;
        }
    });
</script>
</body>
</html>