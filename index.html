<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>배송 시트</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>

.map-select-btn {
            color: #4b5563; /* gray-600 */
        }
        .map-select-btn.active {
            background-color: white;
            color: #1f2937; /* gray-800 */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .map-icon-button {
            width: 28px;
            height: 28px;
            flex-shrink: 0;
        }
        .map-icon-button.naver {
            background-color: #2DB400;
        }
        .map-icon-button.naver svg {
            stroke: white;
        }
        .map-icon-button.kakao {
            background-color: #FEE500;
        }
        .map-icon-button.kakao svg {
            stroke: #0085FF;
        }

        #refresh-indicator {
            transform: translateY(-100%);
            transition: transform 0.3s, opacity 0.3s;
            z-index: 10; /* 카드가 위로 올라오지 않도록 z-index 추가 */
        }
        #refresh-indicator.visible {
            opacity: 1;
            transform: translateY(1rem); /* 보기 좋게 살짝 위에서 띄움 */
        }
        html {
    scroll-behavior: smooth !important;
    height: 100%;
    /* ⚠️ html의 overflow: hidden을 반드시 제거하고 auto로 변경 */
    overflow: auto; 
}
body {
    font-family: 'Inter', sans-serif;
    margin: 0;
    height: 100%;
    overflow-y: auto; /* body는 기본적으로 스크롤 가능하게 */
    overscroll-behavior: contain; /* 스크롤 체이닝 방지 */
}

/* 모달이 열렸을 때 body 스크롤을 잠그기 위한 스타일 (JS로 제어) */
body.modal-open {
    overflow: hidden;
}

.signature-modal, .confirmation-modal, .smart-edit-modal, .number-jump-modal {
    position: fixed;
    inset: 0; /* top, right, bottom, left를 0으로 설정 */
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1.5rem;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 50;
}

.confirmation-modal { z-index: 51; }

.signature-modal-content, .confirmation-modal-content, .smart-edit-modal-content, .number-jump-modal-content {
    background-color: white;
    border-radius: 0.5rem;
    box-shadow: 0 10px 15px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
    padding: 1.5rem;
    width: 100%;
    max-width: 28rem; /* 카드 가로폭과 동일하게 */
    max-height: calc(100vh - 3rem); /* 화면을 넘지 않도록 높이 제한 */
    display: flex;
    flex-direction: column;
    overflow: hidden; /* 내부 스크롤은 별도 영역에서 처리하도록 기본은 숨김 */
}

/* 스크롤이 필요한 영역에만 스크롤 적용 */

/* 모바일에서 모달 내부 스크롤을 부드럽게 하고 스크롤 체이닝을 방지 */
#smart-edit-scroll-area, #number-jump-list {
    -webkit-overflow-scrolling: touch; /* iOS 부드러운 스크롤 */
    overscroll-behavior: contain; /* 스크롤 체이닝(배경으로 넘어가는 스크롤) 방지 */
}
#smart-edit-scroll-area, #number-jump-list {
    flex: 1 1 auto; /* 남는 공간을 차지하고, 내용이 많으면 줄어들도록 설정 */
    overflow-y: auto;
    -webkit-overflow-scrolling: touch; /* iOS 부드러운 스크롤 */
}
        
        .key-button { position: relative; overflow: visible !important; -webkit-tap-highlight-color: transparent; }
        .key-pop {
            position: absolute;
            bottom: 80%;
            left: 50%;
            transform: translateX(-50%) scale(0.8);
            transform-origin: bottom center;
            background-color: #374151; /* gray-700 */
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 1.25rem;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 10;
            min-width: 100%;
            text-align: center;
            white-space: nowrap;
        }
        .key-button:active .key-pop {
            opacity: 1;
            transform: translateX(-50%) scale(1) translateY(-8px);
        }
        .filter-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            border-radius: 9999px;
            background-color: #2563eb; /* blue-600 */
            color: white;
            font-size: 12px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            transition: transform 0.2s, opacity 0.2s;
            transform: scale(1);
            opacity: 1;
        }
        .filter-badge.hidden {
            transform: scale(0.5);
            opacity: 0;
            pointer-events: none;
        }
        #address-pieces-container button { margin: 0.25rem; padding: 0.25rem 0.75rem; border-radius: 9999px; font-size: 0.875rem; font-weight: 500; transition: background-color 0.2s; }

        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #2563eb; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .animate-slide-in-left { animation: slideInLeft 0.3s ease-out forwards; }
        @keyframes slideInLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .animate-slide-in-right { animation: slideInRight 0.3s ease-out forwards; }
        @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        #delivery-cards-container { transition: transform 0.1s ease-out; will-change: transform; }
        #toast-container { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; flex-direction: column; align-items: center; gap: 8px; pointer-events: none; }
        .toast-message { background-color: rgba(0, 0, 0, 0.75); color: white; padding: 10px 20px; border-radius: 20px; font-size: 0.875rem; box-shadow: 0 2px 10px rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.5s, transform 0.5s; transform: translateY(20px); }
        .toast-message.show { opacity: 1; transform: translateY(0); }
        #number-jump-list { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem; overflow-y: auto; padding: 0.5rem; margin: -0.5rem; max-height: 60vh; }
        .number-jump-item { min-width: 50px; padding: 0.75rem; border-radius: 0.5rem; font-weight: 600; text-align: center; transition: background-color 0.2s, color 0.2s; }
        .number-jump-item.active { background-color: #2563eb; color: white; cursor: pointer; }
        .number-jump-item.active:hover { background-color: #1d4ed8; }
        .number-jump-item.inactive { background-color: #f3f4f6; color: #9ca3af; cursor: not-allowed; }
        .number-jump-item.placeholder { background-color: transparent; }
        .bottom-bar { position: fixed; bottom: 0; left: 0; width: 100vw; z-index: 46; transition: transform 0.3s ease-out; background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border-top: 1px solid #e5e7eb; }
        .bottom-bar.hidden { transform: translateY(100%); }
        .completed-strikethrough {
            text-decoration: line-through;
            color: #6b7280; /* gray-500 */
        }
        #fab-options button {
            width: 0;
            padding: 0;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s ease-in-out;
        }
        #fab-options.expanded button {
            width: 3rem; /* w-12 */
            padding: 0.75rem; /* p-3 와 유사 */
            opacity: 1;
            transform: scale(1);
        }
        #search-bar {
    /* 카드와 유사한 느낌의 그림자 효과 */
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
    border: 2px solid #2563eb; /* blue-600 색상의 2px 테두리 추가 */

}
    </style>
</head>
<body class="bg-white font-sans">
    <div id="app-container" class="h-screen flex flex-col">

        <div id="filter-buttons-container" class="z-20 flex-shrink-0 bg-white shadow-md">
            <div class="max-w-md mx-auto w-full min-w-[320px] p-2">
                <div class="flex justify-around">
                    <!-- 배송준비 버튼 -->
                    <button data-filter="배송준비" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8"/><path d="M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg>
                    </button>
                    <!-- 전체 버튼 -->
                    <button data-filter="전체" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M3 5h.01"/><path d="M3 12h.01"/><path d="M3 19h.01"/><path d="M8 5h13"/><path d="M8 12h13"/><path d="M8 19h13"/></svg>
                        <span id="count-전체" class="filter-badge">0</span>
                    </button>
                    <!-- 배송전 버튼 -->
                    <button data-filter="배송전" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z"/><path d="M12 22V12"/><polyline points="3.29 7 12 12 20.71 7"/><path d="m7.5 4.27 9 5.15"/></svg>
                        <span id="count-배송전" class="filter-badge">0</span>
                    </button>
                    <!-- 배송중 버튼 -->
                    <button data-filter="배송중" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M14 18V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v11a1 1 0 0 0 1 1h2"/><path d="M15 18H9"/><path d="M19 18h2a1 1 0 0 0 1-1v-3.65a1 1 0 0 0-.22-.624l-3.48-4.35A1 1 0 0 0 17.52 8H14"/><circle cx="17" cy="18" r="2"/><circle cx="7" cy="18" r="2"/></svg>
                        <span id="count-배송중" class="filter-badge">0</span>
                    </button>
                    <!-- 완료 버튼 -->
                    <button data-filter="완료" class="relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M21.801 10A10 10 0 1 1 17 3.335"/><path d="m9 11 3 3L22 4"/></svg>
                        <span id="count-완료" class="filter-badge">0</span>
                    </button>
                </div>
            </div>
        </div>

        <div id="main-content-wrapper" class="flex-1 overflow-y-auto min-h-0 relative" style="overscroll-behavior: contain;">
            <!-- ▼▼▼ [아래 div 추가] ▼▼▼ -->
            <div id="refresh-indicator" class="absolute top-0 left-0 right-0 flex justify-center items-center h-12 opacity-0 transition-opacity duration-300 pointer-events-none">
                <div class="spinner"></div>
            </div>
            <!-- ▲▲▲ [추가 끝] ▲▲▲ -->
            <div class="max-w-md mx-auto p-4 sm:p-6 lg:p-8">
                <div id="data-management-container" class="mb-6 p-4 bg-white rounded-lg shadow-lg w-full min-w-[320px] space-y-4 hidden">
                    <!-- ▼▼▼ [이 블록 추가] ▼▼▼ -->
                    <div>
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">지도 앱 선택</h3>
                        <div id="map-selection-container" class="flex space-x-2 rounded-lg bg-gray-100 p-1">
                            <button data-map="naver" class="map-select-btn flex-1 py-2 text-sm font-semibold rounded-md transition-colors">네이버 지도</button>
                            <button data-map="kakao" class="map-select-btn flex-1 py-2 text-sm font-semibold rounded-md transition-colors">카카오맵</button>
                        </div>
                    </div>
                    <!-- ▲▲▲ [추가 끝] ▲▲▲ -->
                    <div>
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">데이터 내보내기/가져오기</h3>
                        <div class="flex space-x-2">
                            <button id="exportDataButton" class="w-1/2 px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500">데이터 파일로 저장</button>
                            <label for="importDataInput" class="w-1/2 px-4 py-2 bg-sky-600 text-white rounded-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 text-center cursor-pointer">파일에서 불러오기</label>
                            <input type="file" id="importDataInput" class="hidden" accept=".json"/>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">오류 로그 관리</h3>
                        <div class="flex space-x-2">
                            <button id="viewLogsButton" class="w-1/2 px-4 py-2 bg-yellow-600 text-white rounded-md hover:bg-yellow-700 focus:outline-none focus:ring-2 focus:ring-yellow-500">로그 기록 보기</button>
                            <button id="clearLogsButton" class="w-1/2 px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500">로그 기록 삭제</button>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">카드 초기화</h3>
                        <button id="clearAllCardsButton" class="w-full px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">모든 카드 삭제</button>
                    </div>
                </div>

                <div id="scan-section-container" class="mb-6 p-4 bg-white rounded-lg shadow-lg w-full min-w-[320px] hidden">
                    <h3 class="text-lg font-semibold text-gray-800 mb-3">송장 스캔하여 카드 생성</h3>
                    <div class="flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 sm:space-x-3">
                        <input type="file" id="deliverySheetImage" accept="image/*" multiple class="hidden"/>
                        <label for="deliverySheetImage" class="flex-1 w-full text-sm text-blue-700 py-2 px-4 rounded-md border border-blue-300 bg-blue-50 font-semibold cursor-pointer hover:bg-blue-100 text-center whitespace-nowrap">사진 선택</label>
                        <button id="scanAndGenerateButton" class="w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">스캔하여 카드 생성</button>
                    </div>
                    <div id="selected-files-display" class="mt-2 text-sm text-gray-600 text-center">선택된 파일 없음</div>
                    <div id="scan-loading-indicator" class="hidden mt-3 text-center text-sm text-blue-600">
                        <div class="spinner mx-auto mb-2"></div>
                        <p id="scan-progress-text">송장 스캔 중...</p>
                    </div>
                    <div id="scan-error-message" class="hidden mt-3 text-center text-sm text-red-600">스캔 실패: <span id="scan-error-text"></span></div>
                </div>
                
                <div id="version-info-container" class="mb-6 text-center hidden">
                    <p id="version-text" class="text-xs text-gray-600 font-mono"></p>
                    <p id="version-changelog" class="text-xs text-gray-500"></p>
                </div>

                <div id="delivery-cards-container" class="pb-14"></div>
            </div>
        </div>
    </div>

    <div id="toast-container"></div>

    <div id="search-bar-container" class="fixed bottom-0 left-0 w-full z-40">
        <!-- 카드 목록의 부모와 동일한 구조로 변경 -->
        <div class="max-w-md mx-auto px-4 sm:px-6 lg:px-8 pb-3">
            <div id="search-bar" class="flex items-center w-full p-1.5 rounded-2xl bg-white/90 backdrop-blur-md border border-gray-200">
                <!-- 검색 아이콘 -->
                <div class="pl-2 pr-1 text-gray-400">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
                </div>
                <!-- 검색창 -->
                <input type="tel" id="invoiceNumber" name="invoiceNumber" placeholder="송장번호 또는 전화번호 검색" class="flex-grow px-2 py-2 bg-transparent border-none focus:ring-0 outline-none text-base" inputmode="numeric" pattern="[0-9]*"/>
                <!-- 지움 버튼 -->
                <button id="resetButton" class="w-10 h-10 flex-shrink-0 flex items-center justify-center text-gray-500 hover:text-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M10 5a2 2 0 0 0-1.344.519l-6.328 5.74a1 1 0 0 0 0 1.481l6.328 5.741A2 2 0 0 0 10 19h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2z"/><path d="m12 9 6 6"/><path d="m18 9-6 6"/></svg>
                </button>
            </div>
        </div>
    </div>

    <div id="action-bar-container" class="fixed bottom-0 left-0 w-full z-40 pointer-events-none">
        <div class="max-w-md mx-auto w-full min-w-[320px] p-4 flex justify-end">
            <div id="fab-panel" class="flex items-center space-x-1 p-1.5 rounded-full bg-white/80 backdrop-blur-md shadow-lg border border-gray-200 pointer-events-auto">
                <div id="fab-options" class="flex items-center space-x-1"></div>
                <button id="fab-main-button" class="w-10 h-10 flex-shrink-0 flex items-center justify-center rounded-full transition-colors duration-200">
                    <!-- 메인 아이콘은 JS가 여기에 동적으로 추가합니다. -->
                </button>
            </div>
        </div>
    </div>

    <div id="number-jump-modal" class="number-jump-modal" style="display: none;">
        <div class="number-jump-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800">번호로 이동</h2>
            <div id="number-jump-list">
                <!-- 번호 버튼들이 여기에 동적으로 추가됩니다. -->
            </div>
            <div class="flex justify-end mt-6">
                <button id="number-jump-close" class="px-4 py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500 text-sm font-medium">닫기</button>
            </div>
        </div>
    </div>

    <div id="signature-modal" class="signature-modal" style="display: none;">
        <div class="signature-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800">서명 입력</h2>
            <div class="signature-input-container">
                <textarea id="signature-text-input" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" rows="3" placeholder="여기에 서명 내용을 입력하세요."></textarea>
            </div>
            <div class="flex justify-end space-x-2 mt-4">
                <button id="clearSignature" class="px-4 py-2 rounded-md bg-gray-300 text-gray-800 text-sm font-medium hover:bg-gray-400">지우기</button>
                <button id="cancelSignature" class="px-4 py-2 rounded-md bg-red-500 text-white text-sm font-medium hover:bg-red-600">취소</button>
                <button id="saveSignature" class="px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">저장</button>
            </div>
        </div>
    </div>

    <div id="confirmation-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-4 text-gray-800" id="confirmation-modal-title">확인</h2>
            <div id="confirmation-modal-body">
                <p class="text-base text-gray-700 mb-6" id="confirmation-modal-message"></p>
            </div>
            <div class="flex justify-between space-x-2 mt-4" id="confirmation-modal-buttons">
                <button id="confirmCancelButton" class="w-1/2 px-4 py-2 rounded-md bg-gray-300 text-gray-800 text-sm font-medium hover:bg-gray-400">취소</button>
                <button id="confirmOkButton" class="w-1/2 px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">확인</button>
            </div>
        </div>
    </div>

    <!-- 스마트 편집 모달 -->
    <div id="smart-edit-modal" class="smart-edit-modal" style="display: none;">
        <div class="smart-edit-modal-content">
            <div id="smart-edit-scroll-area">
                <div class="mb-4">
                    <h3 class="text-sm font-semibold text-gray-600 mb-1">AI 추출 원본 (참조용)</h3>
                    <p id="original-address-display" class="p-2 bg-gray-100 rounded-md text-gray-800 text-sm font-mono break-all"></p>
                </div>

                <div class="mb-2">
                    <h3 class="text-sm font-semibold text-gray-600 mb-1">주소 조각 (클릭하여 추가)</h3>
                    <div id="address-pieces-container" class="flex flex-wrap p-2 bg-gray-50 rounded-md border border-gray-200 min-h-[40px]"></div>
                </div>
                
                <div id="fixed-buttons-container" class="mt-2 grid grid-cols-2 gap-4">
                    <div id="number-keypad" class="grid grid-cols-3 gap-2"></div>
                    <div id="unit-keypad" class="grid grid-cols-2 gap-2"></div>
                </div>

                <hr class="my-4 border-gray-300"/>

                                <div class="mt-4">
                    <div class="flex justify-between items-center mb-2">
                         <h3 class="text-lg font-semibold text-gray-800">주소 조각 편집</h3>
                         <div class="flex items-center space-x-2">
                            <button id="reset-pieces-btn" class="p-1.5 text-red-500 hover:bg-red-100 rounded-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                            </button>
                            <button id="apply-pieces-btn" class="px-4 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-sm font-medium">수정 완료</button>
                         </div>
                    </div>
                    <textarea id="pieces-address-input" class="w-full p-2 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500 resize-none overflow-hidden" rows="1" readonly></textarea>
                </div>
                
                <div class="mt-4">
                     <div class="flex justify-between items-center mb-2">
                         <h3 class="text-lg font-semibold text-gray-800">직접 주소 편집</h3>
                         <div class="flex items-center space-x-2">
                             <button id="revert-direct-btn" class="p-1.5 text-blue-600 hover:bg-blue-100 rounded-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>
                            </button>
                             <button id="reset-direct-btn" class="p-1.5 text-red-500 hover:bg-red-100 rounded-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                            </button>
                            <button id="apply-direct-btn" class="px-4 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-sm font-medium">수정 완료</button>
                         </div>
                    </div>
                    <textarea id="direct-address-input" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 resize-none overflow-hidden" rows="2"></textarea>
                </div>

            </div>
            <div class="flex justify-end mt-auto pt-4 border-t border-gray-200">
                <button id="smart-edit-exit" class="px-4 py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500 text-sm font-medium">나가기</button>
            </div>
        </div>
    </div>

    <div id="completion-options-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-6 text-gray-800" id="completion-options-title">완료 옵션 선택</h2>
            <div id="completion-options-list" class="space-y-3">
                <!-- 옵션 버튼들이 여기에 동적으로 추가됩니다. -->
            </div>
            <div class="flex justify-end mt-8">
                <button id="completion-options-cancel" class="px-4 py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500 text-sm font-medium">취소</button>
            </div>
        </div>
    </div>

    <div id="log-viewer-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content" style="max-width: 42rem;"> <!-- 너비를 조금 더 넓게 -->
            <h2 class="text-xl font-semibold mb-4 text-gray-800">오류 로그 기록</h2>
            <div class="flex-1 bg-gray-800 text-white font-mono text-xs p-4 rounded-md overflow-auto" style="min-height: 200px; max-height: 60vh;">
                <pre id="log-content-display"></pre>
            </div>
            <div class="flex justify-between mt-6 space-x-2">
                <button id="log-viewer-close" class="px-4 py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500 text-sm font-medium">닫기</button>
                <button id="exportLogsButton" class="px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 text-sm font-medium">로그 파일로 저장</button>
            </div>
        </div>
    </div>

<div id="delivery-location-modal" class="confirmation-modal" style="display: none;">
        <div class="confirmation-modal-content">
            <h2 class="text-xl font-semibold mb-6 text-gray-800" id="delivery-location-title">배송 위치 선택</h2>
            <div id="delivery-location-options" class="space-y-4">
                <!-- 라디오 버튼 옵션들이 여기에 동적으로 추가됩니다. -->
            </div>
            <div class="flex justify-between space-x-2 mt-8">
                <button id="location-modal-cancel" class="w-1/2 px-4 py-2 rounded-md bg-gray-300 text-gray-800 text-sm font-medium hover:bg-gray-400">취소</button>
                <button id="location-modal-confirm" class="w-1/2 px-4 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-700">배송 완료</button>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        // ▼▼▼▼▼ [추가 시작] 이 코드 블록을 추가하세요 ▼▼▼▼▼
        
        // --- 전역 오류 로깅 시스템 ---
        const LOG_STORAGE_KEY = 'appErrorLogs';

        // 페이지에서 발생하는 모든 자바스크립트 오류를 가로채는 핸들러
        window.onerror = function(message, source, lineno, colno, error) {
            const now = new Date();
            const timestamp = now.toLocaleString('ko-KR', { hour12: false });

            const logEntry = {
                timestamp: timestamp,
                message: message, // 오류 메시지
                source: source.substring(source.lastIndexOf('/') + 1), // 파일 이름만 추출
                line: lineno, // 줄 번호
                column: colno, // 열 번호
                stack: error ? error.stack : 'N/A' // 스택 트레이스 (더 상세한 정보)
            };

            try {
                let logs = JSON.parse(localStorage.getItem(LOG_STORAGE_KEY)) || [];
                logs.unshift(logEntry); // 최신 로그를 맨 앞에 추가
                
                // 로그는 최대 100개까지만 저장하여 용량 문제 방지
                if (logs.length > 100) {
                    logs = logs.slice(0, 100);
                }

                localStorage.setItem(LOG_STORAGE_KEY, JSON.stringify(logs));
            } catch (e) {
                console.error("로깅 시스템 자체 오류:", e);
            }

            // true를 반환하면 브라우저 콘솔에 오류가 표시되지 않음 (선택사항)
            // return true; 
        };

        // Promise에서 처리되지 않은 rejection (예: async/await 오류)을 가로채는 핸들러
        window.addEventListener('unhandledrejection', function(event) {
            // event.reason에 오류 정보가 담겨 있음
            window.onerror(
                `Unhandled Promise Rejection: ${event.reason.message || event.reason}`,
                event.reason.fileName || 'unknown',
                event.reason.lineNumber || 0,
                event.reason.columnNumber || 0,
                event.reason
            );
        });

        // --- 로깅 시스템 끝 ---

        // ▲▲▲▲▲ [추가 끝] 여기까지 추가하세요 ▲▲▲▲▲

        const GEMINI_PROMPT = `Analyze the provided image containing one or more delivery invoices. Your task is to identify each distinct invoice block and extract its key information into a valid JSON array.

**CRITICAL INSTRUCTIONS:**

1.  **IDENTIFY EACH INVOICE:** Treat each logical invoice area as a separate item. An "no" is essential for each item.

2.  **EXTRACT KEY-VALUE PAIRS:** For each invoice, extract the following fields: "no", "hawbNo", "receiverAddress", "receiverPhone", "receiverCompanyName", and "receiverName".

3.  **SEPARATE COMPANY AND PERSONAL NAME:**
    *   **Scenario A (Separate Columns):** If the invoice has distinct columns like "Company Name of Receiver" and "Name of receiver", extract the text from each column into "receiverCompanyName" and "receiverName" respectively.
    *   **Scenario B (Combined Field):** If the recipient information is in a single combined field, intelligently separate the company/organization name and the personal name.
    *   **Handling Edge Cases:**
        *   If only a personal name is found, put it in "receiverName" and omit "receiverCompanyName".
        *   If only a company name is found (e.g., "ABC Mart", "(주)DEF"), put it in "receiverCompanyName" and repeat it in "receiverName".
        *   If you cannot separate them, put the entire text into both "receiverCompanyName" and "receiverName".

4.  **TRANSLATE AND SEPARATE ADDRESS:**
    *   Translate "receiverName" and "receiverCompanyName" to Korean if they are in English/Romanized Korean. Store them in "receiverNameKorean" and "receiverCompanyNameKorean". If already in Korean, just copy them.
    *   **STEP 1: Perform a STRICT, LITERAL TRANSLATION of the original "receiverAddress".**
        *   Translate every component EXACTLY as it appears.
        *   **English Word Joining Rule:** If a single English word is broken across lines (e.g., 'OLYMPI' and 'CRO'), you MUST join them (e.g., 'OLYMPICRO').
        *   **Korean Noun Joining Rule:** When processing Korean addresses, if two consecutive lines can form a natural compound noun (like an apartment name or a road name), you MUST join them without a space. However, do not merge numbers with units (like 동, 호) if they are on separate lines.
            *   Example 1: '래미' on line 1 and '안' on line 2 MUST become '래미안'.
            *   Example 2: '오금' on line 1 and '로' on line 2 MUST become '오금로'.
            *   Example 3: '106동' on line 1 and '1302호' on line 2 MUST remain separate as '106동 1302호'.
        *   **Default Rule:** If the lines do not form a natural single word, treat the line break as a space.
        *   DO NOT reorder, correct, or omit any other characters (e.g., 'GAGIL' MUST become '가길').
        *   If the original is already in Korean, just copy it.
        *   Let's call this result the "Translated Full Address".
    *   **STEP 2: From the "Translated Full Address", separate it into "baseAddressKorean" and "detailAddressKorean" using the following rules:**
        *   **Rule A (Primary): Find the Address Anchor.** First, search for a Korean road name anchor ('로', '길') or a legal address anchor ('동', '리'). Prioritize road name anchors.
        *   **Rule B (If Anchor Found): Extract the Base Address.** The base address consists of everything from the start of the address up to and including the number block that appears IMMEDIATELY BEFORE the anchor. This number is the building number or lot number.
            *   Example 1: For "서울 송파구 1218 양재대로 245-501", the anchor is '대로'. The number block immediately before it is '1218'. So, "baseAddressKorean" is "서울 송파구 양재대로 1218".
            *   Example 2: For "경기 성남시 분당구 판교역로 235", the anchor is '로'. The number block before it is '235'. So, "baseAddressKorean" is "경기 성남시 분당구 판교역로 235".
            *   **Example 3 (Precedence Rule):** For "서울 송파구 135, 올림픽로 235-1301", the anchor is '로'. The number block before the anchor (135) has higher priority than the number after it (235). So, "baseAddressKorean" MUST be "서울 송파구 올림픽로 135".
        *   **Rule C (If Anchor Found): Extract the Detail Address.** "detailAddressKorean" is everything that remains after the base address has been extracted.
            *   From Example 1, "detailAddressKorean" would be "245-501".
            *   From Example 3, "detailAddressKorean" would be "235-1301".
        *   **Rule D (If No Anchor Found): Use Best Judgment.** If no clear anchor ('로', '길', '동', '리') can be identified (due to OCR errors or unusual formatting), analyze the structure and make a best-effort guess to separate the base and detail addresses as you did before.
        *   **Address Hierarchy Rule:** If both a street address (e.g., '풍성로14길 19') and an administrative dong (e.g., '풍납2동') are present, the street address is the primary component for "baseAddressKorean". The administrative dong should be considered redundant information and **MUST be omitted** from the final output unless it is part of a building name.

5.  **OUTPUT A JSON ARRAY:** Your entire output MUST be a single, valid JSON array of objects.

**Example Output:**
[
  {
    "no": "40",
    "hawbNo": "SF028452891 8577",
    "receiverCompanyName": "Techfiber.Co.,-Ltd",
    "receiverCompanyNameKorean": "테크파이버",
    "receiverName": "Richard Kim",
    "receiverNameKorean": "김리차드",
    "receiverPhone": "24080670",
    "receiverAddress": "No.601, 422-dong, 1300, yangjae-daero",
    "baseAddressKorean": "서울 강동구 양재대로 1300",
    "detailAddressKorean": "601호 422동"
  },
  {
    "no": "1",
    "hawbNo": "SF319999130 4534",
    "receiverCompanyName": "Jiyoung Her",
    "receiverCompanyNameKorean": "허지영",
    "receiverName": "Jiyoung Her",
    "receiverNameKorean": "허지영",
    "receiverPhone": "01025190714",
    "receiverAddress": "Seoul Songpa-gu 135, Olympic-ro 235-1301",
    "baseAddressKorean": "서울 송파구 올림픽로 135",
    "detailAddressKorean": "235-1301"
  }
]
`;
        
        const KAKAO_API_KEY = '2342aad8b15d534cb60fb824f71a97f1';

        const dateTimeFormatOptions = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };

        // --- Helper functions ---

            const showLoadingMessage = (message) => {
    confirmationModalTitle.textContent = '처리 중...';
    confirmationModalBody.innerHTML = `
        <div class="flex flex-col items-center justify-center p-4">
            <div class="spinner mb-4"></div>
            <p class="text-base text-gray-700">${message}</p>
        </div>
    `;
    // 확인/취소 버튼 숨기기
    confirmationModalButtons.style.display = 'none';
    document.body.classList.add('modal-open');
    confirmationModal.style.display = 'flex';
};

// ▼▼▼▼▼ [추가 시작] 이 아래 두 함수를 추가하세요 ▼▼▼▼▼

const showToastMessage = (message, duration = 2000) => {
    const toast = document.createElement('div');
    toast.className = 'toast-message';
    toast.textContent = message;
    toastContainer.appendChild(toast);

    // Animate in
    setTimeout(() => {
        toast.classList.add('show');
    }, 10);

    // Animate out and remove
    setTimeout(() => {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, { once: true });
    }, duration);
};

const showMessage = (message, title = '알림') => {
    confirmationModalTitle.textContent = title;
    confirmationModalBody.innerHTML = `<p class="text-base text-gray-700 mb-6">${message}</p>`;
    confirmOkButton.textContent = '확인';
    // 취소 버튼은 숨깁니다.
    confirmCancelButton.style.display = 'none';
    confirmationModalButtons.style.display = 'flex';
    
    onConfirmCallback = null; // 확인 버튼 클릭 시 특별한 동작 없음
    document.body.classList.add('modal-open');
    confirmationModal.style.display = 'flex';
};

// ▲▲▲▲▲ [추가 끝] 여기까지 추가하세요 ▲▲▲▲▲

        const resizeAppContainer = () => {
            const appContainer = document.getElementById('app-container');
            if (appContainer) {
                appContainer.style.height = `${window.innerHeight}px`;
            }
        };

        const isValidPhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) {
                return true; // 번호가 없으면 유효한 것으로 간주 (수정 대상이 아님)
            }
            
            // 모든 비숫자 문자를 제거하여 순수한 숫자 문자열로 만듭니다.
            let cleaned = phoneNumber.replace(/\D/g, '');

            // 국제 번호 형식(+82)을 국내 형식(0)으로 정규화합니다.
            if (cleaned.startsWith('82')) {
                cleaned = '0' + cleaned.substring(2);
            }

            // 1. 010으로 시작하는 휴대폰 번호 검사
            if (cleaned.startsWith('010')) {
                return cleaned.length === 11;
            }
            
            // 2. 02로 시작하는 서울 지역번호 검사
            if (cleaned.startsWith('02')) {
                return cleaned.length === 9 || cleaned.length === 10;
            }

            // 3. 070으로 시작하는 인터넷 전화 검사
            if (cleaned.startsWith('070')) {
                return cleaned.length === 11;
            }

            // 4. 그 외 0으로 시작하는 지역번호 및 식별번호 검사 (예: 031, 051 등)
            if (cleaned.startsWith('0')) {
                // 일반적으로 지역번호(3자리) + 국번(3~4자리) + 번호(4자리) = 10~11자리
                // 또는 식별번호(4자리) + 국번(3~4자리) + 번호(4자리) = 11~12자리 (1588 등)
                // 여기서는 일반적인 유선전화 규칙인 10~11자리를 기준으로 합니다.
                return cleaned.length === 10 || cleaned.length === 11;
            }

            // 위의 모든 규칙에 해당하지 않으면 유효하지 않은 번호로 간주합니다.
            return false;
        };

        const setVersionInfo = () => {
            const version = "v1.5.2";
            const changelog = "버그수정";
            if (versionText) versionText.textContent = version;
            if (versionChangelog) versionChangelog.textContent = changelog;
        };

        const setupDelegatedEventListeners = () => {
            let touchTarget = null;

            // 롱프레스(길게 누르기) 이벤트 처리
            deliveryCardsContainer.addEventListener('touchstart', (event) => {
                const target = event.target.closest('button[data-action="front-door-delivery"]');
                if (!target) return; // '문앞배송' 버튼이 아니면 무시

                isLongPress = false;
                touchTarget = target;
                
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                
                    const itemNo = parseInt(target.dataset.no, 10);
                    openCompletionOptionsModal(itemNo);
                }, 300); // 0.3초
            }, { passive: true });

            deliveryCardsContainer.addEventListener('touchmove', () => {
                clearTimeout(longPressTimer);
                touchTarget = null;
            }, { passive: true });

            deliveryCardsContainer.addEventListener('touchend', (event) => {
                // 타이머를 먼저 클리어합니다.
                clearTimeout(longPressTimer);
                
                // 만약 롱프레스가 발동되었다면,
                if (isLongPress) {
                    // 뒤따라올 'click' 이벤트를 막기 위해 preventDefault()를 호출합니다.
                    event.preventDefault();
                    // 플래그를 리셋합니다.
                    isLongPress = false;
                }
            });

            // 일반 클릭 이벤트 처리
            deliveryCardsContainer.addEventListener('click', (event) => {
                // 롱프레스였다면 touchend에서 이미 preventDefault로 막혔겠지만,
                // 만약을 대비한 방어 코드입니다.
                if (isLongPress) {
                    isLongPress = false; // 플래그 리셋
                    return;
                }
                
                const target = event.target.closest('button, input[type="checkbox"], p[data-action="open-smart-edit"], span[data-action="edit-phone"], div[data-status="완료"], span[data-action="copy-hawb"], button[data-action="swap-name"]');                if (!target) return;

                                // ▼▼▼ [수정] 완료 카드 클릭 시 복사 기능 추가 ▼▼▼
                if (target.dataset.status === '완료' && !event.target.closest('button, a')) {
                    const itemNo = parseInt(target.dataset.no, 10);
                    const item = deliveryItems.find(i => i.no === itemNo);
                    if (item) {
                        const completionText = item.completionType === '본인전달'
                            ? (item.receiverNameKorean || '')
                            : (item.completionDetail || item.completionType || '');
                        const timeText = formatCompletionTime(item.deliveryCompletionTime);
                        const textToCopy = `${item.no} - ${completionText} [${timeText}]`;
                        
                        navigator.clipboard.writeText(textToCopy).then(() => {
                            showToastMessage(`'${textToCopy}' 복사 완료`);
                        }).catch(err => {
                            console.error('클립보드 복사 실패:', err);
                            showMessage('클립보드 복사에 실패했습니다.');
                        });
                    }
                    return; // 복사 후 다른 동작 방지
                }
                // ▲▲▲ [수정] ▲▲▲

                const action = target.dataset.action;
                const itemNo = parseInt(target.dataset.no, 10);

                                switch (action) {
                    case 'toggle-hawb-confirm':
                        handleCheckboxToggleAndResetSearch(itemNo, target.checked);
                        break;
                    case 'open-map':
                        {
                            const item = deliveryItems.find(i => i.no === itemNo);
                            if (item) openMap(item);
                        }
                        break;
                    // ▼▼▼ [이 블록 추가] ▼▼▼
                    case 'swap-name':
                        {
                            const itemIndex = deliveryItems.findIndex(i => i.no === itemNo);
                            if (itemIndex > -1) {
                                const item = deliveryItems[itemIndex];
                                // 원본 이름이 없다면(초기 데이터), 현재 이름을 원본으로 저장
                                if (typeof item.receiverNameKoreanOriginal === 'undefined') {
                                    item.receiverNameKoreanOriginal = item.receiverNameKorean;
                                }

                                const currentName = item.receiverNameKorean;
                                const originalName = item.receiverNameKoreanOriginal;

                                // 현재 이름이 원본과 다르다면 (이미 한번 바뀐 상태) -> 원본으로 복구
                                if (currentName !== originalName) {
                                    deliveryItems[itemIndex].receiverNameKorean = originalName;
                                } else {
                                // 현재 이름이 원본과 같다면 -> 순서 바꾸기 실행
                                    const nameToSwap = currentName.trim().replace(/\s/g, ''); // 공백 모두 제거
                                    if (nameToSwap.length > 1) {
                                        const lastChar = nameToSwap.slice(-1);
                                        const restOfString = nameToSwap.slice(0, -1);
                                        const newName = `${lastChar}${restOfString}`;
                                        deliveryItems[itemIndex].receiverNameKorean = newName;
                                    }
                                }
                                saveDeliveryItemsToLocalStorage();
                                renderDeliveryCards(activeFilter);
                            }
                        }
                        break;
                    // ▲▲▲ [추가 끝] ▲▲▲
                    case 'copy-hawb':
                        {
                            const hawbToCopy = target.dataset.hawbNo;
                            if (hawbToCopy) {
                                navigator.clipboard.writeText(hawbToCopy).catch(err => {
                                    console.error('송장번호 복사 실패:', err);
                                    showMessage('송장번호 복사에 실패했습니다.');
                                });
                            }
                        }
                        break;
                    
                    case 'revert-delivery':
                        openConfirmationModal(`${itemNo}번 항목을 '배송중' 상태로 되돌리시겠습니까?`, () => {
                            handleStatusChange(itemNo, '배송중');
                            showToastMessage(`${itemNo}번 항목이 되돌려졌습니다.`);
                        });
                        break;
                    case 'identity-verification':
                        openConfirmationModal(`${itemNo}번 항목을 '본인전달'로 완료 처리하시겠습니까?`, () => {
                            const currentTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
                            handleStatusChange(itemNo, '완료', currentTime, '본인전달', '신분증');
                            sortItemsByDistanceSilent();
                        });
                        break;
                    case 'open-location-modal':
                        openDeliveryLocationModal(itemNo);
                        break;
                    case 'sign-delivery':
                        openSignatureModal(itemNo);
                        break;
                    case 'toggle-details':
                        {
                            const detailsContainer = document.querySelector(`div[data-details-container="${itemNo}"]`);
                            const iconButton = target.closest('button');
                            const iconSvg = iconButton.querySelector('svg');

                            if (detailsContainer && iconSvg) {
                                const isHidden = detailsContainer.style.display === 'none';
                                detailsContainer.style.display = isHidden ? 'block' : 'none';
                                
                                if (isHidden) {
                                    iconSvg.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />`;
                                } else {
                                    iconSvg.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />`;
                                }
                            }
                        }
                        break;
                    case 'edit-phone':
                        openPhoneEditModal(itemNo);
                        break;
                    case 'open-smart-edit':
                        openSmartEditModal(itemNo);
                        break;
                }
            });

            completionOptionsCancelBtn.addEventListener('click', () => {
                completionOptionsModal.style.display = 'none';
            });
        };

        const resizeImage = (file) => {
            return new Promise((resolve, reject) => {
                const MAX_WIDTH = 1920;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;
                        if (width > MAX_WIDTH) {
                            height = (MAX_WIDTH / width) * height;
                            width = MAX_WIDTH;
                        }
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                        resolve({ file, data: dataUrl.split(',')[1] });
                    };
                    img.onerror = (error) => reject(error);
                };
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        };

        const getCurrentLocation = (timeout = 10000) => {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    return reject(new Error('Geolocation is not supported by this browser.'));
                }
                navigator.geolocation.getCurrentPosition(
                    (position) => resolve({ lat: position.coords.latitude, lng: position.coords.longitude }),
                    (error) => reject(error),
                    { enableHighAccuracy: true, timeout, maximumAge: 0 }
                );
            });
        };

        const getCoordsFromAddress = async (address) => {
            if (!address) throw new Error("Address is empty.");
            const response = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(address)}`, {
                headers: { 'Authorization': `KakaoAK ${KAKAO_API_KEY}` }
            });
            if (!response.ok) throw new Error('Kakao Geocoding API call failed');
            const data = await response.json();
            if (data.documents && data.documents.length > 0) {
                const location = data.documents[0];
                return { lat: parseFloat(location.y), lng: parseFloat(location.x) };
            }
            throw new Error("Could not find coordinates for the address.");
        };

        const calculateDistance = (pos1, pos2) => {
            if (!pos1 || !pos2) return Infinity;
            const R = 6371; // Radius of the Earth in km
            const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
            const dLon = (pos2.lng - pos1.lng) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance in km
        };

        const formatSinglePhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('+82010')) { cleaned = '010' + cleaned.substring(6); }
            else if (cleaned.startsWith('82010')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('+8210')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('8210')) { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('8201') && cleaned.length > 4 && cleaned[4] !== '0') { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('82') && cleaned.length > 2) { cleaned = '0' + cleaned.substring(2); }
            else if (cleaned.length >= 7 && cleaned.length <= 11 && !cleaned.startsWith('0')) { cleaned = '0' + cleaned; }
            
            if (cleaned.startsWith('010') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.startsWith('02')) {
                if (cleaned.length === 9) return cleaned.replace(/(\d{2})(\d{3})(\d{4})/, '$1-$2-$3');
                if (cleaned.length === 10) return cleaned.replace(/(\d{2})(\d{4})(\d{4})/, '$1-$2-$3');
            }
            if (cleaned.startsWith('031') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.startsWith('070') && cleaned.length === 11) return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 10) return cleaned.replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 9) return cleaned.replace(/(\d{2})(\d{3})(\d{4})/, '$1-$2-$3');
            if (cleaned.length === 8) return cleaned.replace(/(\d{4})(\d{4})/, '$1-$2');
            if (cleaned.length === 7) return cleaned.replace(/(\d{3})(\d{4})/, '$1-$2');

            return cleaned;
        };

        const formatPhoneNumberForDisplay = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            const rangeMatch = phoneNumber.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) {
                const baseNumber = rangeMatch[1];
                const suffix = rangeMatch[2];
                if (baseNumber.length >= suffix.length) {
                    const num1 = formatSinglePhoneNumber(baseNumber);
                    const num2Raw = baseNumber.substring(0, baseNumber.length - suffix.length) + suffix;
                    const num2 = formatSinglePhoneNumber(num2Raw);
                    return `${num1} / ${num2}`;
                }
            }
            return formatSinglePhoneNumber(phoneNumber.replace(/\D/g, ''));
        };

        const getCleanPhoneNumber = (phoneNumber) => {
            if (typeof phoneNumber !== 'string' || !phoneNumber) return '';
            const rangeMatch = phoneNumber.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) phoneNumber = rangeMatch[1];
            
            let cleaned = phoneNumber.replace(/\D/g, '');

            if (cleaned.startsWith('+82010')) { cleaned = '010' + cleaned.substring(6); }
            else if (cleaned.startsWith('82010')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('+8210')) { cleaned = '010' + cleaned.substring(5); }
            else if (cleaned.startsWith('8210')) { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('8201') && cleaned.length > 4 && cleaned[4] !== '0') { cleaned = '010' + cleaned.substring(4); }
            else if (cleaned.startsWith('82') && cleaned.length > 2) { cleaned = '0' + cleaned.substring(2); }
            else if (cleaned.length >= 7 && cleaned.length <= 11 && !cleaned.startsWith('0')) { cleaned = '0' + cleaned; }

            return cleaned;
        };

        const formatHawbNoForDisplay = (hawbNo) => {
            if (!hawbNo || hawbNo.length < 4) return hawbNo;
            const prefix = hawbNo.substring(0, hawbNo.length - 4);
            const suffix = hawbNo.substring(hawbNo.length - 4);
            return `${prefix} ${suffix}`;
        };

        const formatCompletionTime = (dateTimeString) => {
            if (!dateTimeString) return '';
            const parts = dateTimeString.split(' ');
            if (parts.length >= 4) {
                const [hour, minute] = parts[3].split(':');
                return `${hour}:${minute}`;
            }
            return '';
        };
        
        const extractClipboardAddressPart = (item) => {
            if (!item) return '';
            const { baseAddress, detailAddress } = item;

            if (detailAddress) {
                const hyphenMatch = detailAddress.match(/\b(\d{2,4}-\d{2,4})\b/);
                if (hyphenMatch) return hyphenMatch[1];
                const dongHoMatch = detailAddress.match(/(\d+)\s*동\s*(\d+)\s*호/);
                if (dongHoMatch) return `${dongHoMatch[1]}-${dongHoMatch[2]}`;
            }

            if (baseAddress) {
    const addressParts = baseAddress.split(' ');
    // 'specialCities' 배열을 확장하여 축약형 도 이름까지 포함하고, 이름을 'adminNames'로 변경
    const adminNames = ['서울', '부산', '대구', '인천', '광주', '대전', '울산', '세종', '경기', '강원', '충북', '충남', '전북', '전남', '경북', '경남', '제주'];
    const adminSuffixes = ['도', '시', '구', '군', '읍', '면'];
    
    while (addressParts.length > 0) {
        const firstPart = addressParts[0];
        // 확장된 'adminNames' 배열을 사용하여 조건을 확인
        if (adminNames.includes(firstPart) || adminSuffixes.some(suffix => firstPart.endsWith(suffix))) {
            addressParts.shift();
        } else {
            break;
        }
    }
    
    const resultAddress = addressParts.join(' ');
    return resultAddress.length > 0 ? resultAddress : baseAddress;
}

            return baseAddress || '';
        };

        const isValidAddressForMap = (address) => {
            return !!(address && address.trim().length > 0);
        };
        
        const validateAddressWithKakao = async (baseAddress, detailAddress) => {
            if (!baseAddress) {
                return { baseAddress: '', detailAddress: detailAddress || '', validated: false };
            }
            try {
                const response = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(baseAddress)}`, {
                    headers: { 'Authorization': `KakaoAK ${KAKAO_API_KEY}` }
                });
                if (!response.ok) throw new Error('Kakao API call failed');
                const data = await response.json();
                if (data.documents && data.documents.length > 0) {
                    const doc = data.documents[0];
                    const kakaoBaseAddress = doc.road_address ? doc.road_address.address_name : doc.address.address_name;
                    // 검증 성공 상태와 함께 반환
                    return { baseAddress: kakaoBaseAddress, detailAddress: detailAddress || '', validated: true };
                }
                // 주소를 찾지 못한 경우, 검증 실패 상태와 함께 원본 반환
                return { baseAddress, detailAddress: detailAddress || '', validated: false };
            } catch (error) {
                console.error('Error validating address with Kakao API:', error);
                // 에러 발생 시, 검증 실패 상태와 함께 원본 반환
                return { baseAddress, detailAddress: detailAddress || '', validated: false };
            }
        };

        // --- Global state and DOM elements ---
        let deliveryItems = [];
        let searchTerm = '';
        let activeFilter = '전체';
        const filterCategories = ['배송준비', '전체', '배송전', '배송중', '완료'];
        let filterScrollPositions = {};
        let currentFileToScan = null;
        let failedFileObjects = []; 
        let currentSignatureItemNo = null;
        let onConfirmCallback = null;
        let currentEditItemNo = null; 
        let currentSortOrder = 'no'; // 'no' or 'distance' or 'time'
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let backButtonPressedOnce = false;
        let justReturnedFromExternalApp = false;
        let deliveryInProgressSortOrder = 'no';
        let completedSortOrder = 'no'; // 'no' 또는 'time'
        let longPressTimer = null;
        let isLongPress = false;
        let isRefreshing = false;
        let pullStartY = 0;
        let refreshIndicator;
        let currentLocationEditItemNo = null;

        const searchBarContainer = document.getElementById('search-bar-container');
        const invoiceNumberInput = document.getElementById('invoiceNumber');
        const searchButton = document.getElementById('searchButton');
        const resetButton = document.getElementById('resetButton');
        const filterButtonsContainer = document.getElementById('filter-buttons-container');
        const deliveryCardsContainer = document.getElementById('delivery-cards-container');
        const deliverySheetImageInput = document.getElementById('deliverySheetImage');
        const scanAndGenerateButton = document.getElementById('scanAndGenerateButton');
        const scanLoadingIndicator = document.getElementById('scan-loading-indicator');
        const scanErrorMessage = document.getElementById('scan-error-message');
        const scanErrorText = document.getElementById('scan-error-text');
        const scanSectionContainer = document.getElementById('scan-section-container');
        const clearAllCardsButton = document.getElementById('clearAllCardsButton');
        const dataManagementContainer = document.getElementById('data-management-container');
        const exportDataButton = document.getElementById('exportDataButton');
        const importDataInput = document.getElementById('importDataInput');
        const scanProgressText = document.getElementById('scan-progress-text');
        const selectedFilesDisplay = document.getElementById('selected-files-display');
        
        const signatureModal = document.getElementById('signature-modal');
        const signatureTextInput = document.getElementById('signature-text-input');
        const clearSignatureBtn = document.getElementById('clearSignature');
        const cancelSignatureBtn = document.getElementById('cancelSignature');
        const saveSignatureBtn = document.getElementById('saveSignature');
        
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationModalTitle = document.getElementById('confirmation-modal-title');
        const confirmationModalMessage = document.getElementById('confirmation-modal-message');
        const confirmationModalBody = document.getElementById('confirmation-modal-body');
        const confirmationModalButtons = document.getElementById('confirmation-modal-buttons');
        const confirmOkButton = document.getElementById('confirmOkButton');
        const confirmCancelButton = document.getElementById('confirmCancelButton');
        
        const versionInfoContainer = document.getElementById('version-info-container');
        const versionText = document.getElementById('version-text');
        const versionChangelog = document.getElementById('version-changelog');
        
        const smartEditModal = document.getElementById('smart-edit-modal');
        const originalAddressDisplay = document.getElementById('original-address-display');
        const piecesAddressInput = document.getElementById('pieces-address-input');
        const directAddressInput = document.getElementById('direct-address-input');
        const applyPiecesBtn = document.getElementById('apply-pieces-btn');
        const resetPiecesBtn = document.getElementById('reset-pieces-btn');
        const applyDirectBtn = document.getElementById('apply-direct-btn');
        const revertDirectBtn = document.getElementById('revert-direct-btn');
        const smartEditExitBtn = document.getElementById('smart-edit-exit');
        
        const toastContainer = document.getElementById('toast-container');
        
        const numberJumpModal = document.getElementById('number-jump-modal');
        const numberJumpList = document.getElementById('number-jump-list');
        const numberJumpClose = document.getElementById('number-jump-close');

        const actionBarContainer = document.getElementById('action-bar-container');
        const actionButtons = document.getElementById('action-buttons');
        
        const completionOptionsModal = document.getElementById('completion-options-modal');
        const completionOptionsTitle = document.getElementById('completion-options-title');
        const completionOptionsList = document.getElementById('completion-options-list');
        const completionOptionsCancelBtn = document.getElementById('completion-options-cancel');

        const deliveryLocationModal = document.getElementById('delivery-location-modal');
        const deliveryLocationTitle = document.getElementById('delivery-location-title');
        const deliveryLocationOptions = document.getElementById('delivery-location-options');
        const locationModalConfirm = document.getElementById('location-modal-confirm');
        const locationModalCancel = document.getElementById('location-modal-cancel');

        // --- Modal & Core Logic Functions ---

        function autoResizeTextarea(event) {
const textarea = event.target;
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
}

const openDeliveryLocationModal = (itemNo) => {
            currentLocationEditItemNo = itemNo;
            const item = deliveryItems.find(i => i.no === itemNo);
            if (!item) return;

            deliveryLocationTitle.textContent = `${item.no}번 배송 위치 선택`;

            const cardInfoHtml = `
                <div class="mb-4 p-2.5 bg-gray-100 border border-gray-200 rounded-md space-y-1">
                    <p class="text-xs text-gray-600 truncate"><span class="font-semibold w-11 inline-block flex-shrink-0">주소:</span> ${item.baseAddress}${item.detailAddress ? ', ' + item.detailAddress : ''}</p>
                    <p class="text-xs text-gray-600 truncate"><span class="font-semibold w-11 inline-block flex-shrink-0">받는분:</span> ${item.receiverNameKorean || item.receiverNameOriginal}</p>
                </div>
            `;

            const locations = ['문앞', '택배보관소', '택배함', '문서수발실', '경비실', '안내데스크'];
            const radioOptionsHtml = locations.map((location, index) => `
                <label for="loc-${index}" class="flex items-center p-2.5 rounded-lg hover:bg-gray-100 cursor-pointer">
                    <input type="radio" id="loc-${index}" name="delivery-location" value="${location}" class="h-5 w-5 text-blue-600 border-gray-300 focus:ring-blue-500" ${index === 0 ? 'checked' : ''}>
                    <span class="ml-3 text-sm font-medium text-gray-800">${location}</span>
                </label>
            `).join('');

            deliveryLocationOptions.innerHTML = cardInfoHtml + `<div class="space-y-1">${radioOptionsHtml}</div>`;

            document.body.classList.add('modal-open');
            deliveryLocationModal.style.display = 'flex';
        };

        const closeDeliveryLocationModal = () => {
            document.body.classList.remove('modal-open');
            deliveryLocationModal.style.display = 'none';
            currentLocationEditItemNo = null;
        };

        const openPhoneEditModal = (itemNo) => {
    const item = deliveryItems.find(i => i.no === itemNo);
    if (!item) return;

    confirmationModalTitle.textContent = `${item.no}번 전화번호 수정`;
    
    confirmationModalBody.innerHTML = `
        <p class="text-sm text-gray-600 mb-2">숫자만 입력하세요. 자동으로 하이픈(-)이 추가됩니다.</p>
        <input type="tel" id="phone-edit-input" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-lg" value="" inputmode="numeric" pattern="[0-9]*" maxlength="13">
    `;
    
    confirmOkButton.textContent = '수정 완료';
    confirmCancelButton.textContent = '취소';
    confirmCancelButton.style.display = '';
    confirmationModalButtons.style.display = 'flex';

    const phoneInput = document.getElementById('phone-edit-input');
    
    const autoHyphenOnInput = (target) => {
        target.value = target.value
            .replace(/[^0-9]/g, '')
            .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, "$1-$2-$3")
            .replace(/(\-{1,2})$/g, "");
    }
    phoneInput.addEventListener('input', (e) => autoHyphenOnInput(e.target));
    
    onConfirmCallback = () => {
        const newPhoneNumber = phoneInput.value;
        const itemIndex = deliveryItems.findIndex(i => i.no === itemNo);
        if (itemIndex > -1) {
            deliveryItems[itemIndex].receiverTelephoneNo = newPhoneNumber;
            saveDeliveryItemsToLocalStorage();
            renderDeliveryCards(activeFilter);
            showToastMessage(`${item.no}번 전화번호가 수정되었습니다.`);
        }
    };

    document.body.classList.add('modal-open'); // body 스크롤 잠금
    confirmationModal.style.display = 'flex';
    phoneInput.focus();
};
const openSignatureModal = (itemNo) => { 
    currentSignatureItemNo = itemNo; 
    document.body.classList.add('modal-open'); // body 스크롤 잠금
    signatureModal.style.display = 'flex'; 
    signatureTextInput.value = ''; 
    signatureTextInput.focus(); 
};
const closeSignatureModal = () => { 
    document.body.classList.remove('modal-open'); // body 스크롤 잠금 해제
    signatureModal.style.display = 'none'; 
    currentSignatureItemNo = null; 
};

const saveSignature = () => {
    const signatureText = signatureTextInput.value.trim();
    if (!signatureText) {
        showMessage('서명 내용을 입력해주세요.');
        return;
    }

    if (currentSignatureItemNo !== null) {
        const currentTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
        handleStatusChange(currentSignatureItemNo, '완료', currentTime, '서명', signatureText);
        sortItemsByDistanceSilent(); // 거리순 정렬 중이었다면 순서 자동 갱신
        closeSignatureModal();
    }
};

const openCompletionOptionsModal = (itemNo) => {
    completionOptionsTitle.textContent = `${itemNo}번 완료 옵션 선택`;
    completionOptionsList.innerHTML = '';

    const options = [
        { text: '경비실', type: '경비실', detail: '경비실 전달' },
        { text: '택배함', type: '택배함', detail: '택배함 보관' },
        { text: '택배보관소', type: '택배보관소', detail: '택배보관소 보관' },
        { text: '문서수발실', type: '문서수발실', detail: '문서수발실 전달' }
    ];

    options.forEach(option => {
        const button = document.createElement('button');
        button.className = 'w-full px-4 py-3 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-base font-semibold';
        button.textContent = option.text;
        button.onclick = () => {
            const currentTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
            handleStatusChange(itemNo, '완료', currentTime, option.type, option.detail);
            sortItemsByDistanceSilent();
            document.body.classList.remove('modal-open'); // body 스크롤 잠금 해제
            completionOptionsModal.style.display = 'none';
        };
        completionOptionsList.appendChild(button);
    });

    document.body.classList.add('modal-open'); // body 스크롤 잠금
    completionOptionsModal.style.display = 'flex';
};

const openConfirmationModal = (message, onOk, okText = '확인', cancelText = '취소') => {
    confirmationModalTitle.textContent = '확인';
    confirmationModalBody.innerHTML = `<p class="text-base text-gray-700 mb-6" id="confirmation-modal-message">${message}</p>`;
    confirmOkButton.textContent = okText;
    confirmCancelButton.textContent = cancelText;
    confirmCancelButton.style.display = '';
    confirmationModalButtons.style.display = 'flex';
    onConfirmCallback = onOk;
    document.body.classList.add('modal-open'); // body 스크롤 잠금
    confirmationModal.style.display = 'flex';
};

const closeConfirmationModal = () => { 
    document.body.classList.remove('modal-open'); // body 스크롤 잠금 해제
    confirmationModal.style.display = 'none'; 
    onConfirmCallback = null; 
};

const openSmartEditModal = (itemNo) => {
    currentEditItemNo = itemNo;
    const item = deliveryItems.find(i => i.no === itemNo);
    if (!item) { showMessage('카드 정보를 찾을 수 없습니다.'); return; }
    
    const originalFullAddress = item.baseAddress + (item.detailAddress ? `, ${item.detailAddress}` : '');
    
    originalAddressDisplay.textContent = item.receiverAddressOriginal || '원본 주소 없음';
    piecesAddressInput.value = '';
    directAddressInput.value = originalFullAddress;
    setTimeout(() => {
        autoResizeTextarea({target: piecesAddressInput});
        autoResizeTextarea({target: directAddressInput});
    }, 0);

    const addressPiecesContainer = document.getElementById('address-pieces-container');
    const numberKeypad = document.getElementById('number-keypad');
    const unitKeypad = document.getElementById('unit-keypad');
    [addressPiecesContainer, numberKeypad, unitKeypad].forEach(c => c.innerHTML = '');
    
    const createKeyButton = (text, colorClass, value, action = 'add') => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = `key-button flex-shrink-0 font-semibold m-1 text-sm rounded-md py-1.5 flex items-center justify-center ${colorClass}`;
    button.dataset.value = value !== undefined ? value : text;
    button.dataset.action = action;
    
    const buttonText = document.createElement('span');
    buttonText.textContent = text;
    button.appendChild(buttonText);

    const keyPop = document.createElement('span');
    keyPop.className = 'key-pop';
    keyPop.textContent = text;
    button.appendChild(keyPop);

    // **직접 클릭 핸들러 추가** — 이벤트 위임이 먹지 않을 때도 동작하도록 보완
    button.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            // piecesAddressInput은 openSmartEditModal 안에서 이미 선언/참조 가능한 변수여야 합니다.
            const input = piecesAddressInput;
            let currentValue = input ? input.value : '';

            const act = button.dataset.action;
            const val = button.dataset.value;

            switch (act) {
                case 'add':
                    input.value = currentValue + val;
                    break;
                case 'add-space':
                    input.value = currentValue + (currentValue.length > 0 && !/\s$/.test(currentValue) ? ' ' : '') + val;
                    break;
                case 'add-unit':
                    input.value = currentValue + val + ' ';
                    break;
                case 'add-comma':
                    input.value = currentValue + (currentValue.length > 0 && !/\s$/.test(currentValue) ? '' : '') + ', ';
                    break;
                case 'add-hyphen':
                    input.value = currentValue + '-';
                    break;
                case 'backspace-char':
                    input.value = currentValue.slice(0, -1);
                    break;
                case 'backspace-word':
                    const lastSpaceIndex = currentValue.trimEnd().lastIndexOf(' ');
                    if (lastSpaceIndex > -1) {
                        input.value = currentValue.substring(0, lastSpaceIndex).trimEnd();
                    } else {
                        input.value = '';
                    }
                    break;
                default:
                    // 숫자키 등 기본 추가 동작
                    input.value = currentValue + (val !== undefined ? val : act);
                    break;
            }

            // textarea 자동 사이즈 조정 (함수는 이미 정의되어야 함)
            try { autoResizeTextarea({ target: input }); } catch (err) { /* 무시 */ }
        });
        return button;
    };

        // AI가 최초 생성한 주소를 기준으로 조각 생성
    const basePieces = (item.baseAddress_AI || item.baseAddress || '').split(/[\s,]+/).filter(Boolean);
    basePieces.forEach(piece => addressPiecesContainer.appendChild(createKeyButton(piece, 'bg-blue-100 text-blue-800 hover:bg-blue-200 px-3 !py-1.5 rounded-full', undefined, 'add-space')));

    const detailAddressSource = typeof item.detailAddress_AI !== 'undefined' ? item.detailAddress_AI : item.detailAddress;
    if (detailAddressSource) {
        addressPiecesContainer.appendChild(createKeyButton(',', 'bg-gray-200 text-gray-800 hover:bg-gray-300 px-3 !py-1.5 rounded-full', undefined, 'add-comma'));
        const detailPieces = (detailAddressSource || '').split(/[\s,]+/).filter(Boolean);
        detailPieces.forEach(piece => addressPiecesContainer.appendChild(createKeyButton(piece, 'bg-green-100 text-green-800 hover:bg-green-200 px-3 !py-1.5 rounded-full', undefined, 'add-space')));
    }

    // Number Keypad
    ['1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '0', '-'].forEach(key => {
        let action = 'add';
        let colorClass = 'bg-gray-200 hover:bg-gray-300';
        if (['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'].includes(key)) {
            colorClass = 'bg-green-100 text-green-800 hover:bg-green-200';
        }
        if (key === ',') action = 'add-comma';
        if (key === '-') action = 'add-hyphen';
        numberKeypad.appendChild(createKeyButton(key, colorClass, key, action));
    });

    // Unit Keypad
    unitKeypad.appendChild(createKeyButton('길', 'bg-blue-100 hover:bg-blue-200', '길', 'add-unit'));
    unitKeypad.appendChild(createKeyButton('번길', 'bg-blue-100 hover:bg-blue-200', '번길', 'add-unit'));
    unitKeypad.appendChild(createKeyButton('동', 'bg-blue-100 hover:bg-blue-200', '동', 'add-unit'));
    unitKeypad.appendChild(createKeyButton('리', 'bg-blue-100 hover:bg-blue-200', '리', 'add-unit'));
    unitKeypad.appendChild(createKeyButton('\u00A0', 'bg-gray-200 hover:bg-gray-300', ' ', 'add')); // 공백
    unitKeypad.appendChild(createKeyButton('<', 'bg-gray-400 hover:bg-gray-500 text-white', '<', 'backspace-char'));
    const backspaceWordBtn = createKeyButton('<<', 'bg-red-500 hover:bg-red-600 text-white', '<<', 'backspace-word');
    backspaceWordBtn.classList.add('col-span-2');
    unitKeypad.appendChild(backspaceWordBtn);

    document.body.classList.add('modal-open'); // body 스크롤 잠금
    smartEditModal.style.display = 'flex';
    history.pushState({ smartEditModalOpen: true }, "");
};

const closeSmartEditModal = () => {
    // history 상태가 있을 경우, history.back()을 호출하여 popstate 이벤트를 트리거합니다.
    // popstate 리스너가 모달을 닫는 실제 동작을 처리할 것입니다.
    if (history.state && history.state.smartEditModalOpen) {
        history.back();
    } else {
        // 만약 history 상태가 없는 예외적인 경우, 직접 모달을 닫습니다.
        document.body.classList.remove('modal-open');
        smartEditModal.style.display = 'none';
        currentEditItemNo = null;
    }
};
        

        const applyAddressEdit = async (fullAddress) => {
            if (currentEditItemNo === null) return;
            
            showLoadingMessage('주소 검증 중...');

            const itemIndex = deliveryItems.findIndex(item => item.no === currentEditItemNo);
            if (itemIndex === -1) {
                closeConfirmationModal();
                showMessage('오류: 수정할 카드를 찾을 수 없습니다.');
                return;
            }

            const commaIndex = fullAddress.indexOf(',');
            let tempBaseAddress, tempDetailAddress;

            if (commaIndex > -1) {
                tempBaseAddress = fullAddress.substring(0, commaIndex).trim();
                tempDetailAddress = fullAddress.substring(commaIndex + 1).trim();
            } else {
                tempBaseAddress = fullAddress;
                tempDetailAddress = '';
            }

            const validationResult = await validateAddressWithKakao(tempBaseAddress, tempDetailAddress);
            closeConfirmationModal();

            const saveAddress = (base, detail, isValidated) => { // <-- isValidated 파라미터 추가
    deliveryItems[itemIndex].baseAddress = base;
    deliveryItems[itemIndex].detailAddress = detail;
    deliveryItems[itemIndex].addressLocation = null;
    deliveryItems[itemIndex].isAddressValidated = isValidated; // <-- 검증 상태 업데이트
    saveDeliveryItemsToLocalStorage();
    renderDeliveryCards(activeFilter);
    closeSmartEditModal();
};

if (validationResult.validated) {
    saveAddress(validationResult.baseAddress, validationResult.detailAddress, true); // <-- true 전달
    showToastMessage('주소가 검증 및 저장되었습니다.');
} else {
    const message = `카카오맵에서 주소를 찾을 수 없습니다. 입력하신 '${fullAddress}' 주소 그대로 저장하시겠습니까?`;
    openConfirmationModal(message, () => {
        saveAddress(tempBaseAddress, tempDetailAddress, false); // <-- false 전달
        showToastMessage('입력한 주소 그대로 저장되었습니다.');
    });
}
        };
        
        applyPiecesBtn.addEventListener('click', async () => await applyAddressEdit(piecesAddressInput.value.trim()));
        applyDirectBtn.addEventListener('click', async () => await applyAddressEdit(directAddressInput.value.trim()));
        
        resetPiecesBtn.addEventListener('click', () => {
            piecesAddressInput.value = '';
            autoResizeTextarea({target: piecesAddressInput});
        });
        
                revertDirectBtn.addEventListener('click', () => {
            const item = deliveryItems.find(i => i.no === currentEditItemNo);
            if(item) {
                // AI 최초 생성 주소로 복원
                const originalBase = typeof item.baseAddress_AI !== 'undefined' ? item.baseAddress_AI : item.baseAddress;
                const originalDetail = typeof item.detailAddress_AI !== 'undefined' ? item.detailAddress_AI : item.detailAddress;
                directAddressInput.value = originalBase + (originalDetail ? `, ${originalDetail}` : '');
                autoResizeTextarea({target: directAddressInput});
            }
        });

        // [새로 추가] 직접 주소 편집 입력창 비우기 버튼
        const resetDirectBtn = document.getElementById('reset-direct-btn');
        resetDirectBtn.addEventListener('click', () => {
            directAddressInput.value = '';
            autoResizeTextarea({target: directAddressInput});
        });
        
        smartEditExitBtn.addEventListener('click', closeSmartEditModal);

        piecesAddressInput.addEventListener('input', autoResizeTextarea);
        directAddressInput.addEventListener('input', autoResizeTextarea);
        
        confirmOkButton.addEventListener('click', () => { if (onConfirmCallback) onConfirmCallback(); closeConfirmationModal(); });
        confirmCancelButton.addEventListener('click', closeConfirmationModal);
        clearSignatureBtn.addEventListener('click', () => signatureTextInput.value = '');
        cancelSignatureBtn.addEventListener('click', closeSignatureModal);
        saveSignatureBtn.addEventListener('click', saveSignature);

        const saveDeliveryItemsToLocalStorage = () => {
            localStorage.setItem('deliveryItems', JSON.stringify(deliveryItems));
            localStorage.setItem('filterScrollPositions', JSON.stringify(filterScrollPositions));
        };
        const handleStatusChange = (itemNo, newStatus, completionTime = null, completionType = null, completionDetail = null) => {
            deliveryItems = deliveryItems.map(item => item.no === itemNo ? { ...item, status: newStatus, deliveryCompletionTime: completionTime, completionType, completionDetail, isHawbConfirmed: newStatus !== '배송전' } : item);
            saveDeliveryItemsToLocalStorage();
            renderDeliveryCards(activeFilter);
            updateFilterCounts();
        };

        const handleCheckboxToggleAndResetSearch = async (itemNo, newCheckboxState) => {
            const checkbox = document.querySelector(`input[data-action="toggle-hawb-confirm"][data-no="${itemNo}"]`);
            if (!checkbox) return;

            const itemIndex = deliveryItems.findIndex(item => item.no === itemNo);
            if (itemIndex === -1) return;

            if (newCheckboxState) { // 체크박스를 켤 때 (체크인)
                // 1. 가장 먼저 상태 변경과 UI 업데이트를 실행합니다.
                deliveryItems[itemIndex].isHawbConfirmed = true;
                deliveryItems[itemIndex].status = '배송중';
                
                saveDeliveryItemsToLocalStorage();
                searchTerm = '';
                invoiceNumberInput.value = '';
                renderDeliveryCards(activeFilter); // 여기서 카드가 '배송전' 목록에서 사라집니다.
                updateFilterCounts();
                collapseSearch();

                // 2. 그 다음, 백그라운드에서 좌표 획득을 시도합니다.
                // 이 과정이 실패해도 이미 상태 변경은 완료되었으므로 앱은 정상적으로 동작합니다.
                if (!deliveryItems[itemIndex].addressLocation) {
                    try {
                        const coords = await getCoordsFromAddress(deliveryItems[itemIndex].baseAddress);
                        deliveryItems[itemIndex].addressLocation = coords;
                        saveDeliveryItemsToLocalStorage(); // 좌표 획득 성공 시 다시 저장
                        showToastMessage(`${itemNo}번 체크인 완료 (좌표 저장 성공)`);
                    } catch (error) {
                        console.error(`좌표 획득 실패 (항목 ${itemNo}):`, error.message);
                        // 사용자에게는 간단한 알림만 주고, 앱 흐름을 막지 않습니다.
                        showToastMessage(`${itemNo}번 체크인 완료 (좌표 저장 실패)`, 2500);
                    }
                } else {
                    showToastMessage(`${itemNo}번 체크인 완료 (좌표 이미 존재)`);
                }

            } else { // 체크박스를 끌 때 (체크인 취소)
                deliveryItems[itemIndex].isHawbConfirmed = false;
                deliveryItems[itemIndex].status = '배송전';
                deliveryItems[itemIndex].addressLocation = null;
                delete deliveryItems[itemIndex].distanceFromMe;
                
                saveDeliveryItemsToLocalStorage();
                searchTerm = '';
                invoiceNumberInput.value = '';
                renderDeliveryCards(activeFilter);
                updateFilterCounts();
                showToastMessage('체크인이 취소되었습니다.');
            }
        };
        
        const openMap = (item) => {
            const selectedMap = localStorage.getItem('selectedMap') || 'naver';
            const addressForMapSearch = item.baseAddress || '';
            const textToCopy = `${item.no}. ${extractClipboardAddressPart(item)}`;

            navigator.clipboard.writeText(textToCopy).catch(err => {
                console.error('클립보드 복사 실패:', err);
                showMessage('클립보드 복사에 실패했습니다.', '복사 실패');
            });

            let mapUrl;
            if (selectedMap === 'naver') {
                mapUrl = `nmap://search?query=${encodeURIComponent(addressForMapSearch)}&appname=DeliveryApp`;
            } else { // kakao
                mapUrl = `kakaomap://search?q=${encodeURIComponent(addressForMapSearch)}`;
            }
            window.location.href = mapUrl;
        };

        const highlightHawbNo = (hawbNo, term) => {
            if (!hawbNo) return '';
            const formattedHawbNo = formatHawbNoForDisplay(hawbNo);
            if (!term || !formattedHawbNo.toLowerCase().includes(term.toLowerCase())) return formattedHawbNo;
            const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(${escapedTerm})`, 'gi');
            return formattedHawbNo.replace(regex, `<span class="bg-yellow-200 rounded px-0.5">$1</span>`);
        };
        
                // --- Render function ---
        const renderDeliveryCards = (currentFilter, animationClass = '') => {
            if (currentFilter === '배송준비') { deliveryCardsContainer.innerHTML = ''; return; }

            let baseData = [];
            if (currentFilter !== '전체') {
                baseData = deliveryItems.filter(item => item.status === currentFilter);
            } else {
                baseData = [...deliveryItems];
            }

            let dataToRender = [];
            if (searchTerm) {
                const cleanedSearchTerm = searchTerm.trim().replace(/[\s-]/g, '').toLowerCase();
                dataToRender = baseData.filter(item => {
                    const hawbMatch = item.hawbNo?.replace(/[\s-]/g, '').toLowerCase().includes(cleanedSearchTerm);
                    const phoneMatch = item.receiverTelephoneNo?.includes(cleanedSearchTerm);
                    return hawbMatch || phoneMatch;
                });
            } else {
                dataToRender = baseData;
            }
            
            if (dataToRender.length === 0) {
                deliveryCardsContainer.innerHTML = '<p class="text-center text-gray-600 px-4">해당하는 항목이 없습니다.</p>';
                return;
            }

            deliveryCardsContainer.innerHTML = dataToRender.map(data => {
                const selectedMap = localStorage.getItem('selectedMap') || 'naver'; // [이 줄 추가]
                const mapButtonClass = selectedMap === 'naver' ? 'naver' : 'kakao'; // [이 줄 추가]
                const isPhoneNumberInvalid = !isValidPhoneNumber(data.receiverTelephoneNo);
                const fullAddress = data.baseAddress + (data.detailAddress ? `, ${data.detailAddress}` : '');
                const isMapButtonActive = isValidAddressForMap(data.baseAddress) && ['전체', '배송전', '배송중'].includes(currentFilter);
                const distanceInfo = (currentSortOrder === 'distance' && data.distanceFromMe !== undefined && data.status === '배송중')
                    ? `<span class="block text-sm font-medium text-purple-600 -mt-1">(${data.distanceFromMe.toFixed(2)} km)</span>`
                    : '';
                
                // ▼▼▼▼▼ [수정] 클래스 정의 로직을 map 루프 안으로 이동 및 수정 ▼▼▼▼▼
                let cardClasses = '';
                let headerBorder = 'border-gray-200';
                let actionBorder = 'border-gray-200';

                if (data.status === '배송전') {
                    cardClasses = 'bg-white rounded-t-3xl rounded-bl-3xl border-2 border-gray-600';
                } else if (data.status === '배송중') {
                    cardClasses = 'bg-blue-50 rounded-t-3xl rounded-bl-3xl border-2 border-blue-600';
                    headerBorder = 'border-blue-200';
                    actionBorder = 'border-blue-200';
                } else if (data.status === '완료') {
                    // '전체' 필터에서도 완료 카드가 이 스타일을 따르도록 여기에 정의
                    cardClasses = 'bg-gray-200 rounded-t-3xl rounded-bl-3xl border-2 border-gray-300';
                }
                // ▲▲▲▲▲ [수정] ▲▲▲▲▲

                const showCompletedCard = !['전체', '배송전', '배송중'].includes(currentFilter) && data.status === '완료';
                const showInProgressButtons = !['전체', '배송전', '완료'].includes(currentFilter) && data.status === '배송중';

                const detailsHtml = `
                    <div class="flex items-start space-x-2.5">
                        <button data-action="open-map" data-no="${data.no}" class="map-icon-button rounded-full flex items-center justify-center ${mapButtonClass} ${isMapButtonActive ? '' : 'opacity-50 cursor-not-allowed'}" ${isMapButtonActive ? '' : 'disabled'}>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 22a1 1 0 0 1-1-1v-4a1 1 0 0 1 .445-.832l3-2a1 1 0 0 1 1.11 0l3 2A1 1 0 0 1 22 17v4a1 1 0 0 1-1 1z"/><path d="M18 10a8 8 0 0 0-16 0c0 4.993 5.539 10.193 7.399 11.799a1 1 0 0 0 .601.2"/><path d="M18 22v-3"/><circle cx="10" cy="10" r="3"/></svg>
                        </button>
                        <div class="pt-0.5">
    <p class="text-base font-semibold ${currentFilter !== '배송중' ? 'cursor-pointer' : ''} ${data.isAddressValidated === false ? 'text-red-500' : 'text-blue-600'}"
       ${currentFilter !== '배송중' ? `data-action="open-smart-edit" data-no="${data.no}"` : ''}>
        ${fullAddress.trim() ? fullAddress : '<span class="text-red-500 cursor-pointer underline font-medium">[주소 없음 (터치하여 입력)]</span>'}
    </p>
    ${data.receiverAddressOriginal ? `<p class="text-xs text-gray-500">(${data.receiverAddressOriginal})</p>` : ''}
</div>
                    </div>
                    <div class="flex items-start space-x-2.5">
                        <div class="flex-shrink-0 pt-1 text-gray-600">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z"/><path d="M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2"/><path d="M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2"/><path d="M10 6h4"/><path d="M10 10h4"/><path d="M10 14h4"/><path d="M10 18h4"/></svg>
                        </div>
                        <div>
                            <p class="text-base text-blue-600 font-semibold">${data.companyNameKorean || 'N/A'}</p>
                            ${data.companyNameOriginal && data.companyNameOriginal !== data.companyNameKorean ? `<p class="text-xs text-gray-500">(${data.companyNameOriginal})</p>` : ''}
                        </div>
                    </div>
                    <div class="flex items-start space-x-2.5">
                        <div class="flex-shrink-0 pt-1 text-gray-600">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><path d="M16 3.128a4 4 0 0 1 0 7.744"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><circle cx="9" cy="7" r="4"/></svg>
                        </div>
                        <div>
                            <div class="flex items-center space-x-2">
                                <p class="text-base text-blue-600 font-semibold">${data.receiverNameKorean || 'N/A'}</p>
                                <button data-action="swap-name" data-no="${data.no}" class="p-1 text-gray-400 rounded-full">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>
                                </button>
                            </div>
                            ${data.receiverNameOriginal && data.receiverNameOriginal !== data.receiverNameKorean ? `<p class="text-xs text-gray-500">(${data.receiverNameOriginal})</p>` : ''}
                        </div>
                    </div>
                    <div class="flex items-start space-x-2.5">
                        <div class="flex-shrink-0 pt-1 text-gray-600">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="20" x="5" y="2" rx="2" ry="2"/><path d="M12 18h.01"/></svg>
                        </div>
                        <div class="flex items-center space-x-2">
    <span 
        class="text-base font-semibold cursor-pointer ${isPhoneNumberInvalid || !data.receiverTelephoneNo ? 'text-red-500 underline' : 'text-blue-600'}"
        data-action="edit-phone" data-no="${data.no}"
    >
        ${data.receiverTelephoneNo ? formatPhoneNumberForDisplay(data.receiverTelephoneNo) : '[번호 없음 (터치하여 입력)]'}
    </span>
                            <a href="tel:${getCleanPhoneNumber(data.receiverTelephoneNo)}" class="px-3 py-1.5 rounded-full bg-transparent text-orange-500 border border-orange-500 text-sm font-medium hover:bg-orange-100 ${!data.receiverTelephoneNo ? 'hidden' : ''}">전화</a>
                            <a href="sms:${getCleanPhoneNumber(data.receiverTelephoneNo)}" class="px-3 py-1.5 rounded-full bg-transparent text-blue-500 border border-blue-500 text-sm font-medium hover:bg-blue-100 ${!data.receiverTelephoneNo ? 'hidden' : ''}">문자</a>
                        </div>
                    </div>
                    ${data.status === '완료' ? `<div class="mt-4 pt-4 border-t border-gray-200 flex justify-center"><button data-action="revert-delivery" data-no="${data.no}" class="px-4 py-2 rounded-md bg-red-500 text-white text-sm font-medium">되돌리기</button></div>` : ''}
                `;

                                if (showCompletedCard) {
                    const completionDisplayHtml = data.completionType === '서명' && data.completionDetail 
                        ? `<span class="text-lg font-semibold text-gray-800 p-1 border border-dashed border-gray-400 rounded-md bg-gray-50 inline-block">${data.completionDetail}</span>`
                        : data.completionType === '본인전달'
                            ? `<span class="text-lg font-semibold text-gray-800">${data.receiverNameKorean || ''}</span>`
                            : `${data.completionType || ''}`;

                    return `
                        <div class="${cardClasses} p-4 mb-4" data-no="${data.no}" data-status="완료">
                            <div class="flex justify-between items-center">
                                <div class="text-xl font-semibold text-gray-700 text-left ${data.isStruckThrough ? 'completed-strikethrough' : ''}">
                                    <span class="text-red-500 text-2xl mr-4">${data.no}</span>
                                    ${completionDisplayHtml}
                                    <span class="ml-2">${formatCompletionTime(data.deliveryCompletionTime)}</span>
                                </div>
                                <button data-action="toggle-details" data-no="${data.no}" class="p-2 rounded-full hover:bg-gray-200 flex-shrink-0">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                                    </svg>
                                </button>
                            </div>
                            <div class="space-y-3 mt-4 pt-4 border-t border-gray-300" data-details-container="${data.no}" style="display:none;">
                                ${detailsHtml}
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="${cardClasses} p-6 mb-4" data-no="${data.no}">
                            <div class="flex justify-between items-start mb-4 pb-2 border-b ${headerBorder}">
                                <div class="flex justify-between items-start w-full">
                                    <div class="flex items-start space-x-4">
                                        <div>
                                            <h3 class="text-3xl font-semibold text-red-500">${data.no}</h3>
                                            ${distanceInfo}
                                        </div>
                                    <div class="pt-1.5">
                                            <span data-action="copy-hawb" data-hawb-no="${data.hawbNo}" data-no="${data.no}" class="text-base font-bold text-gray-600 whitespace-nowrap">${highlightHawbNo(data.hawbNo, searchTerm)}</span>
                                        </div>
                                    </div>
                                    <div class="pt-1.5">
                                        <input type="checkbox" data-action="toggle-hawb-confirm" data-no="${data.no}" ${data.isHawbConfirmed ? 'checked' : ''} class="form-checkbox h-4 w-4 text-blue-600 border-gray-300 rounded ml-2"/>
                                    </div>
                                </div>
                            </div>
                            <div class="space-y-3" data-details-container="${data.no}">
                                ${detailsHtml}
                            </div>
                            ${showInProgressButtons ? `
                                <div class="mt-4 pt-4 border-t ${actionBorder} flex justify-between space-x-2 w-full">
                                    <button data-action="identity-verification" data-no="${data.no}" class="flex-1 px-3 py-2 rounded-lg bg-green-500 text-white text-sm font-semibold hover:bg-green-600 transition-colors">본인전달</button>
                                    <button data-action="open-location-modal" data-no="${data.no}" class="flex-1 px-3 py-2 rounded-lg bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition-colors">배송위치</button>
                                    <button data-action="sign-delivery" data-no="${data.no}" class="flex-1 px-3 py-2 rounded-lg bg-indigo-500 text-white text-sm font-semibold hover:bg-indigo-600 transition-colors">직접입력</button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            }).join('');
        
            if (animationClass) {
                deliveryCardsContainer.classList.remove('animate-slide-in-left', 'animate-slide-in-right');
                void deliveryCardsContainer.offsetWidth; // Reflow to restart animation
                deliveryCardsContainer.classList.add(animationClass);
            }
        };

    // --- UI Update & Event Listener Setup ---
    const updateFilterCounts = () => {
        const counts = {
            '전체': deliveryItems.length,
            '배송전': deliveryItems.filter(item => item.status === '배송전').length,
            '배송중': deliveryItems.filter(item => item.status === '배송중').length,
            '완료': deliveryItems.filter(item => item.status === '완료').length
        };

        for (const filter in counts) {
            const countElement = document.getElementById(`count-${filter}`);
            if (countElement) {
                const count = counts[filter];
                countElement.textContent = count > 99 ? '99+' : count;
                countElement.classList.toggle('hidden', count === 0);
            }
        }
    };
    
    const updateStickyHeaderPositions = () => {
        requestAnimationFrame(() => {
            const isScanVisible = activeFilter === '배송준비';
            scanSectionContainer.classList.toggle('hidden', !isScanVisible);
            dataManagementContainer.classList.toggle('hidden', !isScanVisible);
            versionInfoContainer.classList.toggle('hidden', !isScanVisible); 

            const isSearchVisible = ['전체', '배송전'].includes(activeFilter);
            searchBarContainer.style.display = isSearchVisible ? 'block' : 'none';
            
            const isActionVisible = ['배송중', '완료'].includes(activeFilter);
            actionBarContainer.style.display = isActionVisible ? 'block' : 'none';

            if (isActionVisible) {
                setupFab(); // 새로운 FAB 설정 함수 호출
            }
        });
    };
    
    const setupFab = () => {

if (activeFilter !== '배송중' && activeFilter !== '완료') {
            return; 
        }

        const fabMainButton = document.getElementById('fab-main-button');
        const fabOptions = document.getElementById('fab-options');
        fabOptions.innerHTML = '';
        fabMainButton.innerHTML = '';

        let menuItems = [];
        let currentSortType = '';
        let activeColorClass = '';

        if (activeFilter === '배송중') {
            menuItems = [
                { icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 12h11"/><path d="M10 18h11"/><path d="M10 6h11"/><path d="M4 10h2"/><path d="M4 6h1v4"/><path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>`, action: 'jump-no' },
                { icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 16 4 4 4-4"/><path d="M7 20V4"/><rect x="15" y="4" width="4" height="6" ry="2"/><path d="M17 20v-6h-2"/><path d="M15 20h4"/></svg>`, action: 'sort-no', sortType: 'no' },
                { icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="2" x2="5" y1="12" y2="12"/><line x1="19" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="5"/><line x1="12" x2="12" y1="19" y2="22"/><circle cx="12" cy="12" r="7"/></svg>`, action: 'sort-distance', sortType: 'distance' }
            ];
            currentSortType = deliveryInProgressSortOrder;
            activeColorClass = 'bg-blue-600 text-white';
        } else if (activeFilter === '완료') {
            menuItems = [
                { icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 16 4 4 4-4"/><path d="M7 20V4"/><rect x="15" y="4" width="4" height="6" ry="2"/><path d="M17 20v-6h-2"/><path d="M15 20h4"/></svg>`, action: 'sort-no-completed', sortType: 'no' },
                { icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 6v6l4 2"/><circle cx="12" cy="12" r="10"/></svg>`, action: 'sort-time', sortType: 'time' }
            ];
            currentSortType = completedSortOrder;
            activeColorClass = 'bg-gray-800 text-white';
        }

        const activeItem = menuItems.find(item => item.sortType === currentSortType) || menuItems.find(item => item.sortType);
        fabMainButton.innerHTML = activeItem.icon;
        fabMainButton.className = `w-10 h-10 flex-shrink-0 flex items-center justify-center rounded-full transition-colors duration-200 ${activeColorClass}`;
        fabMainButton.dataset.action = 'toggle-fab';

        menuItems.forEach(item => {
            if (item.sortType === currentSortType) return;

            const button = document.createElement('button');
            button.className = 'w-10 h-10 flex-shrink-0 flex items-center justify-center rounded-full bg-white text-gray-600 hover:bg-gray-100 shadow-md';
            button.innerHTML = item.icon;
            button.dataset.action = item.action;
            fabOptions.appendChild(button);
        });
    };

    const sortItemsByNumber = () => {
        deliveryInProgressSortOrder = 'no';
        currentSortOrder = 'no';
        deliveryItems.sort((a, b) => a.no - b.no);
        renderDeliveryCards(activeFilter);
        setupFab(); // updateSortButtonsUI() 대신 setupFab() 호출
    };

    const sortItemsByDistanceSilent = async () => {
        if (activeFilter !== '배송중' || deliveryInProgressSortOrder !== 'distance') {
            return;
        }

        try {
            const myLocation = await getCurrentLocation(5000);
            const inProgressItems = deliveryItems.filter(item => item.status === '배송중');
            const otherItems = deliveryItems.filter(item => item.status !== '배송중');
            const itemsWithCoords = inProgressItems.filter(item => item.addressLocation);
            const itemsWithoutCoords = inProgressItems.filter(item => !item.addressLocation);
            
            itemsWithCoords.forEach(item => {
                item.distanceFromMe = calculateDistance(myLocation, item.addressLocation);
            });
            itemsWithCoords.sort((a, b) => a.distanceFromMe - b.distanceFromMe);
            
            deliveryItems = [...itemsWithCoords, ...itemsWithoutCoords, ...otherItems];
            
            renderDeliveryCards(activeFilter);
            console.log('자동 거리순 정렬 완료.');

        } catch (error) {
            console.log('자동 정렬 실패 (GPS 신호 없음):', error.message);
        }
    };

    const sortItemsByDistance = async (silent = false) => {
        if (!silent) {
            showLoadingMessage('현재 위치 확인 중...');
        }
        try {
            const myLocation = await getCurrentLocation();
            const inProgressItems = deliveryItems.filter(item => item.status === '배송중');
            const otherItems = deliveryItems.filter(item => item.status !== '배송중');
            const itemsWithCoords = inProgressItems.filter(item => item.addressLocation);
            const itemsWithoutCoords = inProgressItems.filter(item => !item.addressLocation);
            
            if (!silent && itemsWithoutCoords.length > 0) {
                showToastMessage(`${itemsWithoutCoords.length}개의 카드에 좌표 정보가 없어 정렬에서 제외됩니다.`);
            }
            
            itemsWithCoords.forEach(item => {
                item.distanceFromMe = calculateDistance(myLocation, item.addressLocation);
            });
            itemsWithCoords.sort((a, b) => a.distanceFromMe - b.distanceFromMe);
            
            deliveryItems = [...itemsWithCoords, ...itemsWithoutCoords, ...otherItems];
            deliveryInProgressSortOrder = 'distance';
            currentSortOrder = 'distance';
            
            if (silent) {
                if (activeFilter === '배송중') {
                    renderDeliveryCards(activeFilter);
                    showToastMessage('위치 정보가 갱신되었습니다.'); // [이 줄 추가]
                }
            } else {
                renderDeliveryCards(activeFilter);
                closeConfirmationModal();
                showToastMessage('가까운 거리순으로 정렬되었습니다.');
            }
        } catch (error) {
            if (!silent) {
                closeConfirmationModal();
                showToastMessage('GPS 신호 없음. 마지막 정렬 순서를 유지합니다.', 2500);
            }
            console.error("위치 갱신 실패:", error.message);
        } finally {
            setupFab(); // updateSortButtonsUI() 대신 setupFab() 호출
        }
    };

    const changeFilter = (newFilter, animationClass = '', isInitialLoad = false) => {
        if (newFilter === activeFilter && !isInitialLoad) return;

        collapseSearch();
        document.getElementById('fab-options').classList.remove('expanded'); // [추가] 정렬 버튼 접기

        if (!isInitialLoad) {
            searchTerm = '';
            invoiceNumberInput.value = '';
        }

        const mainContentWrapper = document.getElementById('main-content-wrapper');
        filterScrollPositions[activeFilter] = mainContentWrapper.scrollTop;
        activeFilter = newFilter;

        if (newFilter === '배송중') {
            currentSortOrder = deliveryInProgressSortOrder;
            if (deliveryInProgressSortOrder === 'distance') {
                const itemsWithDistance = deliveryItems.filter(item => item.distanceFromMe !== undefined);
                const itemsWithoutDistance = deliveryItems.filter(item => item.distanceFromMe === undefined);
                itemsWithDistance.sort((a, b) => a.distanceFromMe - b.distanceFromMe);
                deliveryItems = [...itemsWithDistance, ...itemsWithoutDistance];
                
                // sortItemsByDistance(true); // [이 줄 삭제 또는 주석 처리]
            } else { 
                deliveryItems.sort((a, b) => a.no - b.no);
            }
        } else if (newFilter === '완료') {
            currentSortOrder = completedSortOrder;
            if (completedSortOrder === 'time') {
                const completedItems = deliveryItems.filter(item => item.status === '완료');
                const otherItems = deliveryItems.filter(item => item.status !== '완료');
                completedItems.sort((a, b) => {
                    if (!a.deliveryCompletionTime) return 1;
                    if (!b.deliveryCompletionTime) return -1;
                    return a.deliveryCompletionTime.localeCompare(b.deliveryCompletionTime);
                });
                deliveryItems = [...completedItems, ...otherItems];
            } else { 
                deliveryItems.sort((a, b) => a.no - b.no);
            }
        } else { 
            currentSortOrder = 'no';
            deliveryItems.sort((a, b) => a.no - b.no);
        }

        filterButtonsContainer.querySelectorAll('button[data-filter]').forEach(btn => {
            const svg = btn.querySelector('svg');
            const isActive = btn.dataset.filter === activeFilter;
            
            const baseClasses = 'relative w-16 h-12 flex items-center justify-center rounded-lg transition-colors';
            const activeClasses = 'bg-blue-100 text-blue-600';
            const inactiveClasses = 'bg-transparent text-gray-500';

            if (isActive) {
                btn.className = `${baseClasses} ${activeClasses}`;
                svg.classList.remove('text-gray-500');
                svg.classList.add('text-blue-600');
            } else {
                btn.className = `${baseClasses} ${inactiveClasses}`;
                svg.classList.remove('text-blue-600');
                svg.classList.add('text-gray-500');
            }
        });
        
        renderDeliveryCards(activeFilter, animationClass);
        updateStickyHeaderPositions();
        const button = filterButtonsContainer.querySelector(`button[data-filter="${activeFilter}"]`);
        if (button) button.scrollIntoView({ behavior: 'smooth', inline: 'center' });
        
        setTimeout(() => {
            mainContentWrapper.scrollTo({ top: filterScrollPositions[activeFilter] || 0, behavior: 'auto' });
        }, 0);
    };

    filterButtonsContainer.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-filter]');
        if (!button) return;
        const newFilter = button.dataset.filter;
        
        const oldIndex = filterCategories.indexOf(activeFilter);
        const newIndex = filterCategories.indexOf(newFilter);
        const animation = newIndex > oldIndex ? 'animate-slide-in-right' : 'animate-slide-in-left';

        changeFilter(newFilter, animation);
    });

    // 검색창 입력 시 실시간으로 검색 결과 필터링
    invoiceNumberInput.addEventListener('input', (event) => {
        searchTerm = event.target.value.trim();
        renderDeliveryCards(activeFilter);
        // 검색 시 스크롤을 맨 위로 이동
        document.getElementById('main-content-wrapper').scrollTo({ top: 0, behavior: 'auto' });
        filterScrollPositions[activeFilter] = 0;
    });

    // 지움 버튼 클릭 시 검색어 초기화
    resetButton.addEventListener('click', () => {
        searchTerm = '';
        invoiceNumberInput.value = '';
        renderDeliveryCards(activeFilter);
    });

    // 필터 변경 시 검색창 초기화 (기존 collapseSearch() 호출 부분을 대체)
    const collapseSearch = () => {
        // 이 함수는 이제 필터 변경 시 검색어를 초기화하는 역할만 합니다.
        // 실제 UI를 접는 기능은 없어졌습니다.
        searchTerm = '';
        invoiceNumberInput.value = '';
    };

    // document.addEventListener('click', ...) 부분에서 검색창 관련 로직 제거
    document.addEventListener('click', (event) => {
        const clickedElement = event.target;
        const fabPanel = document.getElementById('fab-panel');

        // 클릭된 요소가 정렬 버튼 패널의 자식이 아닐 경우 정렬 버튼을 닫음
        if (!fabPanel.contains(clickedElement)) {
            document.getElementById('fab-options').classList.remove('expanded');
        }
    });

    deliverySheetImageInput.addEventListener('change', (event) => {
        currentFileToScan = event.target.files;
        selectedFilesDisplay.textContent = currentFileToScan.length > 0 ? `선택된 파일: ${Array.from(currentFileToScan).map(f => f.name).join(', ')}` : '선택된 파일 없음';
    });

    async function performScan(filesToScan) {
        const CONCURRENT_LIMIT = 4;
        const totalFiles = filesToScan.length;
        let completedCount = 0;

        scanProgressText.textContent = `이미지 리사이징 중 (0/${totalFiles})...`;
        const resizePromises = filesToScan.map((file, index) => 
            resizeImage(file).then(resizedObject => {
                scanProgressText.textContent = `이미지 리사이징 중 (${index + 1}/${totalFiles})...`;
                return resizedObject;
            })
        );
        const resizedImageObjects = await Promise.all(resizePromises);
        scanProgressText.textContent = `리사이징 완료, API 요청 시작...`;
        
        const tempMergedResults = new Map();
        const failedFileObjectsForRetry = [];
        const requestQueue = [...resizedImageObjects]; 

        const updateApiProgress = () => {
            completedCount++;
            scanProgressText.textContent = `API 처리 중 (${completedCount}/${totalFiles})...`;
        };

        const processApiRequest = async (resizedObject) => {
            const { file, data: base64ImageData } = resizedObject;
            let lastError = null;

            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: GEMINI_PROMPT }, { inlineData: { mimeType: 'image/jpeg', data: base64ImageData } }] }],
                        generationConfig: { temperature: 0, responseMimeType: "application/json" }
                    };
                    const tempApiKeyForLocalTest = "AIzaSyD8ZGE4WyIGatmPzRkJijnOt8PqtnLFyds";
                    const directApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${tempApiKeyForLocalTest}`;

                    const response = await fetch(directApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) { throw new Error(`API 요청 실패 (상태: ${response.status})`); }
                    
                    const result = await response.json();

                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        const parsedData = JSON.parse(result.candidates[0].content.parts[0].text);
                        if (Array.isArray(parsedData) && parsedData.length > 0) {
                             return parsedData;
                        }
                    }
                    throw new Error("AI가 유효한 배열 형식으로 응답하지 않았습니다.");
                } catch (error) {
                    lastError = error;
                    console.warn(`파일(${file.name}) 처리 시도 ${attempt} 실패:`, error);
                    if (attempt < 3) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
            }
            throw lastError;
        };
        
        const worker = async () => {
            while (requestQueue.length > 0) {
                const requestObject = requestQueue.shift(); 
                if (requestObject) {
                    try {
                        const apiResultArray = await processApiRequest(requestObject);
                        for (const geminiItem of apiResultArray) {
                            const no = parseInt(geminiItem.no || '0', 10);
                            if (no === 0) continue;
                            
                            // ▼▼▼ [추가] AI가 생성한 주소의 불필요한 쉼표를 정리하는 후처리 로직 ▼▼▼
                            if (geminiItem.baseAddressKorean && geminiItem.detailAddressKorean) {
                                // 상세 주소 안에 있는 쉼표는 모두 띄어쓰기로 변경
                                // 예: "신천동 더샵스타파크 512호, B동 10" -> "신천동 더샵스타파크 512호 B동 10"
                                geminiItem.detailAddressKorean = geminiItem.detailAddressKorean.replace(/,/g, ' ');
                            }
                            // ▲▲▲ [추가] 여기까지 ▲▲▲

                            const validationResult = await validateAddressWithKakao(geminiItem.baseAddressKorean, geminiItem.detailAddressKorean);
geminiItem.baseAddressKorean = validationResult.baseAddress;
geminiItem.detailAddressKorean = validationResult.detailAddress;
geminiItem.isAddressValidated = validationResult.validated; // <-- 검증 상태 저장

tempMergedResults.set(no, geminiItem);
                        }
                    } catch (error) {
                        console.error(`파일 스캔 오류 (${requestObject.file.name}):`, error);
                        failedFileObjectsForRetry.push(requestObject.file);
                    } finally {
                        updateApiProgress();
                    }
                }
            }
        };

        const workerPromises = Array.from({ length: CONCURRENT_LIMIT }, () => worker());
        await Promise.all(workerPromises);

        let newCount = 0;
        let updateCount = 0;
        const allNewItems = Array.from(tempMergedResults.values()); 

        if (allNewItems.length > 0) {
            const finalItems = allNewItems.map(item => ({
                no: parseInt(item.no, 10),
                hawbNo: item.hawbNo || '',
                baseAddress: item.baseAddressKorean || '',
                detailAddress: item.detailAddressKorean || '',
                baseAddress_AI: item.baseAddressKorean || '', // [이 줄 추가]
                detailAddress_AI: item.detailAddressKorean || '', // [이 줄 추가]
                receiverAddressOriginal: item.receiverAddress || '',
                companyNameOriginal: item.receiverCompanyName || '',
                receiverNameOriginal: item.receiverName || '',
                companyNameKorean: item.receiverCompanyNameKorean || item.receiverCompanyName || '',
                receiverNameKorean: item.receiverNameKorean || item.receiverName || '',
                receiverNameKoreanOriginal: item.receiverNameKorean || item.receiverName || '',
                receiverTelephoneNo: item.receiverPhone ? getCleanPhoneNumber(item.receiverPhone) : '',
                status: '배송전', isHawbConfirmed: false,
                deliveryCompletionTime: null, completionType: null, completionDetail: null,
                addressLocation: null,
                isStruckThrough: false,
                isAddressValidated: item.isAddressValidated
            }));
            
            finalItems.forEach(newItem => {
                const existingItemIndex = deliveryItems.findIndex(item => item.no === newItem.no);
                if (existingItemIndex > -1) {
                    deliveryItems[existingItemIndex] = { ...deliveryItems[existingItemIndex], ...newItem };
                    updateCount++;
                } else {
                    deliveryItems.push(newItem);
                    newCount++;
                }
            });
            deliveryItems.sort((a, b) => a.no - b.no);
            saveDeliveryItemsToLocalStorage();
        }
        return { newCount, updateCount, failedFiles: failedFileObjectsForRetry };
    }
    
    scanAndGenerateButton.addEventListener('click', async () => {
        if (!currentFileToScan || currentFileToScan.length === 0) { showMessage('스캔할 이미지를 선택해주세요.'); return; }
        
        const startTime = Date.now();
        scanLoadingIndicator.style.display = 'block';
        scanErrorMessage.style.display = 'none';
        failedFileObjects = []; 

        try {
            const initialFiles = Array.from(currentFileToScan);
            const result = await performScan(initialFiles);
            const endTime = Date.now();
            const elapsedTime = Math.round((endTime - startTime) / 1000);
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;
            const timeString = `(소요 시간: ${minutes}분 ${seconds}초)`;

            if (result.failedFiles.length === 0) {
                showMessage(`${result.updateCount}개의 카드가 업데이트되고 ${result.newCount}개의 카드가 새로 생성되었습니다. ${timeString}`);
            } else {
                failedFileObjects = result.failedFiles;
                const successCount = initialFiles.length - failedFileObjects.length;
                const failedFileNames = failedFileObjects.map(f => f.name);
                
                const message = `총 ${initialFiles.length}개 중 ${successCount}개 파일 스캔 성공. ${timeString}\n\n실패한 ${failedFileObjects.length}개 파일을 다시 스캔하시겠습니까?\n- ${failedFileNames.join('\n- ')}`;

                const onRetry = async () => {
                    scanLoadingIndicator.style.display = 'block';
                    
                    const retryResult = await performScan(failedFileObjects);

                    scanLoadingIndicator.style.display = 'none';

                    if (retryResult.failedFiles.length === 0) {
                        showMessage(`재시도 성공: ${retryResult.updateCount + retryResult.newCount}개의 카드가 추가/업데이트되었습니다.`);
                    } else {
                        const stillFailingNames = retryResult.failedFiles.map(f => f.name);
                        showMessage(`재시도 후에도 아래 ${stillFailingNames.length}개 파일이 실패했습니다.\n- ${stillFailingNames.join('\n- ')}`, '재시도 일부 실패');
                    }
                    renderDeliveryCards(activeFilter);
                    updateFilterCounts();
                };
                openConfirmationModal(message, onRetry, '실패 파일 재시도', '나중에');
            }
        } catch (error) {
            console.error("전체 스캔 프로세스 오류:", error);
            scanErrorText.textContent = error.message;
            scanErrorMessage.style.display = 'block';
        } finally {
            scanLoadingIndicator.style.display = 'none';
            deliverySheetImageInput.value = '';
            currentFileToScan = null;
            selectedFilesDisplay.textContent = '선택된 파일 없음';
            renderDeliveryCards(activeFilter);
            updateFilterCounts();
            updateStickyHeaderPositions();
        }
    });
    
    exportDataButton.addEventListener('click', () => {
        if (deliveryItems.length === 0) { showMessage("저장할 데이터가 없습니다."); return; }
        try {
            const today = new Date();
            const formattedDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            const fileName = `SF-${formattedDate}.json`;
            const dataStr = JSON.stringify(deliveryItems, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToastMessage(`데이터가 '${fileName}' 파일로 저장되었습니다.`);
        } catch (error) {
            showMessage(`데이터 저장 중 오류가 발생했습니다: ${error.message}`, "오류");
        }
    });

    importDataInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        openConfirmationModal( `'${file.name}' 파일의 데이터로 현재 목록을 모두 덮어씁니다. 계속하시겠습니까?`, () => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (!Array.isArray(importedData)) throw new Error("파일 형식이 올바르지 않습니다 (배열이 아님).");
                        
                        const firstItem = importedData[0];
                        if (importedData.length > 0 && typeof firstItem.no === 'undefined' && typeof firstItem.baseAddress === 'undefined') {
                           throw new Error("파일 내용이 올바른 배송 데이터 형식이 아닙니다.");
                        }
                        
                        deliveryItems = importedData;

                        saveDeliveryItemsToLocalStorage();
                        updateFilterCounts();
                        updateStickyHeaderPositions();
                        renderDeliveryCards(activeFilter);
                        showMessage(`'${file.name}' 파일에서 ${deliveryItems.length}개의 항목을 불러왔습니다.`);
                    } catch (error) {
                        showMessage(`파일을 불러오는 중 오류가 발생했습니다: ${error.message}`, "오류");
                    } finally {
                        importDataInput.value = '';
                    }
                };
                reader.onerror = () => { showMessage("파일을 읽는 데 실패했습니다.", "오류"); importDataInput.value = ''; };
                reader.readAsText(file);
            }
        );
    });

    document.addEventListener('DOMContentLoaded', () => {
        try {
            resizeAppContainer();
            window.addEventListener('resize', resizeAppContainer);

            setVersionInfo();
            setupDelegatedEventListeners();

            // ▼▼▼ [이 블록 추가] ▼▼▼
            const mapSelectionContainer = document.getElementById('map-selection-container');
            const mapSelectButtons = mapSelectionContainer.querySelectorAll('.map-select-btn');

            const updateMapSelectionUI = () => {
                const selectedMap = localStorage.getItem('selectedMap') || 'naver';
                mapSelectButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.map === selectedMap);
                });
                // UI가 변경되었을 수 있으므로, 현재 보이는 카드들을 다시 렌더링
                if (['전체', '배송전', '배송중', '완료'].includes(activeFilter)) {
                    renderDeliveryCards(activeFilter);
                }
            };

            mapSelectionContainer.addEventListener('click', (event) => {
                const selectedButton = event.target.closest('.map-select-btn');
                if (selectedButton) {
                    const mapType = selectedButton.dataset.map;
                    localStorage.setItem('selectedMap', mapType);
                    updateMapSelectionUI();
                }
            });

            updateMapSelectionUI(); // 앱 시작 시 UI 초기화
            // ▲▲▲ [추가 끝] ▲▲▲

            clearAllCardsButton.addEventListener('click', () => {
                openConfirmationModal("모든 카드를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.", () => {
                    deliveryItems = [];
                    saveDeliveryItemsToLocalStorage();
                    renderDeliveryCards(activeFilter);
                    updateFilterCounts();
                    showToastMessage("모든 카드가 삭제되었습니다.");
                });
            });

locationModalCancel.addEventListener('click', closeDeliveryLocationModal);

        locationModalConfirm.addEventListener('click', () => {
                const selectedOption = document.querySelector('input[name="delivery-location"]:checked');
                if (!selectedOption) {
                    showMessage('배송 위치를 선택해주세요.');
                    return;
                }

                const itemNoToShow = currentLocationEditItemNo; // [이 줄 추가]
                const location = selectedOption.value;
                const currentTime = new Date().toLocaleString('ko-KR', dateTimeFormatOptions);
                
                handleStatusChange(currentLocationEditItemNo, '완료', currentTime, location, location);
                sortItemsByDistanceSilent();
                closeDeliveryLocationModal();
                
                showToastMessage(`${itemNoToShow}번: ${location} 완료`); // [이 줄 수정]
            });

            // 키보드 '이동' 키로 검색 실행 및 키패드 숨기기
            invoiceNumberInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault(); // 폼 제출 등 기본 동작 방지
                    
                    // 검색어는 이미 'input' 이벤트에서 실시간으로 적용되고 있으므로
                    // 여기서는 키보드를 숨기는 동작만 수행하면 됩니다.
                    invoiceNumberInput.blur(); 
                }
            });

            // --- 외부 스캐너 앱 연동 로직 ---
            setTimeout(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const hawbFromUrl = urlParams.get('hawb');
                const filterFromUrl = urlParams.get('filter');

                let initialLoad = true;
                if (hawbFromUrl) {
                    searchTerm = hawbFromUrl;
                    invoiceNumberInput.value = hawbFromUrl;
                } else {
                    initialLoad = false;
                }

                if (filterFromUrl && filterCategories.includes(filterFromUrl)) {
                    changeFilter(filterFromUrl, '', initialLoad);
                } else {
                    changeFilter('배송준비', '', true);
                }
            }, 0);
            // ------------------------------------

            const mainContent = document.getElementById('main-content-wrapper');
            refreshIndicator = document.getElementById('refresh-indicator'); // [이 줄 추가]
            let isMainContentTouched = false;

            refreshIndicator = document.getElementById('refresh-indicator'); // DOM 요소 할당

            mainContent.addEventListener('touchstart', (e) => {
                // 1. 거리순 정렬 상태일 때만 새로고침 준비
                if (mainContent.scrollTop === 0 && !isRefreshing && activeFilter === '배송중' && deliveryInProgressSortOrder === 'distance') {
                    pullStartY = e.touches[0].pageY;
                } else {
                    pullStartY = 0; // 그 외의 경우는 시작점을 0으로 초기화하여 동작 방지
                }
            }, { passive: true });

            mainContent.addEventListener('touchmove', (e) => {
                if (pullStartY === 0 || isRefreshing) return;
                const pullDistance = e.touches[0].pageY - pullStartY;
                if (pullDistance > 0) {
                    const opacity = Math.min(pullDistance / 100, 1);
                    refreshIndicator.style.opacity = opacity;
                    refreshIndicator.style.transform = `translateY(${Math.min(pullDistance, 100) - 48}px)`;
                }
            }, { passive: true });

            mainContent.addEventListener('touchend', (e) => {
                if (pullStartY === 0 || isRefreshing) return;
                const pullDistance = e.changedTouches[0].pageY - pullStartY;
                
                const resetIndicator = () => {
                    refreshIndicator.classList.remove('visible');
                    // 3. 아이콘을 확실하게 숨기기 위해 스타일 초기화
                    refreshIndicator.style.opacity = 0;
                    refreshIndicator.style.transform = 'translateY(-100%)';
                };

                // 1. 새로고침 실행 조건을 다시 한번 명확하게 확인
                if (pullDistance > 100 && activeFilter === '배송중' && deliveryInProgressSortOrder === 'distance') {
                    isRefreshing = true;
                    refreshIndicator.classList.add('visible');
                    
                    sortItemsByDistance(true).finally(() => {
                        isRefreshing = false;
                        pullStartY = 0;
                        resetIndicator(); // 3. 새로고침이 끝나면 아이콘 숨기기
                    });
                } else {
                    // 당기다 취소했거나, 조건이 맞지 않으면 아이콘 숨기기
                    resetIndicator();
                }
            });

            mainContent.addEventListener('touchstart', () => {
                isMainContentTouched = true;
            }, { passive: true });

            mainContent.addEventListener('touchend', () => {
                isMainContentTouched = false;
            }, { passive: true });
            
            window.addEventListener('touchmove', (event) => {
                if (!isMainContentTouched) {
                    // allow touch scrolling when a modal with its own scroll is open
                    try {
                        const modalOpen = (smartEditModal && smartEditModal.style.display === 'flex') ||
                                          (numberJumpModal && numberJumpModal.style.display === 'flex') ||
                                          (signatureModal && signatureModal.style.display === 'flex') ||
                                          (confirmationModal && confirmationModal.style.display === 'flex');
                        const withinScrollableModal = event.target && event.target.closest && (
                            event.target.closest('#smart-edit-scroll-area') ||
                            event.target.closest('#number-jump-list') ||
                            event.target.closest('.smart-edit-modal-content') ||
                            event.target.closest('.number-jump-modal-content')
                        );
                        if (modalOpen || withinScrollableModal) {
                            return; // allow normal scroll inside modal
                        }
                    } catch (e) {
                        // if any error, fall back to preventing default (safer)
                    }
                    event.preventDefault();
                }
            }, { passive: false });

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    // 외부 앱(네이버 지도 등)에서 바로 돌아왔을 때의 popstate 이벤트를 무시하기 위한 플래그
                    justReturnedFromExternalApp = true;
                    setTimeout(() => {
                        justReturnedFromExternalApp = false;
                    }, 500);

                }
            });

            history.pushState(null, '', location.href);
            window.addEventListener('popstate', (event) => {
    // 스마트 편집 모달이 열려있는 상태에서 popstate가 발생하면 모달을 닫습니다.
    if (smartEditModal.style.display === 'flex') {
        document.body.classList.remove('modal-open'); // body 스크롤 잠금 해제
        smartEditModal.style.display = 'none';
        currentEditItemNo = null;
        // 모달을 닫는 동작을 수행했으므로, 앱 종료 로직으로 넘어가지 않도록 여기서 함수를 종료합니다.
        return;
    }

    if (justReturnedFromExternalApp) {
        justReturnedFromExternalApp = false; // 사용 후 플래그 초기화
        history.pushState(null, '', location.href); // history 상태 복원
        return;
    }

    if (backButtonPressedOnce) {
        // 실제 앱 종료 의도. history.back()을 호출하여 앱을 닫거나 이전 페이지로 이동.
        // 이 부분은 그대로 둡니다.
        history.back(); 
        return;
    }

    backButtonPressedOnce = true;
    showToastMessage('한 번 더 누르면 종료됩니다.', 2000);
    setTimeout(() => {
        backButtonPressedOnce = false;
    }, 2000);

    // 사용자가 뒤로가기를 눌렀지만 앱을 종료하지 않았으므로,
    // pop된 history를 다시 push하여 현재 페이지에 머무르도록 합니다.
    history.pushState(null, '', location.href);
});

            document.body.addEventListener('touchstart', (event) => {
                const touch = event.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartTime = Date.now();
            }, { passive: true });

            // ▼▼▼ [추가] 스와이프 시작을 감지하는 touchmove 이벤트 리스너 ▼▼▼
            let isSwiping = false;
            document.body.addEventListener('touchmove', () => {
                if (!isSwiping) {
                    // 스와이프가 시작되면 모든 필터 버튼의 포인터 이벤트를 비활성화
                    filterButtonsContainer.querySelectorAll('button').forEach(btn => btn.style.pointerEvents = 'none');
                }
                isSwiping = true;
            }, { passive: true });

            document.body.addEventListener('touchend', (event) => {
                // ▼▼▼ [추가] 스와이프가 끝났으므로, 포인터 이벤트를 다시 활성화 ▼▼▼
                if (isSwiping) {
                    setTimeout(() => {
                        filterButtonsContainer.querySelectorAll('button').forEach(btn => btn.style.pointerEvents = 'auto');
                        isSwiping = false;
                    }, 100); // 약간의 딜레이를 주어 클릭 이벤트와 충돌 방지
                }

                if (signatureModal.style.display === 'flex' ||
                    confirmationModal.style.display === 'flex' ||
                    smartEditModal.style.display === 'flex' ||
                    numberJumpModal.style.display === 'flex') {
                    return;
                }

                const touch = event.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;

                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                const duration = Date.now() - touchStartTime;

                if (duration > 500 || Math.abs(diffX) < 75 || Math.abs(diffX) < Math.abs(diffY) * 2) {
                    return;
                }

                const currentFilterIndex = filterCategories.indexOf(activeFilter);
                
                if (diffX > 0) {
                    if (currentFilterIndex > 0) {
                        const prevFilter = filterCategories[currentFilterIndex - 1];
                        changeFilter(prevFilter, 'animate-slide-in-left');
                    }
                } else {
                    if (currentFilterIndex < filterCategories.length - 1) {
                        const nextFilter = filterCategories[currentFilterIndex + 1];
                        changeFilter(nextFilter, 'animate-slide-in-right');
                    }
                }
            });

            actionBarContainer.addEventListener('click', async (event) => {
                const button = event.target.closest('button');
                if (!button) return;

                const action = button.dataset.action;
                if (!action) return;

                const fabOptions = document.getElementById('fab-options');

                // 메인 버튼 클릭 시 옵션 토글
                if (action === 'toggle-fab') {
                    fabOptions.classList.toggle('expanded');
                    return;
                }

                // 옵션 버튼 클릭 시의 공통 동작
                if (button.parentNode.id === 'fab-options') {
                    fabOptions.classList.remove('expanded');

                    if (action === 'sort-distance') deliveryInProgressSortOrder = 'distance';
                    else if (action === 'sort-no') deliveryInProgressSortOrder = 'no';
                    else if (action === 'sort-time') completedSortOrder = 'time';
                    else if (action === 'sort-no-completed') completedSortOrder = 'no';
                }

                // 각 액션에 따른 실제 기능 실행
                switch (action) {
                    case 'sort-distance':
                        sortItemsByDistance();
                        break;
                    case 'sort-no':
                        sortItemsByNumber();
                        showToastMessage('순번순으로 정렬되었습니다.');
                        break;
                    case 'sort-no-completed':
                        completedSortOrder = 'no';
                        currentSortOrder = 'no';
                        deliveryItems.sort((a, b) => a.no - b.no);
                        renderDeliveryCards(activeFilter);
                        showToastMessage('순번순으로 정렬되었습니다.');
                        break;
                    case 'jump-no':
                        numberJumpList.innerHTML = '';
                        if (deliveryItems.length === 0) {
                            numberJumpList.innerHTML = '<p class="text-gray-500 col-span-5 text-center">카드가 없습니다.</p>';
                        } else {
                            const maxNo = Math.max(0, ...deliveryItems.map(item => item.no));
                            const itemsMap = new Map(deliveryItems.map(item => [item.no, item.status]));
                            for (let i = 1; i <= maxNo; i++) {
                                const status = itemsMap.get(i);
                                const btn = document.createElement('div');
                                btn.textContent = i;
                                if (status === '배송중') {
                                    btn.className = 'number-jump-item active';
                                    btn.dataset.no = i;
                                    btn.onclick = () => {
                                        const targetCard = document.querySelector(`[data-no="${i}"]`);
                                        if (targetCard) {
                                            targetCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                        }
                                        numberJumpModal.style.display = 'none';
                                    };
                                } else if (status) {
                                    btn.className = 'number-jump-item inactive';
                                } else {
                                    btn.className = 'number-jump-item placeholder';
                                    btn.innerHTML = ' ';
                                }
                                numberJumpList.appendChild(btn);
                            }
                        }
                        numberJumpModal.style.display = 'flex';
                        break;
                    case 'sort-time':
                        completedSortOrder = 'time';
                        currentSortOrder = 'time';
                        const completedItems = deliveryItems.filter(item => item.status === '완료');
                        const otherItems = deliveryItems.filter(item => item.status !== '완료');
                        completedItems.sort((a, b) => {
                            if (!a.deliveryCompletionTime) return 1;
                            if (!b.deliveryCompletionTime) return -1;
                            return a.deliveryCompletionTime.localeCompare(b.deliveryCompletionTime);
                        });
                        deliveryItems = [...completedItems, ...otherItems];
                        renderDeliveryCards(activeFilter);
                        showToastMessage('빠른 완료시간순으로 정렬되었습니다.');
                        break;
                }

                // 옵션 버튼을 클릭했을 때만 FAB UI를 즉시 갱신
                if (button.parentNode.id === 'fab-options') {
                    setTimeout(setupFab, 50);
                }
            });

            // --- 번호로 이동 모달 ---
numberJumpClose.addEventListener('click', () => {
    numberJumpModal.style.display = 'none';
});
// 배경 클릭으로 닫기 추가
numberJumpModal.addEventListener('click', (event) => {
    if (event.target === numberJumpModal) {
        numberJumpModal.style.display = 'none';
    }
});

// --- 스마트 주소 편집 모달 ---
smartEditExitBtn.addEventListener('click', closeSmartEditModal);

// 모달의 배경(회색 영역)을 클릭했을 때 닫히도록 이벤트 리스너 추가
smartEditModal.addEventListener('click', (event) => {
    // event.target은 사용자가 '정확히' 클릭한 요소를 가리킵니다.
    // 만약 사용자가 모달의 회색 배경 부분을 직접 클릭했다면,
    // event.target은 smartEditModal 요소 자체가 됩니다.
    // 하지만 모달 내부의 하얀 컨텐츠 영역이나 버튼을 클릭하면
    // event.target은 그 컨텐츠나 버튼이 되므로, 아래 조건문은 false가 되어
    // 모달이 닫히지 않습니다.
    if (event.target === smartEditModal) {
        closeSmartEditModal();
    }
});

// --- 서명 입력 모달 (예시) ---
cancelSignatureBtn.addEventListener('click', closeSignatureModal);
// 배경 클릭으로 닫기 추가
signatureModal.addEventListener('click', (event) => {
    if (event.target === signatureModal) {
        closeSignatureModal();
    }
});

// --- 로그 뷰어 관련 요소 및 이벤트 리스너 ---
            const viewLogsButton = document.getElementById('viewLogsButton');
            const clearLogsButton = document.getElementById('clearLogsButton');
            const logViewerModal = document.getElementById('log-viewer-modal');
            const logContentDisplay = document.getElementById('log-content-display');
            const logViewerClose = document.getElementById('log-viewer-close');
            const exportLogsButton = document.getElementById('exportLogsButton');

            viewLogsButton.addEventListener('click', () => {
                const logs = JSON.parse(localStorage.getItem(LOG_STORAGE_KEY)) || [];
                if (logs.length === 0) {
                    logContentDisplay.textContent = '기록된 오류 로그가 없습니다.';
                } else {
                    // 로그 객체를 보기 좋은 문자열로 변환
                    const formattedLogs = logs.map(log => {
                        return `[${log.timestamp}] - ${log.message}\n  at ${log.source} (${log.line}:${log.column})\n  Stack: ${log.stack}\n--------------------------------------`;
                    }).join('\n\n');
                    logContentDisplay.textContent = formattedLogs;
                }
                document.body.classList.add('modal-open');
                logViewerModal.style.display = 'flex';
            });

            clearLogsButton.addEventListener('click', () => {
                openConfirmationModal('모든 오류 로그 기록을 삭제하시겠습니까?', () => {
                    localStorage.removeItem(LOG_STORAGE_KEY);
                    showToastMessage('로그 기록이 삭제되었습니다.');
                });
            });

            logViewerClose.addEventListener('click', () => {
                document.body.classList.remove('modal-open');
                logViewerModal.style.display = 'none';
            });

            exportLogsButton.addEventListener('click', () => {
                const logs = JSON.parse(localStorage.getItem(LOG_STORAGE_KEY)) || [];
                if (logs.length === 0) {
                    showMessage('저장할 로그가 없습니다.');
                    return;
                }
                
                const formattedLogs = logs.map(log => JSON.stringify(log, null, 2)).join(',\n');
                const dataStr = `[\n${formattedLogs}\n]`;
                
                const today = new Date();
                const formattedDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
                const fileName = `SF-Error-Logs-${formattedDate}.txt`;

                const blob = new Blob([dataStr], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToastMessage(`로그가 '${fileName}' 파일로 저장되었습니다.`);
            });

            // --- 로그 뷰어 끝 ---

            const storedItems = localStorage.getItem('deliveryItems');
            if (storedItems) {
    let parsedItems = JSON.parse(storedItems);
    deliveryItems = parsedItems.map(item => {
        if (typeof item.addressLocation === 'undefined') {
            item.addressLocation = null;
        }
        if (typeof item.isStruckThrough === 'undefined') {
            item.isStruckThrough = false;
        }
        // isAddressValidated 속성이 없으면 기본값 true로 설정 (기존 데이터 호환)
        if (typeof item.isAddressValidated === 'undefined') {
            item.isAddressValidated = true;
        }
        return item;
    }).sort((a, b) => a.no - b.no);
}
            const storedScroll = localStorage.getItem('filterScrollPositions');
            if (storedScroll) filterScrollPositions = JSON.parse(storedScroll);
            updateFilterCounts();
            
            const urlParamsForCheck = new URLSearchParams(window.location.search);
            if (!urlParamsForCheck.has('hawb') && !urlParamsForCheck.has('filter')) {
                changeFilter('배송준비', '', true);
            }

        } catch (error) {
            console.error("초기화 오류:", error);
            document.body.innerHTML = `<div class="p-4 text-red-500">앱 로딩 중 오류가 발생했습니다. 오류: ${error.message}</div>`;
        }
    });
    </script>
</body>
</html>